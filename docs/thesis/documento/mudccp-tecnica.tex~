\chapter{\mudccp: Detalhes de Funcionamento e Estado Atual de Desenvolvimento}
\label{cap:mudccp-tecnica}

Neste capítulo, apresenta-se detalhes de funcionamento do protocolo \mudccps no
tocante a três principais aspectos, o cabeçalho de pacotes, o processo de
conexão e o mecanismo para controle de congestionamento. Neste capítulo,
apresentar-se detalhes técnicos de funcionamento do \mudccp, sendo este mais
dedicado aos leitores interessados em sua implementação. Na versão final deste
trabalho, este capítulo se tornará um \textit{draft} de RFC a ser submetida
para a IETF, justificando assim o seu teor mais técnico.

% Por este motivo,
% inevitavelmente torna-se um capítulo cansativo e o leitores mais experientes
% podem optar por continuar sua leitura a partir
% Capítulo~\ref{cap:metodosexperimentos}.

As palavras \aspas{deve}, \aspas{não deve}, \aspas{requerido}, \aspas{pode},
\aspas{não pode}, \aspas{recomendado} e \aspas{opcional}, incluindo suas
variações morfológicas, devem ser interpretadas como descrito na RFC
2119~\cite{RFC2119}, em inglês.

Todos os \textit{bytes} no \mudccp, tais como números de portas, números de
seqüência e valores para opções são transmitidos em \textit{network byte order}
(primeiro os bytes mais significativos).

Os números aleatórios no \mudccps são utilizados por razões de segurança e podem
ser escolhidos de acordo com a RFC 4086~\cite{RFC4086}.

\section{Cabeçalhos e Tipos de Pacotes do \mudccp}
\label{sec:tipodepacotesmudccp-tecnica}

Na Figura~\ref{fig:cabecalhomudccp48}, ilustra-se o cabeçalho genérico do
\mudccp. O nome genérico é justificado porque o cabeçalho assume um
formato diferente dependendo do tipo de pacote transmitido. De acordo com o
tipo de pacote transmitido, o \mudccps poderá utilizar até $48$ bits para
diferentes finalidades e, nestes casos, o tamanho total do cabeçalho passa a ser
de $20$ bytes. A descrição dos campos do cabeçalho genérico é apresentada a
seguir.

\begin{figure}[ht]
    \begin{center}
        \includegraphics[scale=0.5]{imagens/mudccp-generic-header.pdf}
    \end{center}
    \vspace{-1.2cm}
    \caption{Cabeçalho Genérico do protocolo \mudccp.}
    \label{fig:cabecalhomudccp48}
\end{figure}

\begin{description}

  \item[Porta de origem e destino:] cada porta possui um tamanho de $16$ bits.
Estes campos identificam a conexão, como acontece com os protocolos TCP, UDP e
o DCCP;

  \item[\textit{Offset} de dados:] ou simplesmente \emph{offset},
determina o tamanho do cabeçalho \mudccp, contando do início do cabeçalho até o
início de onde estão os dados da aplicação. Este campo tem o tamanho de $8$
bits;

  \item[CCVal:] é utilizado pelo controle de congestionamento do sistema
transmissor. O tamanho desse campo é de $4$ bits. Em uma transmissão \mudccps
entre um cliente e um servidor \mudccps ou de um \mdrel, o algoritmo para
controle de congestionamento de cada lado pode enviar $4$ bits de informação
para o lado oposto utilizando este campo para tal;

  \item[Tipo do pacote:] tamanho de $4$ bits. Este campo determina o tipo de
pacote que está sendo transmitido/recebido. Os possíveis valores desse campo
serão apresentados na Seção~\ref{subsec:tipopacote-mudccp};

  \item[\emph{Checksum}:] tamanho de $16$ bits. Este campo é utilizado para
checagem de erro, tradicionalmente como acontece em outros protocolosde
transporte;

  \item[Número de seqüência:] número de seqüência com $32$ bits utilizado para
transmitir requisições, podendo ser estendido para $48$ bits ao utilizar-se dos
próximos $16$ bits de conteúdo variável, o que dependerá do tipo de pacote a ser
transmitido. Como em outros protocolos, este campo identifica unicamente um
pacote transmitido na rede por um sistema final. O valor deste campo aumenta-se
em $1$ a cada pacote transmitido;

  \item[Opção:] tamanho de $4$ bits. Este campo é utilizado para sinalizar a
ativação ou não de alguma opção do \mudccp, por exemplo, para sinalizar se a
conexão entre um cliente e um relay \mudccps deve ser unicast ou multicast;

  \item[Reservado:] tamanho de $12$ bits. Campo reservado para utilizações
futuras;

  \item[Conteúdo variável:] tamanho de $48$ bits. Campo reservado para uso em
mecanismos específicos do \mudccps como, por exemplo, especificar o endereço IP
e número da porta do servidor \mudccps no momento de uma conexão
multicast.

\end{description}

\subsection{Tipos de Pacotes}
\label{subsec:tipopacote-mudccp}

No Capítulo~\ref{cap:mudccp}, apresentou-se a
Tabela~\ref{tab:tipospacotemudccp}, quando descreveu-se brevemente os tipos de
pacotes utilizados no \mudccp. No campo \emph{tipo do pacote} desse cabeçalho
genérico do \mudccp, determina-se que tipo de informação está contida no pacote
transmitido por um nó \mudccp. Isto permite que um nó execute uma determinada
ação ao recebe um pacote de um outro nó \mudccps e possivelmente gerando-se
outros pacotes como resposta. Nesta seção, apresenta-se detalhes do uso de cada
um dos tipos de pacotes, discutindo-se através de exemplos o preenchimento dos
campos do cabeçalho genérico apresentado anteriormente.

\subsubsection{\mudccp-Request}

O pacote do tipo \mudccp-Request, número 0 (0000$_2$), é utilizado pelo cliente
\mudccps para enviar um pedido de estabelecimento de conexão em modo multicast.
Quando transmitido na rede, um nó \mdrel\space captura esse tipo de pacote e
responde ao cliente \mudccp, notificando-o a respeito do fluxo de interesse e
que este é um dos \mdrels\space do servidor de mídia \mudccp. Considerando o
cabeçalho genérico do \mudccps ilustrado na
Figura~\ref{fig:cabecalhomudccp48}, os dois campos variáveis desse cabeçalho
são utilizados. Como pode-se observar na
Figura~\ref{fig:cabecalhomudccp-request}, o campo variável de $16$ bits é
utilizado para armezenar o número da porta do servidor de mídia \mudccps e o
segundo campo de $32$ bits é utilizado para armazenar o endereço IP desse
servidor. No processo de conexão, esses dois campos variáveis são lidos por um
\mdrel\space a fim de identificar o fluxo de mídia desejado pelo usuário e, caso
exista algum \mdrel\space recebendo o fluxo de mídia de interesse, o mesmo
responde pelo pedido de conexão como se fosse o servidor de mídia \mdrel\space
original, utilizando-se do pacote \mudccp-Response, descrito a seguir. Na
Seção~\ref{sec:conexaomudccp}, discutem-se detalhes do processo de
estabelecimento de conexão do \mudccp.

\begin{figure}[ht]
    \begin{center}
        \includegraphics[scale=0.5]{imagens/mudccp-header-request.pdf}
    \end{center}
    \vspace{-1.2cm}
    \caption{Cabeçalho do pacote \mudccp-Request.}
    \label{fig:cabecalhomudccp-request}
\end{figure}

\subsubsection{\mudccp-Response}

O pacote do tipo \mudccp-Response, número 1 (0001$_2$), é utilizado pelo
\mdrel\space para enviar uma resposta a um pedido de estabelecimento de conexão
enviado por um cliente \mudccps em modo multicast. Quando um nó \mdrel\space
recebe um pacote \mudccp-Request, este cria um pacote do tipo \mudccp-Response
para informar ao cliente \mudccps sobre o estabelecimento de conexão.
Neste caso e considerando o cabeçalho genérico do \mudccps ilustrado na
Figura~\ref{fig:cabecalhomudccp48}, os dois campos variáveis desse cabeçalho
são utilizados. Como pode-se observar na
Figura~\ref{fig:cabecalhomudccp-response}, o campo variável de $16$ bits é
utilizado para armezenar o número da porta do \mdrel\space e o segundo campo de
$32$ bits é utilizado para armazenar o endereço IP desse Relay. Desta forma, um
cliente \mudccps é capaz de ler pacotes do tipo \mudccp-Data transmitidos por um
\mdrel\space via multicast na rede e reproduzir a mídia de interesse. O tipo de
pacote \mudccp-Data e \mudccp-DataAck são descritos a seguir.

\begin{figure}[ht]
    \begin{center}
        \includegraphics[scale=0.5]{imagens/mudccp-header-response.pdf}
    \end{center}
    \vspace{-1.2cm}
    \caption{Cabeçalho do pacote \mudccp-Response.}
    \label{fig:cabecalhomudccp-response}
\end{figure}

\subsubsection{\mudccp-Data e \mudccp-DataAck}

Os pacotes do tipo \mudccp-Data e \mudccp-DataAck, números 2 e 4 (0010$_2$ e
0100$_2$), respectivamente, são utilizados por um \mdrel\space para enviar dados
em modo multicast a todos os clientes \mudccps interessados pelo fluxo por ele
transmitido. A partir do momento que um nó \mudccps se torna um nó \mdrel,
através do processo de eleição de nós \mdrels, descrito na
Seção~\ref{subsec:electrelsreps}, este começa a retransmitir, em modo multicast,
os dados vindos do servidor de mídia \mudccps ou de outro \mdrel,
utilizando pacotes dos tipos \mudccp-Data ou \mudccp-DataAck para este fim.
Neste caso, o cabeçalho genérico do \mudccps ilustrado na
Figura~\ref{fig:cabecalhomudccp48}, passa a ter a forma dos cabeçalhos
ilustrados nas Figuras~\ref{fig:cabecalhomudccp-data}
e~\ref{fig:cabecalhomudccp-dataack}, respectivamente. Note que ambos pacotes não
possuem os campos endereço IP e porta relacionados ao servidor de mídia \mudccp.
Esta decisão foi intencional para forçar que um cliente \mudccps realize o
pedido de conexão enviando o pacote \mudccp-Request, caso contrário um cliente
\mudccps poderia capturar um pacote \mudccp-Data sem que um \mdrel\space
soubesse de sua existência.

\begin{figure}[ht]
    \begin{center}
        \includegraphics[scale=0.5]{imagens/mudccp-header-data.pdf}
    \end{center}
    \vspace{-1.2cm}
    \caption{Cabeçalho do pacote \mudccp-Data.}
    \label{fig:cabecalhomudccp-data}
\end{figure}

\begin{figure}[ht]
    \begin{center}
        \includegraphics[scale=0.5]{imagens/mudccp-header-dataack.pdf}
    \end{center}
    \vspace{-1.2cm}
    \caption{Cabeçalho do pacote \mudccp-DataAck.}
    \label{fig:cabecalhomudccp-dataack}
\end{figure}

\subsubsection{\mudccp-Ack}

O pacote do tipo \mudccp-Ack, número 3 (0011$_2$), é utilizado por um nó
\mudccps para enviar confirmações de recepção de pacotes contendo dados
enviados com garantia de entrega. Por exemplo, um pacote \mudccp-Ack pode ser
enviado por um \mdrel\space para confirmar pacotes de definições de opções de
uma conexão \mudccps ou por um nó \mudccps ao aceitar ser eleito para ser
um \mdrep.

\begin{figure}[ht]
    \begin{center}
        \includegraphics[scale=0.5]{imagens/mudccp-header-ack.pdf}
    \end{center}
    \vspace{-1.2cm}
    \caption{Cabeçalho do pacote \mudccp-Ack.}
    \label{fig:cabecalhomudccp-ack}
\end{figure}

\subsubsection{\mudccp-Elect, \mudccp-ElectReply e \mudccp-ElectAck}

Os pacotes do tipo \mudccp-Elect, \mudccp-ElectReply e \mudccp-ElectAck, números
5, 6 e 7 (0101$_2$, 0110$_2$ e 0111$_2$), respectivamente, são utilizados por um
\mdrel\space ou por um cliente \mudccps para tratar do processo de eleição de
nós \mdreps\space ou de promoções de clientes \mudccps para se tornarem \mdrel.
Quando um \mdrel\space assume seu papel de repassar o fluxo de dados em modo
multicast para os clientes \mudccps interessados, o mesmo precisa obter
informações sobre o estado da rede. Para isto, um \mdrel\space cria um pacote do
 tipo \mudccp-Elect e transmite no canal multicast. Quando um cliente \mudccps
recebe um pacote deste tipo, o mesmo pode se candidatar a um \mdrep, enviando um
pacote do tipo \mudccp-ElectReply para o nó \mdrel\space que enviou o pacote
\mudccp-Elect. Como muitos nós \mudccps podem receber um pacote \mudccp-Elect, o
nó \mdrel\space utiliza o pacote do tipo \mudccp-ElectAck para confirmar a
eleição apenas de um subconjunto de clientes \mudccp.

Neste caso, para os pacotes \mudccp-Elect, \mudccp-ElectReply e
\mudccp-ElectAck, o cabeçalho genérico do \mudccps ilustrado na
Figura~\ref{fig:cabecalhomudccp48} passa a ter a forma dos cabeçalhos ilustrados
nas Figuras~\ref{fig:cabecalhomudccp-elect},
\ref{fig:cabecalhomudccp-electreply} e \ref{fig:cabecalhomudccp-electack},
respectivamente. Note que no pacote \mudccp-Elect, os campos variáveis de $16$ e
$32$ bits são utilizados para o \mdrel\space especificar um número de porta e
um endereço IP para o qual um cliente \mudccps enviará um pacote do tipo
\mudccp-ElectReply.

\begin{figure}[ht]
    \begin{center}
        \includegraphics[scale=0.5]{imagens/mudccp-header-elect.pdf}
    \end{center}
    \vspace{-1.2cm}
    \caption{Cabeçalho do pacote \mudccp-Elect.}
    \label{fig:cabecalhomudccp-elect}
\end{figure}

\begin{figure}[ht]
    \begin{center}
        \includegraphics[scale=0.5]{imagens/mudccp-header-electreply.pdf}
    \end{center}
    \vspace{-1.2cm}
    \caption{Cabeçalho do pacote \mudccp-ElectReply.}
    \label{fig:cabecalhomudccp-electreply}
\end{figure}

\begin{figure}[ht]
    \begin{center}
        \includegraphics[scale=0.5]{imagens/mudccp-header-electack.pdf}
    \end{center}
    \vspace{-1.2cm}
    \caption{Cabeçalho do pacote \mudccp-ElectAck.}
    \label{fig:cabecalhomudccp-electack}
\end{figure}

\subsubsection{Outros pacotes: \mudccp-RelayQuery,
\mudccp-RelayReply, \mudccp-AdvConn, \mudccp-CloseReq, \mudccp-Close
e \mudccp-Reset}

Os pacotes \mudccp-RelayQuery, \mudccp-RelayReply, \mudccp-AdvConn,
\mudccp-CloseReq, \mudccp-Close e \mudccp-Reset tem funções e formatos
similares aos outros pacotes anteriormente discutidos.

\section{Detalhamento do Processo de Conexão do \mudccp}
\label{sec:detalhe-proc-conexao}

Como discutido na Seção~\ref{sec:conexaomudccp}, o processo de conexão do
protocolo \mudccps acontece em duas fases. A fase 1 ocorre quando não existe
nenhum nó recebendo os dados desejados por um outro nó \mudccp. Já a fase 2
ocorre quando existe um nó na rede local recebendo um fluxo de dados de
interesse de um segundo nó interessado em também recebê-lo.

\subsection{Fase 1}

O primeiro pacote a ser utilizado neste processo é o \mudccp-Request,
apresentado na Figura~\ref{fig:cabecalhomudccp-request}, seguindo-se da forma
como discutido na Seção~\ref{subsec:conn-fase1}. Um aspecto importante ainda não
discutido é o tempo que um cliente deve esperar para receber um pacote do tipo
\mudccp-Response. Baseando-se em simulações de rede realizadas no contexto desse
trabalho e considerando os padrões de tecnologia de rede atualmente difundidas,
constatou-se ser suficiente que um cliente espere por um \mudccp-Response até no
máximo \ut{300}{ms}. Considerando-se uma rede local, este tempo é suficiente
para que um relay receba um pacote \mudccp-Request, processe-o e em seguida crie
e envie um \mudccp-Response de volta para o cliente.

Mesmo com este procedimento, é possível que no final do processo existam dois
nós relays presentes na mesma rede local, o que significa duas conexões na mesma
rede local recebendo o mesmo conteúdo de dados. Como discutido na
Seção~\ref{sec:problematica}, este tipo de situação deve ser evitada ao utilizar
protocolos orientados a conexão a fim de evitar o problema da tragédia dos
comuns, principalmente considerando os cenários de aplicações estudados neste
trabalho. Dito isto, deve-se garantir que existirá apenas um relay na rede local
e, para garantir esta premissa, outra decisão foi tomada. Caso um cliente inicie
uma conexão unicast com o servidor, mas receba um pacote \mudccp-Response
durante este tempo ou após o estabelecimento da conexão com o servidor, o mesmo
deve encerrá-la e obter os dados da conexão multicast transmitidos pelo relay
que o enviou o pacote \mudccp-Response. Antes de iniciar o processo de
encerramento de conexão, um cliente nessa situação deverá contactar primeiro
o nó relay e começar a receber o fluxo de dados de interesse e em seguida este
deverá parar de agir como nó relay.

No contexto deste trabalho, atualmente estão sendo avaliadas outras propostas
para definição do tempo que um cliente deve esperar por uma resposta ao pedido
de conexão enviado por ele. Porém, de acordo com uma série de simulações
realizadas até o momento, o uso de um tempo fixo de \ut{300}{ms} é suficiente e
ao mesmo tempo simples de se implementar, pois não requer quaisquer cálculos
extras, como por exemplo, cálculos baseados no valor do RTT ou na quantidade de
saltos entre o cliente e o servidor, práticas bastante adotadas por outros
protocolos de transporte, como o TCP. Independente disto, no protocolo \mudccps
permite-se que uma aplicação cliente altere o tempo de espera padrão por um
\mudccp-Response através da própria API de \textit{sockets} padrão BSD. Para
isto, o desenvolvedor da aplicação deve utilizar a função \textit{setsockopt} e
alterar o valor da opção SO\_SNDTIMEO, aumentando-se ou diminuindo-se o tempo
padrão de espera como desejado.

Como o pacote \mudccp-Request é transmitido na rede local com TTL igual a $1$,
o pacote \mudccp-Request inicial não será roteado para a rede externa e apenas
os nós da rede local o receberá. Note que se houvesse um \mdrel\space na rede
local, este responderia com um pacote do tipo \mudccp-Response, notificando o
cliente de que o mesmo passará a transmitir dados multimídia em modo multicast
relacionado à conexão desejada. Este procedimento está relacionado com a fase
$2$ do processo de estabelecimento de conexão do protocolo \mudccp, a seguir
discutida mais adiante.

Como exemplo de uma conexão \mudccps na fase $1$, suponha que um servidor de
mídias ao vivo esteja respondendo por conexões \textit{sockets} através do
endereço IP 200.200.211.5 e porta $8900$. Suponha também que um cliente com
endereço IP 200.200.200.1 e número de porta de origem $53900$ esteja interessado
pelo fluxo de dados enviado por este servidor. Neste caso, o cliente deve enviar
um pacote do tipo \mudccp-Request para o canal de controle do \mudccps com os
campos endereço IP e número de porta do servidor de mídia preenchidos com os
dados do \textit{socket} do servidor em questão, ou seja, endereço IP
200.200.211.5 e número de porta $8900$.

Na Figura~\ref{fig:cabecalhomudccp-request-exemplo}, ilustra-se como os campos
mais relevantes do cabeçalho do pacote \mudccp-Request devem ser preenchidos
para o caso do exemplo supracitado. Note que os valores estão preenchidos em
decimal para facilitar o entendimento, mas na prática esses valores devem estar
representados em binário. Note também que o campo IPPROTO do cabeçalho do IP
deve ser preenchido com o valor $253$. O valor para este campo é também regulado
pela IANA, que definiu o valor $253$ para protocolos experimentais, como é o
caso do \mudccp~\cite{protonum2008}.

\begin{figure}[ht]
    \begin{center}
        \includegraphics[scale=0.5]{imagens/mudccp-header-request-exemplo.pdf}
    \end{center}
    \vspace{-1.2cm}
    \caption{Exemplo do Cabeçalho do \mudccp-Request e do IP.}
    \label{fig:cabecalhomudccp-request-exemplo}
\end{figure}

Quando um nó cliente \mudccps se promove a relay, um outro procedimento deve
ser executado por ele. Após estabelecer a conexão, o relay já começa a receber o
fluxo de dados, mas em segundo plano, o relay deve continuar em busca de outro
nó relay mais próximo a ele. O objetivo desse procedimento é sempre evitar a
sobrecarga de acessos simultâneos no servidor partindo de uma mesma rede.

Para encontrar um relay em outras redes, um cliente deve enviar o pedido de
conexão utilizando o pacote do tipo \mudccp-Request, da mesma forma que da
primeira tentativa, porém com o valor de TTL igual a 2 em diante. Neste
caso, se o roteador da rede do cliente estiver participando do grupo multicast
do canal de controle do \mudccp, o mesmo deverá repassar o pacote
\mudccp-Request para suas interfaces de rede de saída. Se houver algum relay
correspondente ao pedido de conexão do cliente, este deverá responder ao cliente
em modo unicast, através do endereço IP e porta do \textit{socket} do cliente.

Note que o procedimento para descoberta de novos relays discutido anteriormente
não funcionará em redes que utilizam NAT~\cite{RFC1631} e, para a atual versão
do \mudccp, este assunto está fora do escopo deste trabalho. Como o procedimento
de encontrar um relay é baseado em busca por profundidade, não se pode conhecer
facilmente o limite de saltos até encontrar um relay correspondente a conexão
desejada pelo cliente. Desta forma, este procedimento de busca deve ser limitado
a no máximo $5$ saltos, ou seja TTL igual a $5$.

% Uma questão fundamental que pode levar a um impasse por parte do cliente é
% como este detecta se seu pacote \mudccp-Request, com TTL igual a 2 em diante,
% está sendo roteado para uma rede adjacente, mas nenhum relay foi encontrado ou
% se simplesmente seu pacote \mudccp-Request não foi roteado para uma rede
% adjante. Em ambos os casos, o comportamento será o mesmo, ou seja, nenhum pacote
% do tipo \mudccp-Response será recebido. Saber diferenciar esses dois casos é
% muito importante para evitar que o cliente continue tentando enviar pacotes
% \mudccp-Request com TTL acima de 2 quando se detecte que o roteador não
% está repassando este tipo de pacote para redes adjacentes. Na
% Seção~\ref{subsec:detectmulticast}, discute-se como o \mudccps lida com esta
% questão, onde serão apresentadas algumas estratégias para evitar este impasse.

% Como o processo de busca em profundidade adotada no protocolo \mudccps pode ser
% bastante oneroso, está em estudo uma estratégia alternativa caso nenhum relay
% seja encontrado utilizando o procedimento descrito anteriormente. Sendo assim,
% quando um cliente A não consegue encontrar nenhum relay, o mesmo pode enviar
% uma requisição da lista de relays de nível $1$ ao servidor que ele está
% conectado em modo unicast, ou seja, o cliente solicita a lista de todos os
% clientes conectados diretamente ao servidor, pois estes podem ser potenciais
% relays e estarem localizados mais próximos a ele. Na
% Seção~\ref{sec:arcdescorels}, discute-se como este processo funciona no
% protocolo \mudccp.

%  Este
% procedimento pode ser oneroso por dois motivos: (1) pode-se demorar para
% encontrar um relay e (2) mais dados de controle serão transmitidos sem a
% garantia de encontrar um relay, consumindo recursos de rede
% desnecessariamente.

\subsection{Fase 2}

A fase 2 inicia quando um relay cria um socket de repasse multicast.
Por exemplo, suponha um socket de repasse multicast no endereço IP
239.255.255.252 e número de porta $23456$. Como ilustrado na
Figura~\ref{fig:cabecalhomudccp-response-exemplo}, o relay deve preencher os
campos endereço IP e o número de porta do pacote do tipo \mudccp-Response com os
valores 239.255.255.252 e $23456$, respectivamente. Note que o pacote do tipo
\mudccp-Response a ser transmitido pelo nó relay ao cliente em resposta ao
pacote \mudccp-Request deve ser transmitido em modo unicast, neste caso para o
endereço IP 200.200.200.1 e na porta $53900$. Note que neste exemplo o endereço
IP do relay é o 200.200.200.2.

\begin{figure}[ht]
    \begin{center}
        \includegraphics[scale=0.5]{imagens/mudccp-header-response-exemplo.pdf}
    \end{center}
    \vspace{-1.2cm}
    \caption{Exemplo do Cabeçalho do \mudccp-Response.}
    \label{fig:cabecalhomudccp-response-exemplo}
\end{figure}

Um aspecto importante nesse processo é que todos os pacotes \mudccp-Response e
\mudccp-Ack utilizados no processo de conexão do \mudccp, transmitidos através
do canal de controle, devem ser transportados de forma confiável, ou seja, com o
uso de confirmação de recebimento utilizando o pacote do tipo \mudccp-Ack e
retransmissão caso pacotes desse tipo sejam perdidos.

% As regras de implementação
% desse mecanismo confiável de transmissão podem ser as mesmas adotadas no
% protocolo DCCP, descritos nas seções 6, 7 e 11 da RFC 4340~\cite{RFC4340}.

Para os casos em que um cliente encontre um relay localizado fora da sua rede
local, o relay deve iniciar um \textit{socket} unicast e repassar os dados
recebidos do servidor para o cliente em questão, criando-se portanto um
\textit{socket} para o canal de repasse. Para que o cliente saiba dessa decisão,
o relay deve enviar um pacote do tipo \mudccp-Response com os campos endereço IP
e número de porta do relay preenchidos com as informações do canal de repasse,
como ilustrado na Figura~\ref{fig:cabecalhomudccp-response-externo-exemplo}.
Nesse pacote, o primeiro bit do campo \textit{opção} deve está ativado para
sinalizar ao cliente que a transmissão é unicast e não multicast.

\begin{figure}[ht]
    \begin{center}

\includegraphics[scale=0.5]{imagens/mudccp-header-response-externo-exemplo.pdf}
    \end{center}
    \vspace{-1.2cm}
    \caption{Exemplo do Cabeçalho do \mudccp-Response quando o relay não está
na mesma rede do cliente.}
    \label{fig:cabecalhomudccp-response-externo-exemplo}
\end{figure}

\subsection{Conexão Rápida}
\label{subsec:fasccommudccp}

O processo de conexão do \mudccps requer que o cliente envie um pacote do tipo
\mudccp-Request para o canal de controle. Este procedimento objetiva fazer com
que o relay tenha conhecimento dos nós \mudccps interessados em receber o fluxo
de dados repassado pelo relay e, com este conhecimento, permitir que o relay
regule a taxa de transmissão a fim de controlar o congestionamento da rede. O
problema é que o processo de conexão do \mudccps pode demorar devido as
tentativas de busca para encontrar um nó relay. Sabendo-se disso, no \mudccps
adicionou-se um mecanismo que permite um cliente estabelecer uma conexão de
forma mais rápida.

A conexão rápida do \mudccps é opcional e funciona da seguinte forma.
Quando um cliente \mudccps se torna um nó relay e começa a enviar dados
utilizando o pacote do tipo \mudccp-Data, o mesmo pode anunciar no canal de
controle suas conexões ativas e qual canal de repasse está sendo utilizado.
Neste caso, o relay utiliza o pacote do tipo \mudccp-AdvConn para anunciar,
através do canal de controle, suas conexões de repasse ativas e clientes
interessados em obter o conteúdo multimídia correspondente pode passar a
receber pacotes de dados no canal especificado no anúncio do relay. O anúncio
do conexão de repasse deve ser enviado a cada \ut{30}{s}.

Na Figura~\ref{fig:anuncio-advconn}, ilustra-se o cabeçalho do pacote
\mudccp-AdvConn para o caso em que um nó relay tem uma conexão de repasse na
porta $32231$ através do endereço IP 200.200.200.2.

\begin{figure}[ht]
    \begin{center}

\includegraphics[scale=0.5]{imagens/mudccp-header-advconn-exemplo.pdf}
    \end{center}
    \vspace{-1.2cm}
    \caption{Exemplo do Cabeçalho do \mudccp-AdvConn para anúncio de conexão
de repasse.}
    \label{fig:anuncio-advconn}
\end{figure}

%
% \subsubsection{Desconexão de um nó relay}
%
% \subsubsection{Desconexão de um nó reporter}

%\subsection{Detecção do Modo Multicast}
%\label{subsec:detectmulticast}

% You could listen on 224.0.0.1 for 125s for an IGMP query but this wont detect
% static multicast routing.
% 
% The only sure method is to have a transport to another host on a different LAN
% segment and test a join & send. Still then dependent upon sparse or dense mode
% routing its not an immediate response.
% 
% ----
% 
% The best way is you have to have atleast 2 nodes on the both sides of a ROUTER.
% Then you can run a very small Utility written in C Lang called "mcfirst" and a
% sender "vlc" or "smtext" etc. So Scene is
% 
% PC1 (Sender)---->>-- Router ---->>-----PC2 (Receiver)
% 
% If you have any issue you can send message to me.
% 
% Above works for both IPv4 and IPv6

\section{Algoritmo de Controle de Congestionamento Multicast}
\label{sec:mcc}

Na Seção~\ref{subsec:mudccp-mcc}, apresentou-se uma visão geral do algoritmo de
controle de congestionamento para transmissões multicast (\mudccp-MCC) empregado
no \mudccp. Nesta seção, apresenta-se detalhes do funcionamento deste algoritmo,
iniciando-se com algumas considerações. Diante das adaptações no algoritmo
original do TFRC mencionadas na Seção~\ref{subsec:mudccp-mcc}, para definir um
algoritmo de controle de congestionamento em transmissões multicast, deve-se
considerar alguns requisitos que serão discutidos a seguir.

\begin{enumerate}[{\tab}1.]
 \item Uma equação para controle de congestionamento deve ser definida em
função de parâmetros obtidos sobre a rede, tais como a taxa dos eventos de
perda e o RTT.
 \item Como cada receptor deve medir a taxa dos eventos de perda, deve-se
definir um filtro que represente uma medição estável da taxa de transmissão para
as condições atuais da rede, mas que o algoritmo seja sensível quando tais
condições mudarem.
 \item Como cada receptor deve estimar o RTT entre ele e o transmissor, deve-se
elaborar uma forma efetiva de calcular este parâmetro sem excessivas trocas de
dados de controle.
 \item Como cada receptor deve calcular a taxa de transmissão e enviá-la para o
transmissor, deve-se definir um filtro para determinar qual é a melhor taxa de
transmissão dentre as diversas taxas de transmissão enviadas pelos nós
receptores.
 \item Como cada receptor deve enviar o cálculo da sua taxa de transmissão,
deve-se determinar a frequência de envio desse relatórios para o nó transmissor.
Essa taxa não pode ser muito alta para não causar o problema da \textit{explosão
de feedbacks}, porém, se essa taxa for muito baixa, o \mudccp-MCC irá demorar
para reagir às mudanças do estado da rede.
\end{enumerate}

\subsubsection{Para as discussões a seguir, considere:}

\begin{enumerate}

 \item $\hat{c}$, uma transmissão \mudccp;

 \item $\hat{s}$, o nó servidor de $\hat{c}$;

 \item $|X|$, a quantidade de elementos de um conjunto $X$ de nós;

 \item \textit{link($e_1$, $e_2$)}, uma função que relaciona o elemento $e_1$ a
um $e_2$, com $e_1$ e $e_2$ pertencente a dois conjuntos diferentes e $e_1$ não
podendo estar relacionado com mais de um elemento;

 \item $C$, o conjunto de clientes tal que $C = \{c_{i}/c_{i}$ é um nó
participante de $\hat{c}\}$;

 \item $S$, o conjunto de relays tal que $S = \{s_{i}/s_{i}$ é um relay$\}$ e
$S \subset C$;

 \item $W$, o conjunto de todos os clientes não relays, ou seja, $W = C-S$;

 \item $W_i$, um subconjunto $i$ de $W$ tal que $W_i = \{\hat{w}_i /$
\textit{link($\hat{w}_{i}$, $s_i$)}$\}$. Ou seja, $\bigcap_{i=1}^{n} W_i$ =
{$\emptyset$}, para $n$ correspondendo a quantidade de subconjuntos derivados
de $W$. Isto significa que um cliente $\hat{w}_i$ não pode pertencer a dois
subconjuntos $W_i$ e $W_j$, com $i \neq j$, $ 1 \leq i \leq $ \textit{n} e $ 1
\leq j \leq $ \textit{n}. Na prática, um subconjunto $W_i$ é um grupo multicast
e um cliente $\hat{w}_i$ não pode pertencer a dois grupos multicast distintos
para receber o mesmo conteúdo, uma vez que cada grupo multicast está
relacionados apenas com um relay $s_i$;

 \item $R$, o conjunto de todos os clientes reporters em uma transmissão
$\hat{c}$;

 \item $R_i$, um subconjunto $i$ de $R$ tal que $R_i =
\{\hat{r}_{i}/$ link($\hat{r}_{i}$, $s_i$)$\}$ e $R_i \subset W_i$ ou $R_i
\subseteq W_i$. Ou seja, $\bigcap_{i=1}^{n} R_i$ = {$\emptyset$}, para $n$
correspondendo a quantidade de subconjuntos derivados de $R$. Isto significa
que um reporter $\hat{r}_i$ não pode pertencer a dois subconjuntos $R_i$ e
$R_j$, com $i \neq j$, $ 1 \leq i \leq $ \textit{n} e $ 1 \leq j \leq $
\textit{n}. Na prática, isto quer dizer que um reporter $\hat{r}_i$ não pode
enviar relatórios sobre congestionamento para mais de um relay $s_i$.
 \label{i:cons-mcc-ri}

\end{enumerate}

\subsection{Determinando a Taxa de Transmissão para $s_i$}

A taxa de transmissão de um nó $s_i$ é definida por $T_{s_{i}}$ e calculada
através da Equação~\ref{eq:srtx} em função de $T_{\hat{r}_i}$. No \mudccp-MCC,
cada elemento de $R_i$, ou seja, cada reporter $\hat{r}_i$ deve calcular seu
valor para $T_{\hat{r}_{i}}$ e enviá-lo para seu $s_i$ correspondente. O relay
$s_i$, por sua vez, utiliza-se da Equação~\ref{eq:srtx} para calcular sua taxa
de transmissão e a utilizará para transmitir dados em modo multicast para
um grupo de clientes $W_i$. O cálculo para $T_{\hat{r}_{i}}$ é
feito através da Equação~\ref{eq:trfcmudccp}, em função da taxa de perda $p$
percebida em $\hat{r}_{i}$ e pelo valor do RTT $t_{rtt}$ entre um certo
$\hat{r}_{i}$ e seu respectivo $s_{i}$.

\begin{equation}
T_{s_{i}} = \frac{\sum_{i=1}^{n} T_{\hat{r}_{i}}}{n}
\label{eq:srtx}
\end{equation}

No caso do \mudccp-MCC, a estratégia é que o valor da taxa de transmissão para
um $s_i$ seja tão próximo ao valor de $T$ quanto possível, tornando-o um
algoritmo \textit{TCP-Friendly}. Um fluxo de dados é considerado
\textit{TCP-Friendly} quando este não degrada a taxa de transmissão de um fluxo
de dados TCP mais do que outro fluxo TCP degradaria quando começasse a ser
transmitido na rede.

Como o valor para $T$ é uma aproximação da taxa de transmissão que um fluxo de
dados TCP obteria e $s_i$ segue esta condição, então se estiverem sendo
transmitidos fluxos de dados TCP concorrentes com fluxos de dados \mudccp, o
valor calculado para a taxa de transmissão de um fluxo de dados $s_i$ será
equivalente aos valores das taxas de transmissão dos fluxos de dados
transmitidos através do TCP. Essa preocupação é muito importante no contexto do
\mudccps porque atualmente o TCP é o protocolo mais utilizado na Internet,
sendo de fundamental importância tornar os fluxos de dados transmitidos com o
\mudccps equinimes com relação aos fluxos de dados transmitidos com TCP.

Desta forma, seja $T_{\hat{r}_{max}}$ o valor da maior taxa de transmissão
recebida por um $s_i$ e enviada por algum $\hat{r}_i$, pertencente a $R$ em
uma transmissão $\hat{c}$. No \mudccp-MCC, partiu-se do pressuposto de
que se nenhum nó $s_i$ ou $\hat{s}$ exceder o valor de $T_{\hat{r}_{max}}$ em
uma conexão $\hat{c}$, então o fluxo \mudccps será \textit{TCP-Friendly}.

Teoricamente, o \mudccps seria um protocolo \textit{TCP-Friendly} se
$T_{\hat{r}_{max}} = T_{s_{i}}$ em $s_i$. Porém, optou-se por utilizar a média
aritimética dos valores
$T_{\hat{r}_i}$ (Equação~\ref{eq:srtx}) porque na prática diversos fatores podem
alterar drasticamente o estado da rede
no instante em que se utilizar $T_{\hat{r}_{max}}$. Com esta decisão,
define-se uma margem de segurança evitando que o \mudccp-MCC alcance o limite
superior para o valor da taxa de transmissão de um fluxo transmitido com TCP.
Além disso, a média aritimética suaviza os valores subsequentes para $s_i$,
mesmo se algum $\hat{r}_x$ envie para $s_i$ um valor $T_{\hat{r}_x}$ muito alto
ou muito baixo com relação aos demais valores $T_{\hat{r}_i}$.

\subsection{Ajuste da Taxa de Transmissão}

O ajuste da taxa de transmissão $T_{s_{i}}$ de um relay $s_i$ ocorre
periodicamente de acordo com os valores de cada taxa de transmissão
$T_{\hat{r}_i}$ calculada por um nó $\hat{r}_i$. Todo nó $\hat{r}_i$ deve enviar
ao nó transmissor o cálculo de $T_{\hat{r}_i}$ e $s_i$ deve ajustar sua taxa de
transmissão para o valor obtido através da Equação~\ref{eq:srtx}.

% Cada nó $T_{\hat{r}_i}$ deve enviar seu valor para $T_{\hat{r}_i}$ em uma
% frequência determinada pela Equação~\ref{eq:freqsendtx} em função do valor de
% $p$ e do $RTT$. A Equação~\ref{eq:freqsendtx}
%
% \begin{equation}
% F(rtt) = \frac{1}{p\times\log{rtt}}
% \label{eq:freqsendtx}
% \end{equation}
% Na
% Seção~\ref{subsec:freqenvrel}, descreve-se como é calculada a frequência que
% um
% reporter $\hat{r}_i$ deve enviar para $s_i$ seu valor de $T_{\hat{r}_i}$.

Sendo assim, a frequência que $s_i$ deve ajustar sua taxa de transmissão
$T_{s_{i}}$ é determinada por cada nó em $R_i$. Toda vez que $\hat{r}_x$ enviar
para $s_i$ seu novo valor $T_{\hat{r}_x}$, $s_i$ deve recalcular sua taxa de
transmissão $T_{s_{i}}$ utilizando a Equação~\ref{eq:srtx}, mantendo-se o
restante dos valores inalterados de $T_{\hat{r}_i}$ neste cálculo.

Note que um nó $\hat{r}_x$ deve enviar um novo valor para $T_{\hat{r}_x}$ todas
as vezes que um novo intervalo de perda for determinado. Um intervalo de perda
é determinado por consecutivas perdas de pacotes, desde do primeiro pacote
perdido até o último pacote perdido seguido de um pacote recebido com sucesso.
Na Seção~\ref{subsec:mcclossevent}, explica-se com mais detalhes como funciona
o processo que determina um intervalo de perda.

Uma outra observação com relação ao ajuste da nova taxa de transmissão de $s_i$
está relacionado ao fato de um nó $\hat{r}_i$ se desconectar ou perder
repentinamente sua conexão. Caso isto aconteça com algum nó $\hat{r}_x$, seu
valor $T_{\hat{r}_x}$ deverá ser desconsiderado no cálculo da nova taxa de
transmissão $T_{s_{i}}$. Existem duas formas que um relay $s_i$ pode perceber a
desconexão de um ou mais nós $\hat{r}_i$. A primeira forma é quando um nó
$\hat{r}_x$ envia explicitamente um pedido de desconexão para $s_i$,
tal processo é discutido na Seção~\ref{subsec:mudccp-desconexao}, ao passo que a
segunda forma é quando um contador de tempo de manutenção de conexão, mantido
pelo relay $s_i$ se expira, tal processo é discutido na
Seção~\ref{subsec:electrelsreps}. Com esta medida, evita-se utilizar um taxa de
transmissão $T_{s_{i}}$ incorreta, portanto não correr o risco de utilizar uma
taxa de transmissão não condizente com o estado atual da rede.

\subsection{Taxa de Eventos de Perda $p$}
\label{subsec:mcclossevent}

A taxa de eventos de perda $p$, definido na Equação~\ref{eq:trfcmudccp}, é
determinada por cada \mdrep\space $\hat{r}_i$ de forma similar ao TFRC. No caso
do \mudccp-MCC, cada $\hat{r}_i$ agrega as perdas de pacotes que
ocorrem dentro de um evento de perda, definido por uma ou mais perdas de pacotes
no espaço de tempo de um RTT. O número de pacotes entre eventos de perdas
consecutivos é chamado de intervalo de perda. Para o cálculo de $p$, utiliza-se
a média dos tamanhos dos intervalos de perda, calculada através da média
ponderada dos $m$ mais recentes intervalos de perdas $l_k, \dots, l_{k-m+1}$
seguindo a Equação~\ref{eq:losseventmean}. O conjunto de todos os intervalos de
perda é chamado de \textit{histórico de perdas}.

\begin{equation}
l_{avg} = \frac{\sum_{i=0}^{m} w_i \times l_{k-i}}{\sum_{i=0}^{m} w_i}
\label{eq:losseventmean}
\end{equation}

Os pesos $w_i$ são escolhidos de tal forma que os intervalos de perdas mais
recentes recebem pesos mais altos, decrescendo-os gradualmente até $1$
para os intervalos de perdas mais antigos. Por exemplo, para $8$ intervalos de
perda $m$, pode-se utilizar os pesos $w = [5, 5, 5, 5, 4, 3, 2, 1]$. Ao
utilizar-se da média ponderada para o cálculo da média dos tamanhos dos
intervalos de perda, obtem-se mudanças mais suaves para o valor de $l_{avg}$ à
medida que os tamanhos dos intervalos de perdas se tornam mais antigos. Para
grandes valores de $m$, obtem-se mudanças mais suaves para $p$ ao longo do
tempo, porém isto também reduz a capacidade de resposta e portanto a equidade do
protocolo. No TFRC, recomenda-se utilizar valores de $m$ entre $8$ e $32$ e por
este motivo no \mudccps é considerada esta recomendação. A
Equação~\ref{eq:losseventmean} é definida na RFC 3448~\cite{RFC3448} e foi
mantida no \mudccp. O protocolo DCCP também utiliza essa mesma abordagem no
algoritmo de controle de congestionamento CCID-3~\cite{RFC4342}.

Uma vez definido como determina-se a média dos tamanhos dos intervalos de
perda, a taxa dos eventos de perda $p$ é definido pelo inverso de $l_{avg}$,
definido na Equação~\ref{eq:losseventrate}. Como um intervalo de perda é
definido em função do número de pacotes entre de eventos de perdas consecutidos,
o mais recente evento de perda não pode influenciar na taxa do evento de perda,
por isto utilizou a função \textit{max} no denominador da
Equação~\ref{eq:losseventrate}.

\begin{equation}
p = \frac{1}{max(l_{avg}(k), l_{avg}(k-1))}
\label{eq:losseventrate}
\end{equation}

% Para mais discussões acerca de como funciona o mecanismo para medição dos
% intervalos de perda, consulte a referência~\cite{CONG:Floyd00:TFRC:art}.

% Um aspecto importante no cálculo do valor de $p$ é determinar o seu valor
% inicial.

\subsection{Cálculo do RTT}
\label{subsec:mccrtt}

O cálculo do RTT realizado no \mudccp-MCC é feito apenas pelos nós
reporters e funciona da seguinte forma. Um nó $\hat{r}_i$ transmite ao seu
respectivo relay $\hat{s}_i$ um pacote de controle e inicia um marcador de
tempo. Ao receber uma resposta do nó relay $\hat{s}_i$, o nó reporter
$\hat{r}_i$ pára o marcador de tempo e utiliza este tempo chamado de
$RTT_{instant}$ para calcular o valor do próximo $RTT$ de acordo com a
Equação~\ref{eq:calcrtt}.

\begin{equation}
RTT = \beta \times RTT_{instant} + (1 - \beta) \times RTT
\label{eq:calcrtt}
\end{equation}

Note que no \mudccp-MCC não se utiliza o valor de $RTT$ instantâneo
($RTT_{instant}$) como o valor do $RTT$, mas sim utiliza-se de um mecanismo
para suavizar as mudanças do $RTT$ ao longo do ciclo de vida de uma conexão.
Desta forma, procura-se evitar que valores absurdos de $RTT_{instant}$ -- muito
baixos ou muito altos com relação aos valores medidos anteriormente --
influenciem demasiadamente na taxa de transmissão $T_{\hat{s}_i}$.

O mecanismo mencionado anteriormente para suavizar as medições do valor de
$RTT$ é chamado de Médias Móveis Exponencialmente Ponderadas ou
\textit{Exponentially Weighted Moving Average} (EWMA). O EWMA foi primeiramente
utilizado para índices financeiros de medição de risco, onde a série de retornos
diários com $n$ observações é ponderada por um fator de decaimento. As
observações mais recentes no tempo são ponderadas com um peso maior que as
observações mais antigas. O peso de uma observação decai exponencialmente com
$n$. Em seguida, utilizou-se EWMA em medições de tempo do $RTT$ em protocolos
como o TCP. Como trata-se de uma estratégia conhecida para medição de RTT, no
\mudccp-MCC manteve-se o mesmo mecanismo, principalmente por já ter sido
exaustivamente testado e utilizado. Tanto no TCP quanto no caso do \mudccp,
utiliza-se $\beta = 0.25$ para o cálculo do valor de $RTT$ através da
Equação~\ref{eq:calcrtt}~\cite{kurose2006}.

Porém, diferentemente do mecanismo de medição de $RTT$ no TCP e no TFRC, os nós
reporters $\hat{r}_i$ são os responsáveis pela medição do $RTT$ e não o nó
transmissor. Um aspecto importante na medição do RTT está relacionado com o
início de uma conexão \mudccp, pois não se sabe o valor para $RTT_{instant}$
até o final do processo de estabelecimento de uma conexão. Nesse caso, deve-se
utilizar um valor consideravelmente alto para evitar taxas de transmissões
$T_{\hat{s}_i}$ muito maiores do que a rede tem capacidade de suportar. No
\mudccp, utiliza-se o valor inicial de $RTT_{instant}$ igual a \ut{150}{ms}.
Quando um nó $\hat{r}_i$ enviar um pedido de conexão utilizando o pacote do tipo
\mudccp-Request, o mesmo deve realizar a sua primeira medição do valor de
$RTT_{instant}$, iniciando-se o marcador de tempo para o cálculo do RTT quando
enviar o primeiro \mudccp-Request e parando-o quando receber o pacote do tipo
\mudccp-Response. Em seguida, deve-se acionar o mecanismo de cálculo de
$T_{\hat{r}_i}$, caso o respectivo nó $\hat{r}_i$ seja eleito como reporter.

% - A frequencia que é feito (pode ser proporcional ao valor de p), quanto maior
% p, provavelmente maior será rtt

% \subsection{Envio da Taxa de Transmissão}
% \label{subsec:txetime}
%
% FALAR AQUI DO FORMATO DO PACOTE

% \subsection{Frequência de Envio de Relatórios}
% \label{subsec:freqenvrel}
%
% Essa taxa não pode ser muito alta para não causar o problema da
% \textit{explosão
% de feedbacks}, porém, se essa taxa for muito baixa, o \mudccp-MCC irá demorar
% para reagir às mudanças do estado da rede. Para o caso que a taxa de envio de
% relatórios for muito baixa, dois
% problemas agravantes podem ser observados. O primeiro problema é se a taxa de
% transmissão estiver muito alta e o nó receptor perceber muitas perdas de
% pacotes. Neste caso, o transmissor pode levar a rede a altos níveis de
% congestionamento e, como consequência, o \mudccp-MCC pode não manter a
% equidade
% para com fluxos do protocolo TCP. E o seguindo problema é se a taxa de
% transmissão praticada pelo nó transmissor estiver muito baixa e o nó receptor
% calcular uma taxa maior do que a atual. Neste caso, o algoritmo \mudccp-MCC
% pode
% sub-utilizar o canal de transmissão por um determinado instante até que a nova
% taxa de transmissão seja enviada para o nó transmissor.

\section{Considerações sobre Implementação}

O núcleo do protocolo \mudccps foi implementado no simulador NS-2 e a versão atual
do protocolo já permite a execução de transmissão de dados. Com o
desenvolvimento preliminar do protocolo \mudccps no simulador NS-2, permitiu-se
a execução de diversas simulações a fim de avaliar o comportamento do protocolo
considerando diversas configurações.

Em linhas gerais, a implementação no referido simulador de rede permite a
comunicação entre os nós através dos modos de transmissão multicast e unicast.
Foram implementados os tipos de pacotes do \mudccps e os processos de
estabelecimento de conexão, incluindo o processo de uso de nós relays, troca
de dados em modos multicast e unicast e os algoritmos para controle de
congestionamento, incluindo o uso de nós reporters.

Contudo, não foi implementado o arcabouço de extensão para permitir o
desenvolvimento de novos algoritmos para o processo de conexão, descoberta e
seleção de nós, adaptação de fluxo de dados e tolerância a falhas. Tal
implementação será feita no núcleo do sistema operacional Linux, juntamente com
todos os mecanismos básicos para o funcionamento do \mudccp.

A proposta é de implementar um arcabouço de extensão para as funções previstas
no \mudccp, permitindo-se o desenvolvimento e adição de novos algoritmos para
as funcionalidades supracitadas, de modo que torne o \mudccps flexível para
permitir que qualquer aplicação os utilizem.

Na prática, um cenário desejado para essa proposta de implementação do \mudccps
é que o desenvolvedor possa configurar quais algoritmos deseja utilizar em sua
aplicação, permitindo-se que estes sejam alterados em modo de execução da
da mesma. Neste caso, suponha um algoritmo de descoberta de nós chamado
\textit{DN-1}, um algoritmo para controle de congestionamento chamado
\textit{CC-2}, um algoritmo de tolerância a desconexão \textit{TD-3}; um
algoritmo de adaptação de fluxo \textit{AF-4} e um algoritmo para reciprocidade
\textit{R-2}. As implementações de tais algoritmos serão feitas na camada de
transporte, acoplando-as em forma de módulos do sistema operacional ao protocolo
\mudccp. Em seguida, as aplicações podem selecionar quais algoritmos melhor se
adequa as suas necessidades, com o \mudccps sendo responsável por:

\begin{enumerate}

  \item carregar o conjunto de algoritmos \textit{A = \{DN-1, CC-2, TD-3, AF-4,
R-2\}};

  \item definir os parâmetros iniciais para cada um dos algoritmos em A,
definidos pela aplicação;

  \item executar funções preliminares para ajustes iniciais, tais como informar
aos nós participantes de uma transmissão quais dos algoritmos estão sendo
utilizados (o conjunto \textit{A}) e quais outros estão disponíveis;

  \item executar os algoritmos em momentos apropriados de acordo com os eventos
de rede, notificando a aplicação caso necessário e desejável pela aplicação;

  \item descarregar os algoritmos quando não forem mais necessários e informar
aos nós parceiros.

\end{enumerate}

Desta forma, um nó servidor poderá solicitar que seus nós clientes carreguem um
determinado módulo, dependendo da sua disponibilidade nos nós clientes. Neste
caso, o \mudccps controlará todo o processo de carregamento dos mesmos.

Com isso, o \mudccps se tornará um protocolo extensível que gerencia quais
algoritmos devem ser executados em cada ponto de extensão. Esses algoritmos
podem ser adicionados ao protocolo através de módulos do sistema operacional,
carregáveis utilizando-se comandos como o \textit{modprobe} (no Linux, por
exemplo) e manipulados (passagem de parâmetros) pela aplicação através de uma
API de programação, por exemplo, utilizando-se as primitivas
\textit{setsockopt()} e \textit{getsockopt()} da especificação \textit{BSD
Socket API}~\cite{1197551}.

Para que as aplicações possam utilizar o \mudccp, o protocolo deve ser
compatível com todas as funções prevista na especificação \textit{BSD Socket
API}, são elas: \textit{socket()}, \textit{bind()}, \textit{listen()},
\textit{connect()}, \textit{accept()}, \textit{send()}, \textit{recv()},
\textit{write()}, \textit{read()}, \textit{sendto()}, \textit{recvfrom()},
\textit{close()}, \textit{select()}, \textit{setsockopt()},
\textit{getsockopt()} e \textit{pull()}.

Outros trabalhos podem ser desenvolvidos para tornar o \mudccps compatível com o
padrão de \textit{sockets} do sistema operacional Windows, conhecido pelo nome
de \textit{winsock}. Todavia, por ser um sistema operacional de código fechado,
a implementação do \mudccps só será possível após sua padronização em forma de
RFC.

% http://en.wikipedia.org/wiki/Berkeley_sockets

\section{Sumário do Capítulo}

Neste capítulo, apresentou-se uma visão técnica do \mudccp. Discutiu-se o uso e
as aplicabilidades dos diferentes tipos de pacotes do \mudccp, onde foram
abordados exemplos para a execução das funcionalidade de tal protocolo.

Em seguida, apresentou-se discussões acerca do processo de estabelecimento de
conexão do \mudccps e uma formalização do algoritmo para controle de
congestionamento em modo de transmissão multicast empregado no
\mudccps através do uso de teoria de conjuntos.

Por fim, apresentou-se algumas considerações importantes quanto a implementação
do \mudccps em sistemas operacionais, tais como o Linux (\textit{BSD Socket
API}) e Windows (\textit{Winsock API}).