\chapter{Global Media Transmission Protocol (\mudccp)}
\label{cap:mudccp}

O \textit{Global Media Transmission Protocol} (\mudccp) é um protocolo de rede
que atual nas camadas de transporte e de rede (\textit{crossing-layer})
projetado para operar na Internet, a ser utilizado em sistemas de distribuição
de fluxos dados multimídia ao vivo. Trata-se de um protocolo baseado em uma
arquitetura híbrida P2P/CDN, onde os dados de um ou mais sistemas são
transmitidos através de uma rede de favores P2P, onde os nós cooperam entre si a
fim de obterem um conteúdo multimídia de interesse ao mesmo tempo que ocorrem
interações entre os servidores de uma ou mais redes CDNs, os quais atuam como
super nós para a rede P2P, auxiliando-os no envio e recebimento dos fluxos de
dados de eventos ao vivo. À medida que recebe um determinado fluxo de dados de
um evento ao vivo, os nós cliente reproduzem tal conteúdo para o usuário final,
através de um processo em execução na camada de aplicação, ao passo que o
roteador de sua rede realiza parcerias com outros roteadores os quais possuem
nós clientes também interessados no mesmo conteúdo a fim de reproduzi-lo aos
seus usuários finais.

As trocas de dados entre nós GMTP ocorrem por meio do envio e recebimento de
pequenas partes do conteúdo de uma mídia, que são transmitidas por diferentes
nós da rede, constituindo um fluxos de datagramas IP. Estes fluxos são
transmitidos em modo \textit{multicast} ou em múltiplos fluxos \textit{unicast}
compartilhados (multi-unicast), realizando-se controle de congestionamento sem
garantia de entrega. A escolha do modo de transmissão utilizado para disseminar
um determinado conteúdo ocorre automaticamente, ou seja, sem a influência da
aplicação que, simplesmente ``sintoniza'' sua conexão em um determinado canal
definido pelo roteador, correspondete ao fluxo de dados de interesse do usuário
final. Tal abstração para a camada de aplicação ocorre de modo que os processos
em execução utilizam o GMTP através de uma API compatível com as especificações
de socket BSD e POSIX.

Por conseguinte, o GMTP permite o estabelecimento de conexões entre diversas
aplicações, executadas de forma distribuída em cada sistema final, tornando-as
compatíveis entre si, uma vez que o protocolo desacopla a forma como os dados
são transportados da forma como estes são exibidos ao usuário final, emulando
os sistemas tradicionais de TV e rádio. Assim, promove-ve a integração do GMTP
em aplicações já existentes, consideradas futuras adoções, ao tempo que
permite-se a utilização dos novos recursos introduzidos no protocolo,
evitando-se a complexidade de construção dos sistemas de transmissão de fluxos
de dados de eventos ao vivo.

Nas próximas seções deste capítulo, detalha-se o funcionamento do GMTP,
conforme a seguinte organização:

\begin{itemize}

\item Na Seção~\ref{sec:visaogeral}, apresenta-se uma visão geral do protocolo,
como cenário de atuação, arquitetura, canais de comunicação e tipos de nós e
pacotes.

\item Na Seção~\ref{sec:defsrests}, formaliza-se as definições e restrições do
protocolo, que serão utilizadas nas seções subsequentes.

\item Na Seção~\ref{sec:connformnet}, descreve-se o processo de
constituição da rede de favores, bem como aspectos de conexão multi-ponto
através da introdução de um novo conceito de sockets P2P. Detalham-se os
aspectos inerantes à constituição de uma rede P2P, tais como o registro de
participação de um nó e o processo de seleção de nós parceiros.

\item Na Seção~\ref{sec:asptransrecep}, discute-se sobre os aspectos de
transmissão e recepção de fluxos de dados, com os algoritmos utilizados para
compartilhar um fluxos de dados e as estratégias de disponibilização e
obtenção das partes de uma mídia.

\item Na Seção~\ref{sec:ccgmtp}, apresentam-se detalhes de funcionamento dos
algoritmos de controle de congestionamento utilizados no GMTP.

\item Na Seção~\ref{sec:seguranca}, discute-se sobre os aspectos relacionados a
validação de autenticidade de um fluxo de dados transmitido através do GMTP.

\item E, por fim, na Seção~\ref{sec:outros-aspectos}, apresentam-se outros
aspectos relacionados ao GMTP, tais como finalização de conexão, tolerância à
desconexão e eleição de nós relatores.

% e
% integração com outros protocolos de rede.
%
% \item Na Seção~\ref{sec:impl}, discute-se brevemente sobre aspectos de
% implementação e implantação do GMTP.
%
% \item E, por fim, na Seção~\ref{sec:benef}, apresenta-se um resumo sobre os
% benefícios e as justificativas de decisões de projeto do protocolo GMTP.

\end{itemize}

\section{Visão Geral do GMTP}
\label{sec:visaogeral}

O GMTP é composto por dois módulos chamados de \textit{GMTP Intra} e
\textit{GMTP Inter}, que operam na camada de transporte e de rede,
respectivamente. O \textit{GMTP Intra} fornece serviços às aplicações de rede a
fim de abstrair a complexidade na execução de tarefas comuns a qualquer
sistema, tais como conexão multi-ponto, multiplexação/demultiplexação de
segmentos IP e controle de congestionamento. O \textit{GMTP Inter} é
responsável por constituir uma rede de sobreposição P2P composta por roteadores,
os quais funcionam como pontes de acesso aos servidores de uma rede CDN.
Sendo assim, para viabilizar a disseminação de conteúdos multimídia, emprega-se
o Princípio da Cooperação de Brigadas de Incêndio (\textit{Fire Bucket Brigade
Principle}), onde cada nó roteador de um caminho constituído entre o servidor
que transmite a mídia e o cliente interessado em obtê-la, pode replicar o
conteúdo sendo roteado para os clientes conectados diretamente a ele e assim
sucessivamente, análogo a ilustração da
Figura~\ref{fig:bucket-brigade-principle-1}. No caso do GMTP, é como se cada
roteador fosse responsável por apagar os focos de incêndio próximos a ele, ou
melhor, atender a demanda dos clientes diretamente conectados a ele, ao passo
que ajuda os outros a fazer o mesmo.

\vspace{0.2cm}

\begin{figure}[ht]
\begin{center}
\includegraphics[natwidth=706,natheight=152,scale=.71]{imgs/bucket-brigade-principle-1.png}
\end{center}
\vspace{-0.8cm}
\caption{Analogia do Princípio da Cooperação de Brigadas utilizado no \mudccps
para distribuição de conteúdos multimídia ao vivo.}
\label{fig:bucket-brigade-principle-1}
\end{figure}

Na Figura~\ref{fig:cenario-global}, observa-se o cenário global de atuação do
protocolo \mudccp, onde ilustram-se os nós \textit{Clientes GMTP} interessados
em obter o conteúdo de um determinado evento ao vivo. Neste caso,
observa-se também um \textit{Servidor GMTP}, que está conectado a uma rede CDN e
atua como fonte geradora de dados. Na prática, os nós \textit{Clientes GMTP} são
aplicações de rede capazes de iniciar uma sessão GMTP, que transmitem, recebem
e reproduzem dados multimídia de um determinado evento. Os nós \textit{Clientes
GMTP} estão conectados a um nó \textit{Repassador GMTP}, que é executado em um
roteador de rede e, junto com outros nós \textit{Repassadores GMTP},
efetivamente constituem a rede de sobreposição P2P. Os \textit{Repassadores
GMTP} também podem se conecta a um ou mais \textit{Servidores GMTP}.
Os \textit{Servidores GMTP} são as fontes de conteúdos multimídia, obtidos
através de três formas: i) diretamente a partir de uma unidade geradora
de conteúdo (filmadora e/ou microfone); ii) a partir de um \textit{Cliente
GMTP}; e/ou iii) a partir de outro \textit{Servidor GMTP} (troca de dados entre
os servidores da CDN). Os \textit{Servidores GMTP} recebem sinalizações de
controle contendo requisições dos nós \textit{Repassadores GMTP}, que ao
receberem uma resposta correspondente a sua requisição, atendem a demanda de um
ou mais nós \textit{Clientes GMTP}.

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=.65]{imgs/cenario-global.pdf}
\end{center}
\vspace{-1cm}
\caption{Cenário global de atuação do \mudccp.}
\label{fig:cenario-global}
\end{figure}

Quando um nó \textit{Cliente GMTP} deseja reproduzir um determinado evento,
este envia uma requisição destinada ao nó \textit{Servidor GMTP} que está
transmitindo o conteúdo de interesse, como atualmente acontece em qualquer
conexão na Internet. A diferença é que um pedido de conexão é interceptado por
algum nó \textit{Repassador GMTP} durante o trajeto do pedido de conexão até o
nó \textit{Servidor GMTP}, que então determina os melhores parceiros para
atendê-la. Em geral, isto ocorre já no roteador de borda do \textit{Cliente
GMTP}, que funciona como nó \textit{Repassador GMTP} de origem. Caso o nó
\textit{Repassador GMTP} não encontre nenhum nó parceiro capaz repassar a mídia
de interesse, este encaminha tal requisição ao nó \textit{Servidor GMTP} que
transmite a mídia correspondente. Em todo caso, sempre o nó \textit{Repassador
GMTP} de origem assumirá o controle da requisição do \textit{Cliente GMTP},
habilitando-se como candidato a parceiro para outros nós \textit{Repassadores
GMTP}, quando motivados por requisições originadas pelos seus \textit{Clientes
GMTP}.

O posicionamento dos nós \textit{Repassadores GMTP} e suas habilidades permitem
a redução do número de fluxos de dados correspondente a um mesmo evento. Além
disso, permite-se uma maior escalabilidade do número de nós \textit{Clientes
GMTP} interessado em receber um mesmo fluxo de dados. Por este mesmo motivo, o
protocolo GMTP é flexível para permitir que um nó \textit{Repassador GMTP} atue
somente encaminhando conteúdos multimídias entre duas ou mais redes
distintas, mesmo que este não esteja conectado a nenhum nó \textit{Cliente
GMTP} interessado por tal conteúdo. Desta forma, maximiza-se o uso de canais de
transmissão ociosos, em particular das redes residenciais, as quais seus
usuários muitas vezes estão ausentes e portanto sem fazer uso dos recursos
disponíveis, não necessitando, inclusive, manter um determinado computador da
sua rede interna ativo (ligado), como é obrigatório em todas as outras soluções
similares e baseadas em arquitetura P2P.

Pelo princípio da cooperação de brigadas empregado no GMTP, as requisições
de conexão podem ser originados não apenas por nós \textit{Clientes GMTP} para
seu respectivo nó \textit{Repassador GMTP}, mas também as requisições podem
ocorrer entre nós \textit{Repassadores GMTP} que, motivados pelos interesses
dos seus nós \textit{Clientes GMTP}, podem formar parcerias entre si. Isto
significa que um nó \textit{Repassador GMTP} pode agir como se fosse um nó
\textit{Servidor GMTP}, respondendo às requisições originadas por seus nós
\textit{Clientes GMTP} ou de outros nós \textit{Repassadores GMTP}, como se a
requisição estivesse alcançado o \textit{Servidor GMTP} que oficialmente
transmite o conteúdo, o que ocorre de forma transparente para a aplicação.

Na Figura~\ref{fig:cenario-global-detailed}, observam-se detalhes do cenário
supracitado, introduzindo-se o conceito de um grupo especial de nós chamados de
nós \textit{Relatores GMTP}. Estes nós são responsáveis por enviar relatórios
periódicos sobre o estado da transmissão ao seu nó \textit{Repassador GMTP}, que
os utiliza para regular a taxa de transmissão de um ou mais fluxos de dados,
impedindo-se que a rede entre em colapso de congestionamento.

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=.85]{imgs/cenario-global-detailed.pdf}
\end{center}
\vspace{-1cm}
\caption[Rede de sobreposição construída pelo \mudccp]{Rede de sobreposição
construída dinamicamente pelo \mudccps com
a presença de nós repassadores e relatores.}
\label{fig:cenario-global-detailed}
\end{figure}

\subsection{Terminologias e Convenções}

Nesta seção, apresentam-se algumas definições, terminologias e convenções
utilizadas no restante deste documento, de acordo com a
Figura~\ref{fig:protocolo-tipos-nos}.

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=.6]{imgs/protocolo-tipos-nos.pdf}
\end{center}
\vspace{-1cm}
\caption{Tipos de Nós e modos de conexões do GMTP.}
\label{fig:protocolo-tipos-nos}
\end{figure}

\subsubsection{Tipos de Nós:}
\label{subsec:tiposnos}

\begin{itemize}

  \item \textbf{Nó GMTP ou Processador GMTP:} qualquer processador de rede que
implementa o protocolo GMTP. É um sistema computacional que implementa parte ou
todo do protocolo GMTP, sendo capaz de interpretar os cabeçalhos dos pacotes
definidos pelo GMTP e realizar ações pré-definidas. Não há restrições de qual
tipo de processador de rede pode implementar qual(is) parte(s) do GMTP.

  \item \textbf{Cliente GMTP:} é um \textit{nó GMTP} capaz de reproduzir e
gerar conteúdos multimídia ao vivo. Em geral, um \textit{Cliente GMTP} é um
sistema final que executa um processo a nível de sistema operacional,
representando uma aplicação manipulada pelo usuário final. A maioria dos
\textit{Clientes GMTP} funciona apenas de forma passiva, recebendo o fluxo de
dados de um conteúdo multimídia e entregando para um processo em execução,
contribuindo na execução do algoritmo de controle de congestionamento.

  \item \textbf{Servidor GMTP:} é um \textit{nó GMTP} capaz de capturar um
evento ao vivo e gerar conteúdos digitais de áudio e vídeo ou ainda, receber de
um \textit{Cliente GMTP} tais conteúdos. Em geral, um \textit{Servidor GMTP} é
um sistema final que participa de uma rede CDN.

  \item \textbf{Repassador GMTP:} é um \textit{Nó GMTP} com habilidades de
repassar os fluxos de dados originados de um ou mais \textit{Servidores GMTP}
ou de um outro nó \textit{Repassador GMTP}.

  \item \textbf{Relator GMTP:} é um \textit{Cliente GMTP} com habilidades de
enviar relatórios periódicos ao repassador sobre o estado da transmissão.

\end{itemize}

\subsubsection{Modos de Transmissão:}
\label{subsec:tiposconexao}

\begin{itemize}

  \item \textbf{\textit{Unicast}:} toda comunicação que ocorre entre dois nós
\textit{Repassadores GMTP}, com a interpretação do conceito definido por
\textit{unicast} em sua forma tradicional no contexto de redes de
computadores.

  \item \textbf{\textit{Multi-unicast}:} é um conjunto formado por dois ou mais
canais de transmissão \textit{unicast}.

\item \textbf{\textit{Multicast}:} toda comunicação que ocorre entre um nó
\textit{Repassador GMTP} e seus respectivos \textit{Clientes GMTP}, com a
interpretação do conceito definido por \textit{multicast} em sua forma
tradicional no contexto de redes de computadores.

\end{itemize}

O modo \textit{multicast} sempre é utilizado para a transmissão dos datagramas
correspondentes ao fluxo de dados multimídia, porém quando este modo não é
suportado pela rede, executa-se o modo \textit{multi-unicast} do protocolo. É
mandatório que o modo \textit{multicast} seja utilizado para transmissões entre
um nó \textit{Repassador GMTP} e seus \textit{Clientes GMTP} diretos. O modo
\textit{unicast} é utilizado para que \textit{Clientes GMTP} estabeleçam uma
conexão com um \textit{Servidor GMTP} ou um \textit{Repassador GMTP} e passe a
distribuir o conteúdo de dados multimídia em sua rede local.

Deste ponto em diante, os termos \textit{Nó GMTP}, \textit{Cliente GMTP},
\textit{Servidor GMTP}, \textit{Repassador GMTP} e \textit{Relator GMTP}
serão utilizados em sua forma simplificada, ou seja, \textit{nó},
\textit{cliente}, \textit{servidor}, \textit{repassador} e \textit{relator},
respectivamente. Além disso, estes termos não serão mais formatados em itálico,
bem como os termos \textit{socket}, \textit{unicast}, \textit{multi-unicast} e
\textit{multicast}. Ademais, quando o termo \textit{transmissão} ou
\textit{transmissão de um evento} for mencionado, denotar-se-á a transmissão de
um fluxo de datagramas IP correspondente a um evento ao vivo, utilizando-se o
protocolo GMTP.

Embora alguns autores considerem os termos \aspas{repasse} e \aspas{roteamento}
como conceitos distintos, neste trabalho ambos os termos são considerados
sinônimos e devem ser interpretados como a capacidade que um nó \mudccps tem de
receber dados em uma interface de rede de entrada e encaminhar estes dados
através de uma interface de rede de saída, permitindo-se que uma mesma interface
de rede seja utilizada como entrada e saída ao mesmo tempo.

As palavras \aspas{deve}, \aspas{não deve}, \aspas{requerido}, \aspas{pode},
\aspas{não pode}, \aspas{recomendado} e \aspas{opcional}, incluindo suas
variações morfológicas, devem ser interpretadas como descrito na RFC
2119~\cite{RFC2119}, em inglês.

\subsection{Arquitetura}

Na Figura~\ref{fig:arq_geral_gmtp}, ilustra-se a arquitetura geral do GMTP.

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=.8]{imgs/protocolo-arquitetura.pdf}
\end{center}
\vspace{-1cm}
\caption{Arquitetura do Protocolo \mudccp.}
\label{fig:arq_geral_gmtp}
\end{figure}

\subsection{GMTP Intra e GMTP Inter}
\label{subsec:gmtp-intra-inter}

De acordo com a arquitetura apresentada na seção anterior, define-se:

\begin{itemize}

 \item \textbf{GMTP Intra:} parte do protocolo GMTP executada na camada de
transporte da pilha de protocolos TCP/IP, corresponde ao módulo interno de uma
rede, composta por nós clientes e relatores, disponibilizado no sistema
operacional e utilizado pela aplicação através de uma API de socket GMTP. Um
socket GMTP é a representação de uma instância do protocolo GMTP em execução,
sendo responsável por gerenciar todas as atividades de comunicação da aplicação
correspondente ao meio externo (outros processos GMTP). No contexto de uma
conexão, o GMTP Intra mantém diversas variáveis de estado que representam uma
instância e executa algoritmos para gerenciamento de conexão (estabelecimento e
desconexão) e eleição de nós parceiros, determinação do formato e preenchimento
dos parâmetros que definem uma determinada mídia digital, permitindo que a
aplicação defina os valores de tais parâmetros e ou obtenham acesso aos valores
dos mesmos, controle de congestionamento e multiplexação e demultiplexação de
datagramas IP. O GMTP não faz verificação de conteúdo por mecanismo de soma de
verificação.

 \item \textbf{GMTP Inter:} parte do protocolo GMTP executada na camada de
rede da pilha de protocolos TCP/IP e corresponde ao módulo externo de uma rede,
composta por vários nós repassadores que cooperam entre si. É executado por um
roteador de rede e aceita conexões oriundas de um nó cliente ou de um nó
repassador. No contexto de uma conexão, o GMTP Inter mantém variáveis de estado
relacionadas às funções de sua responsabilidade, tais como estabelecimento de
conexão com nós servidores ou repassadores, seleção de nós repassadores
parceiros, eleição de nós relatores, controle de congestionamento assistido pela
rede e controle de compartilhamento de fluxos multimídia.

No GMTP Inter, permite-se a configuração de parâmetros iniciais de configuração
da rede de favores e da integração com servidores de uma ou mais CDN, como
ilustrado na Figura~\ref{fig:tela-gmtp-inter}. Nesse caso, o usuário
administrador de um nó repassador pode definir os seguintes parâmetros:

\begin{itemize}

  \item registro de participação em uma ou mais redes redes CDN;

  \item largura de banda (\textit{download} e \textit{upload}) que deseja
compartilhar;

  \item o período (faixa de dias e horários) que o roteador funcionará como nó
repassador;

  \item quantidade máxima de parcerias que podem ser realizadas;

  \item quantidade máxima de fluxos de dados que podem ser compartilhados;

  \item parâmetros avançados relacionados aos algoritmos de controle de
congestionamento;

  \item download automático ou não do certificado digital de um nó servidor; e

  \item realização de cache ou não dos certificados digitais obtidos.

\end{itemize}


\begin{figure}[ht]
\begin{center}
\includegraphics[natwidth=664,natheight=340,scale=.5]{imgs/tela-gmtp-inter.png}
\end{center}
\vspace{-1cm}
\caption{Tela da ferramenta de administração do OpenWRT~\cite{REF} com suporte
ao GMTP. Nessa tela, permitir que o administrador do roteador configure
registros de participação em uma ou mais redes CDN.}
\label{fig:tela-gmtp-inter}
\end{figure}

\end{itemize}

\subsection{Principais funções}

\begin{itemize}

  \item Registro de participação de um nó repassador em um nó servidor. Isto
permite o suporte à pré-seleção de nós parceiros filtrados por métricas que
influenciam na qualidade de experiência do usuário ao assistir um
evento ao vivo, como atraso fim-a-fim.

  \item Acesso a uma transmissão através de um processo de conexão em três-vias
(\textit{3WHS}), com a requisição de conexão transmitida ao servidor e podendo
ser interceptada por um nó repassador em seu trajeto ao servidor, com suporte
automático de detecção e uso dos modos de transmissão suportados pelo nó
repassador.

  \item Descoberta de nós parceiros entre redes distintas e negociação de
parcerias, com suporte a formação de parcerias baseadas em métricas que
influenciam na qualidade de experiência do usuário.

  \item Envio e recebimento de fluxos de dados compartilhados entre nós
da mesma rede através de multicast e uso de fluxos unicast entre redes
distintas, porém sem a relação de uma conexão por cliente e assim evitando o
fenômeno da tragédia dos bens comuns, discutido na Seção~\ref{sec:problematica}.

  \item Suporte a algoritmos de controle de congestionamento assistidos pela
rede e de fluxos multicast. Troca de relatórios periódicos entre os nós
repassadores sobre a transmissão.

  \item Eleição de nós relatores com suporte a tolerância a desconexões de nós,
com notificação e reeleição de novos nós.

  \item Possibilidade de permitir que os nós clientes verifiquem a autenticidade
das partes de uma mídia, por meio do uso de certificado digital determinado no
nó servidor para impedir ataques de poluição.

\end{itemize}

\subsection{Canais de Comunicação}
\label{subsec:canaiscommudccp}

No GMTP, utilizam-se dois canais de comunicação para executar suas
funcionalidades, o de transmissão unicast e o de transmissão multicast. A
seguir, definem-se tais conceitos.

% (Figura~\ref{fig:canais-comunicacao}).
%
% \begin{figure}[ht]
% \begin{center}
% \includegraphics[scale=.86]{imgs/canais-comunicacao.pdf}
% \end{center}
% \vspace{-1cm}
% \caption{Canais de Comunicação do \mudccp.}
% \label{fig:canais-comunicacao}
% \end{figure}

\subsubsection{Canal de Transmissão Unicast:}

O canal de controle e recepção unicast é criado por todos os nós repassadores ao
iniciar uma instância do protocolo GMTP. Na prática, trata-se de um socket que
os nós repassadores formam as devidas parcerias para transmitir os fluxos de
dados uns para os outros e posteriormente serem disseminados em
modo multicast pelos respectivos nós repassadores aos seus clientes.

Do ponto de vista de roteamento, todo nó repassador deve avaliar os datagramas
GMTP e realizar as ações apropriadas, definidas nas próximas seções deste
capítulo. Por exemplo, no processo de estabelecimento de conexão, a ser
detalhado na Seção~\ref{subsec:conexao-requisicao}, ao processar um pacote GMTP
transmitido por um nó cliente, o nó repassador deve verificar se o pacote é do
tipo \pac{GMTP-Request} e, em caso positivo, deve-se retornar um pacote do tipo
\pac{GMTP-Response} ao nó cliente, se o fluxo de dados de interesse do nó
cliente especificado no pacote \pac{GMTP-Request} já estiver sendo recebido por
tal nó repassador.

%  quando iniciarem uma instância do
% protocolo \mudccp, devem criar um socket multicast no endereço IP
% 238.255.255.250 e na porta $1900$, em toda interface de rede local, ou seja,
% nas interfaces que existem nós clientes. Através desse socket, um nó GMTP é
% capaz de enviar e receber pacotes de controle utilizados para negociar as
% funções de transmissão de um determinado fluxo de dados de mídia ao vivo
% através do canal de transmissão de dados. Por exemplo, este canal é utilizado
% para permitir que um nó cliente descubra quais fluxos de dados já está sendo

% A decisão do uso do endereço IP multicast 238.255.255.250 foi baseada na RFCs
% 2365~\cite{RFC2365}, que define o escopo administrativo do uso dos endereços
% multicast entre 239.0.0.0 e 239.255.255.255. O endereço 238.255.255.250 é
% definido no escopo de uso global e por este motivo esse endereço foi o
% escolhido.

% \subsubsection{Canal de Controle Unicast}
%
% Tal canal de controle é criado apenas entre os nós repassadores e relatores
% para troca de informações implementar as funcionalidades do protocolo, tais como
% procedimentos de estabelecimento de conexão, descoberta de nós e notificações de
% desconexões, eleição de nós relatores e envio e recebimento de relatórios para
% controle de congestionamento.

\subsubsection{Canal de Repasse Multicast:}

Além do canal de controle, define-se no protocolo \mudccps um canal de repasse
utilizado por um nó repassador para encaminhar datagramas vindos de um servidor
ou de outro repassador para a rede local. Esse canal de repasse, na prática, é
um socket multicast criado pelo nó repassador para transmitir os datagramas para
todos os seus clientes com interesse em reproduzir o mesmo fluxo de dados de um
evento ao vivo.

O \textit{socket de repasse multicast} deve ser criado quando um nó repassador
passa a obter um determinado fluxo de dados correspondente a um determinado
evento de interesse de pelo menos um dos seus clientes. Na prática, quando
isto acontece, o repassador deve criar um socket multicast em um
endereço IP e número de porta escolhida aleatoriamente para repassar os dados
vindos do servidor ou de outro repassador para dentro de sua rede. A
faixa de endereços IP multicast que o nó repassador deve utilizar para criar seu
socket de repasse para um determinado fluxo de dados é a de escopo local
239.192.0.0/14, definida na RFC 2365~\cite{RFC2365}. Como é uma faixa de
endereços IP multicast de domínio local, não se faz necessário registrar o uso
desses endereços. Isto significa que para todo fluxo de dados de um evento ao
vivo, deve-se alocar um endereço IP e uma porta. No caso do esquema de
endereçamento IPv4, com isto, será possível definir a transmissão de
exatamente de 17.179.607.040 (dezessete bilhões, cento e setenta e nove
milhões, seiscentos e sete mil e quarenta) diferentes fluxos de dados em uma
rede local, o que é mais do que suficiente e escalável por vários séculos.

% \subsubsection{Canal de Recepção de Dados:}
%
% O canal de recepção de dados é um socket multicast criado por um
% cliente para receber um fluxo de dados transmitindo por um nó repassador em
% algum endereço IP da faixa 239.192.0.0/14. Alternativamente, um canal de
% recepção de dados será um socket unicast quando existir apenas um
% cliente em uma rede interessado por um fluxo de dados, utilizando-se o
% endereço da sua própria interface de rede local. O endereço IP e o
% número de porta que o cliente deve se conectar é determinado pelo nó repassador
% no momento da conexão.

% \subsection{Diagrama de Estados do GMTP}
%
% TBD

% \section{Fluxograma de Estados do \mudccp}
%
% Após o processo de estabelecimento de conexão do \mudccp, o protocolo entra no
% estado de transmissão de dados, se o nó for um servidor ou um relay, ao passo
% que o protocolo entra no estado de recepção de dados, se o nó for um cliente.
%
% Um servidor ou um relay começa a transmitir os dados após o processo de
% estabelecimento de conexão e até quando o fluxo de dados no servidor se
% encerrar ou quando o relay não desejar mais receber o fluxo de dados.

\subsection{Tipos de Pacotes}
\label{subsec:tipodepacotesmudccp}

Toda comunicação entre dois ou mais nós GMTP ocorre através da troca de
datagramas IP, que carregam sinalizações de controle e/ou dados da aplicação.
Para isso, faz-se necessário registrar o uso de um código para o campo
\textit{Protocolo} do cabeçalho de um datagrama IP junto à \textit{Internet
Assigned Numbers Authority} -- IANA\footnote{IANA: http://www.iana.org/}. Com a
padronização do protocolo \mudccps e a publicação da sua RFC, provavelmente
será utilizado o código 100, como já está definido no documento \textit{Protocol
Numbers}\footnote{O código 100 foi utilizado no passado por um outro protocolo
de mesma sigla, mas foi descontinuado e se tornou obsoleto. O uso de tal
identificador está sendo negociado junto a IETF e a IANA
\murl{http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml}}
da IANA.

No cabeçalho dos pacotes \mudccp, existe um campo denominado \emph{tipo do
pacote} com tamanho de \ut{4}{bits}, que são descritos a seguir. Este campo
determina qual tipo de informação está contida em um determinado pacote \mudccps
e, ao processá-lo, o nó \mudccps deve executar uma determinada ação.

\begin{enumerate}
\setcounter{enumi}{-1}

  \item \textit{GMTP-Request:} Cliente envia requisição para obter um fluxo
de dados multimídia dado um nome do fluxo de interesse;

  \item \textit{GMTP-RequestNotify:} Repassador notifica um cliente que um
fluxo de dados está prestes a ser transmitido ou já está sendo transmitido em um
determinado canal de repasse multicast;

  \item \textit{GMTP-Response:} Repassador confirma o estabelecimento de uma
parceria com outro nó repassador, dado um determinado fluxo de dados;

  \item \textit{GMTP-Register:} Repassador registra participação no servidor
para funcionar como distribuidor de um ou mais fluxos de dados;

  \item \textit{GMTP-Register-Reply:} Servidor responde ao repassador sobre seu
pedido de registro de participação;

  \item \textit{GMTP-RelayQuery:} Repassador pode solicitar ao servidor uma
lista de possíveis nós repassadores parceiros;

  \item \textit{GMTP-Data:} Qualquer nó utiliza para transmitir dados da
aplicação;

  \item \textit{GMTP-Ack:} Qualquer nó utiliza para confirmar a recepção de
um determinado pacote, seja pacotes previamente contendo dados ou não;

  \item \textit{GMTP-DataAck:} Combinação dos pacotes GMTP-Data e GMTP-Ack
(\textit{PiggyBack});

  \item \textit{GMTP-MediaDesc:} Servidor transmite esse pacote para
descrever informações sobre a mídia sendo transmitida em uma
determinada transmissão;

  \item \pac{GMTP-DataPull-Request:} Repassador envia um pedido para obter o
mapa de buffer atual de um outro repassador parceiros;

  \item \pac{GMTP-DataPull-Response:} Resposta ao pedido para obtenção de um
mapa de buffer;

  \item \pac{GMTP-Elect-Request:} Repassador envia para um cliente o pedido
para tal cliente atuar como nó relator;

  \item \pac{GMTP-Elect-Response:} Cliente envia para o repassador uma
confirmação de que pode atuar como relator;

  \item \pac{Reservado:} Reservado para uso futuro e ignorado pelos nós que
o processa;

  \item \pac{Reservado:} Reservado para uso futuro e ignorado pelos nós que
o processa;

  \item \pac{GMTP-Close:} Servidor, repassador ou cliente solicita o término
de uma conexão;

  \item \pac{GMTP-Reset:} Determina, incondicionalmente, a finalização de
uma conexão.

\end{enumerate}

Nas próximas seções, descreve-se todas as possíveis ações do GMTP e os tipos de
pacotes envolvidos na comunicação entre os seus nós. No
Apêndice~\ref{app:mudccp-tecnica}, apresenta-se detalhes acerca do uso dos
tipos de pacotes do GMTP, sendo seu teor bastante técnico e portanto dedicado
aos leitores interessados em sua implementação.

% \begin{table}[ht]
%         \caption{Tipos de Pacotes do protocolo \mudccp.}
%         \label{tab:tipospacotemudccp}
%     \begin{center}
% 	\vspace{-0.8cm}
%         \begin{tabular}{|p{1.0cm}|p{1.5cm}|p{1.5cm}|}
%             \hline
%
% \multicolumn{1}{|>{\columncolor[rgb]{0.05,0.2,0.43}}c}{\textcolor{white}{\textbf
% {\#}}} &
% \multicolumn{1}{|>{\columncolor[rgb]{0.05,0.2,0.43}}c|}{\textcolor{white}{
% \textbf{Tipo}}} &
% \multicolumn{1}{>{\columncolor[rgb]{0.05,0.2,0.43}}c|}{\textcolor{white}{\textbf
% {Descrição}}}
% 	    \\
% 	    \hline
% 	    \hline
%             \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c}{\textbf{0}}
% & \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c|}{Request} &
% \multicolumn{1}{>{\columncolor[rgb]{0.66,0.7,0.759}}l|}{Requisição de um fluxo
% de dados multimídia a partir do seu nome}
% 	    \\
%
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c}{\textbf{1}} &
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c|}{RequestNotify} &
% \multicolumn{1}{>{\columncolor[rgb]{0.913,0.929,0.957}}l|}{Notificar um nó
% cliente que um fluxo de dados está pronto para ser transmitido.}
% 	    \\
%
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c}{\textbf{1}} &
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c|}{Response} &
% \multicolumn{1}{>{\columncolor[rgb]{0.913,0.929,0.957}}l|}{Resposta ao pedido de
% estabelecimento de conexão multicast}
% 	    \\
%             \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c}{\textbf{2}}
% & \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c|}{Data} &
% \multicolumn{1}{>{\columncolor[rgb]{0.66,0.7,0.759}}l|}{Contém dados da
% aplicação}
% 	    \\
%
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c}{\textbf{3}} &
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c|}{Ack} &
% \multicolumn{1}{>{\columncolor[rgb]{0.913,0.929,0.957}}l|}{Confirmação de
% recebimento de pacote}
% 	    \\
%
%             \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c}{\textbf{4}}
% & \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c|}{DataAck} &
% \multicolumn{1}{>{\columncolor[rgb]{0.66,0.7,0.759}}l|}{Dados da aplicação e
% confirmação de recepção}
% 	    \\
%
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c}{\textbf{5}} &
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c|}{Elect} &
% \multicolumn{1}{>{\columncolor[rgb]{0.913,0.929,0.957}}l|}{Inicia o processo de
% eleição de um nó em relay ou reporter}
% 	    \\
%
% \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c}{\textbf{6}}
% & \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c|}{ElectReply} &
% \multicolumn{1}{>{\columncolor[rgb]{0.66,0.7,0.759}}l|}{Sinaliza o interesse de
% um nó em se transformar em relay ou reporter}
% 	    \\
%
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c}{\textbf{7}} &
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c|}{ElectAck} &
% \multicolumn{1}{>{\columncolor[rgb]{0.913,0.929,0.957}}l|}{Confirmação do nó
% eleito para relay ou reporter}
% 	    \\
%
% \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c}{\textbf{8}}
% & \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c|}{RelayQuery} &
% \multicolumn{1}{>{\columncolor[rgb]{0.66,0.7,0.759}}l|}{Transmitido por um nó
% para consultar a lista de relays}
% 	    \\
%
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c}{\textbf{9}} &
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c|}{RelayReply} &
% \multicolumn{1}{>{\columncolor[rgb]{0.913,0.929,0.957}}l|}{Resposta ao pedido
% de consulta da lista de relays}
% 	    \\
%
% \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c}{\textbf{10}}
% & \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c|}{AdvConn} &
% \multicolumn{1}{>{\columncolor[rgb]{0.66,0.7,0.759}}l|}{Utilizado por um nó
% relay ou reporter para anunciar que está ativo na rede}
% 	    \\
%
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c}{\textbf{11}} &
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c|}{Reservado} &
% \multicolumn{1}{>{\columncolor[rgb]{0.913,0.929,0.957}}l|}{Uso futuro e ignorado
% pelo receptor}
% 	    \\
%
% \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c}{\textbf{12}} &
% \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c|}{Reservado} &
% \multicolumn{1}{>{\columncolor[rgb]{0.66,0.7,0.759}}l|}{Uso futuro e ignorado
% pelo receptor}
% 	    \\
%
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c}{\textbf{13}} &
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c|}{CloseReq} &
% \multicolumn{1}{>{\columncolor[rgb]{0.913,0.929,0.957}}l|}{Servidor ou
% Relay solicita término de conexão sem TIMEWAIT}
% 	    \\
%
%             \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c}{\textbf{14}}
% & \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c|}{Close} &
% \multicolumn{1}{>{\columncolor[rgb]{0.66,0.7,0.759}}l|}{Servidor/Cliente/Relay
% solicita término da conexão}
% 	    \\
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c}{\textbf{15}} &
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c|}{Reset} &
% \multicolumn{1}{>{\columncolor[rgb]{0.913,0.929,0.957}}l|}{Determina,
% incondicionalmente, o final da conexão}
% 	    \\
%             \hline
%         \end{tabular}
%     \end{center}
% % 	\scriptsize
% % 	$^1$ O tipo de pacote \textbf{\mudccp-Reset} é utilizado com este
% % propósito, porém utiliza-se também para outros motivos: para sinalizar número
% % de
% % porta incorreto; comportamento inapropriado de opções; desconexão prevista de
% % um
% % \mdrel\space etc.
% \end{table}

% \normalsize


% ver: http://peerstreamer.org

% Anotações após defesa:
%  - Ler o survey: http://www.aicit.org/jcit/ppl/%20JCIT_MAY_30.pdf
%  - Simuladores mais robustos: SimGrid [23], OPSS [26, 27], ChunkSim [29], 3LS
% [30], OPNET [30] (não sei se vai ser bom!)
%  -

\section{Definições, Relações e Restrições do GMTP}
\label{sec:defsrests}

Nesta seção, descrevem-se as definições, relações e restrições do protocolo
GMTP. Para isto, faz-se uso de fundamentos de algebra booleana, lógica
proposicional, teoria de conjuntos e teoria dos
grafos~\cite{Jonathan2003,Seroul2000,Courant1996,Devlin1979}.

\newcommand{\transmission}{\Large$\tau$\normalsize\normalfont}
\newcommand{\transmissions}{\transmission\space}
\newcommand{\event}{\Large$\varepsilon$\normalsize\normalfont}
\newcommand{\events}{\event\space}

\newcommand{\setservrepass}{$Z$}
\newcommand{\setservrepasss}{\setservrepass\space}

\newcommand{\settranc}{T}
\newcommand{\transconst}{t}
\newcommand{\settrans}{$\settranc$}
\newcommand{\settranss}{\settrans\space}
\newcommand{\transi}{u}
\newcommand{\transu}[1]{$\transconst_{#1}$}
\newcommand{\transssu}[1]{\transu{#1}\space}
\newcommand{\trans}{\transu{\transi}}
\newcommand{\transs}{\trans\space}

\newcommand{\setrepassc}{R}
\newcommand{\repassconst}{r}
\newcommand{\setrepass}{$\setrepassc$}
\newcommand{\setrepasss}{\setrepass\space}
\newcommand{\repassi}{d}
\newcommand{\repassu}[1]{$\repassconst_{#1}$}
\newcommand{\repasssu}[1]{\repassu{#1}\space}
\newcommand{\repass}{\repassu{\repassi}}
\newcommand{\repasss}{\repass\space}

\newcommand{\setclic}{C}
\newcommand{\cliconst}{c}
\newcommand{\setcli}{$\setclic$}
\newcommand{\setclis}{\setcli\space}
\newcommand{\subsetclii}{i}
\newcommand{\subsetcli}{\setcli$_{\subsetclii}$}
\newcommand{\subsetclis}{\subsetcli\space}
\newcommand{\cliu}[1]{$\cliconst_{#1}$}
\newcommand{\clisu}[1]{\cliu{#1}\space}
\newcommand{\clii}{f}
\newcommand{\cli}{\cliu{\clii}}
\newcommand{\clis}{\cli\space}

\newcommand{\setservc}{S}
\newcommand{\servconst}{s}
\newcommand{\setserv}{$\setservc$}
\newcommand{\setservs}{\setserv\space}
\newcommand{\servi}{a}
\newcommand{\servu}[1]{$\servconst_{#1}$}
\newcommand{\servsu}[1]{\servu{#1}\space}
\newcommand{\serv}{\servu{\servi}}
\newcommand{\servs}{\serv\space}

\newcommand{\setrelc}{L}
\newcommand{\relconst}{l}
\newcommand{\setrel}{$\setrelc$}
\newcommand{\setrels}{\setrel\space}
\newcommand{\subsetrel}{\setrel$_{\theta}$}
\newcommand{\subsetrels}{\setrel$_{\theta}$\space}
\newcommand{\reli}{w}
\newcommand{\rel}{$\relconst_{\reli}$}
\newcommand{\rels}{$\relconst_{\reli}$\space}
\newcommand{\relu}[1]{$\relconst_{#1}$}
\newcommand{\relsu}[1]{$\relconst_{#1}$\space}

\newcommand{\semifullsymb}{\circ}
\newcommand{\fullsymb}{\bullet}
\newcommand{\setwayc}{W}
\newcommand{\setway}{$\setwayc$}
\newcommand{\setways}{\setway\space}
\newcommand{\setwayii}{v}
\newcommand{\setwayiu}[1]{$\setwayc_{#1}$}
\newcommand{\setwayius}[1]{\setwayiu{#1}\space}
\newcommand{\setwayi}{\setwayiu{\setwayii}}
\newcommand{\setwayis}{\setwayius{\setwayii}}

\newcommand{\setwayifu}[1]{$\setwayc^{\fullsymb}_{#1}$}
\newcommand{\setwayifus}[1]{\setwayifu{#1}\space}
\newcommand{\setwayif}{\setwayifu{\setwayii}}
\newcommand{\setwayifs}{\setwayifus{\setwayii}}

\newcommand{\setwayisfu}[1]{$\setwayc^{\semifullsymb}_{#1}$}
\newcommand{\setwayisfus}[1]{\setwayisfu{#1}\space}
\newcommand{\setwayisf}{\setwayisfu{\setwayii}}
\newcommand{\setwayisfs}{\setwayisfus{\setwayii}}

\newcommand{\setwayidu}[1]{$\setwayc^{\lhd}_{#1}$}
\newcommand{\setwayidus}[1]{\setwayidu{#1}\space}
\newcommand{\setwayid}{\setwayidu{\setwayii}}
\newcommand{\setwayids}{\setwayidus{\setwayii}}

\newcommand{\setwayidfu}[1]{$\setwayc^{\lhd\fullsymb}_{#1}$}
\newcommand{\setwayidfus}[1]{\setwayidfu{#1}\space}
\newcommand{\setwayidf}[1]{\setwayidfu{\setwayii}}
\newcommand{\setwayidfs}[1]{\setwayidfus{\setwayii}}

\newcommand{\setwayidsfu}[1]{$\setwayc^{\lhd\semifullsymb}_{#1}$}
\newcommand{\setwayidsfus}[1]{\setwayidsfu{#1}\space}
\newcommand{\setwayidsf}[1]{\setwayidsfu{\setwayii}}
\newcommand{\setwayidsfs}[1]{\setwayidsfus{\setwayii}}

\newcommand{\wayconst}{w}
\newcommand{\wayi}{m}
\newcommand{\wayu}[1]{$\wayconst_{#1}$}
\newcommand{\waysu}[1]{\wayu{#1}\space}
\newcommand{\way}{\wayu{\wayi}}
\newcommand{\ways}{\way\space}

\newcommand{\setpkc}{P}
\newcommand{\pkconst}{p}
\newcommand{\pkalli}{h}
\newcommand{\setpk}{$\setpkc$}
\newcommand{\setpks}{\setpk\space}
\newcommand{\setpkf}{$\setpkc^{\fullsymb}$}
\newcommand{\setpkfs}{\setpkf\space}
\newcommand{\setpkallc}{\mathbb{\setpkc}}
\newcommand{\setpkall}{$\setpkallc$}
\newcommand{\setpkalls}{\setpkall\space}
\newcommand{\subsetpkall}{\setpkall$_{\theta}$}
\newcommand{\subsetpkalls}{\subsetpkall\space}
\newcommand{\subpkf}{\Large$\rho$\normalsize}
\newcommand{\subpkfs}{\subpkf\space}
\newcommand{\subsetpk}{$\setpkc^\lhd$}
\newcommand{\subsetpks}{\subsetpk\space}
\newcommand{\subsetpkf}{$\setpkc^{\lhd\fullsymb}$}
\newcommand{\subsetpkfs}{\subsetpkf\space}
\newcommand{\pki}{x}
\newcommand{\pku}[1]{$\pkconst_{#1}$}
\newcommand{\pksu}[1]{\pku{#1}\space}
\newcommand{\pk}{\pku{\pki}}
\newcommand{\pks}{\pk\space}

\newcommand{\setnetrc}{B}
\newcommand{\setnetr}{$\setnetrc$}
\newcommand{\setnetrs}{\setnetr\space}
\newcommand{\netrconst}{b}
\newcommand{\netri}{e}
\newcommand{\netru}[1]{$\netrconst_{#1}$}
\newcommand{\netrsu}[1]{\netru{#1}\space}
\newcommand{\netr}{\netru{\netri}}
\newcommand{\netrs}{\netr\space}

\newcommand{\net}{$\eta$}
\newcommand{\nets}{\net\space}

\newcommand{\powerset}[1]{$2^{#1}$}
\newcommand{\powersets}[1]{\powerset\space}
\newcommand{\transmit}{$\varphi($\serv$,$ \setpk$)$}
\newcommand{\transmits}{\transmit\space}
\newcommand{\transmitr}{$\varphi($\repass$,$ \setpk$)$}
\newcommand{\transmitrs}{\transmitr\space}
\newcommand{\transmitru}[1]{$\varphi($\repassu{#1}$,$ \setpk$)$}
\newcommand{\transmitrus}[1]{\transmitru{#1}\space}
\newcommand{\transmitqu}[1]{$\varphi($#1$,$ \setpk$)$}
\newcommand{\transmitqus}[1]{\transmitqu{#1}\space}
\newcommand{\invert}[1]{$\sim$$($#1$)$}

\begin{enumerate}

  \item Seja o conjunto finito dos nós repassadores, definido por
\setrepasss $ = \{\repassconst_1, \repassconst_2, \repassconst_3,
\ldots, $ \repass$\}$, tal que $\repassi \in \mathbb{N}$.

  \item Seja o conjunto finito dos roteadores de uma rede de computadores,
definido por \setnetrs $ = \{\netrconst_1, \netrconst_2,
\netrconst_3, \ldots, $ \netr$\}$, tal que $\netri \in \mathbb{N}$. Existe uma
relação \setrepasss $\rightarrow$ \setnetrs que determina a sobreposição
dos nós repassadores \repasss $\in$ \setrepasss sob os roteadores em \setnetrs
(\textit{rede de sobreposição}).

  \item Seja o conjunto finito dos nós servidores, definido por \setservs $ =
\{\servconst_1, \servconst_2, \servconst_3, \ldots, $ \serv$\}$, tal que $\servi
\in \mathbb{N}$.

  \item Seja o conjunto finito dos nós clientes, definido por \setclis $ =
\{\cliconst_1, \cliconst_2, \cliconst_3, \ldots, $ \cli$\}$, tal que $\clii \in
\mathbb{N}$.

  \item Seja o conjunto \textit{totalmente ordenado (toset)} dos pacotes de
dados gerados pelos nós \servs $\in$ \setservs durante a transmissão de um
evento ao vivo \event, definido por $($\setpkall$,\prec) = \{\pkconst_1,
\pkconst_2, \pkconst_3, \ldots, $\pku{\pkalli}$\}$, onde $\pkalli \in
\mathbb{N}$. Note que o símbolo $\prec$ é utilizado para representar
precedência entre dois elementos diferentes.

  \item Seja um grafo determinado pelo conjunto de vértices \setservrepass, que
podem estar interligados entre si por um conjunto de diferentes arestas,
chamadas de caminhos \setway, por onde se transmite o fluxo de dados \setpk,
definido por $\eta = G($\setservrepass$,$ \setway$)$, tal que:

    \begin{enumerate}

      \item \setservrepasss $=$ \setservs $\cup$ \setrepass;

      \item Sejam as relações e restrições estabelecidas entre os diferentes
tipos de nós de uma transmissão de um evento ao vivo \event, definida por
\transmission $= \{$\setservrepass, \setpk, \subsetcli$\}$, tal que:

      \begin{enumerate}

	  \item Seja \setpk, o conjunto \textit{parcialmente ordenado
(\textit{poset})} dos pacotes de dados \pks transmitidos por um nó \servs ou
repassados por um nó \repass, também chamado de fluxo de pacotes de dados ou
apenas fluxo de dados, definido por $($\setpk$,\prec) =
\{\pkconst_{1},\pkconst_{2}, \pkconst_{3},
\ldots, $\pku{x}$\}$, tal que $x \in \mathbb{N}$. Trata-se de um \textit{poset}
porque o GMTP não garante entrega de \pk;

	  \item Seja \subsetcli, uma função que denota os nós \cli relacionados
a um nó \repass, de modo que nenhum nó \clis $\in$ \setclis pode estar
relacionado com dois ou mais nós, definida por \subsetclis $:$ \repasss
$\rightarrow$ \powerset{\setclic}, $\forall$\repass,\repassu{\repassi+1} $\in$
\setrepass, \subsetcli$($\repass$)$ $\cap$ \subsetcli$($\repassu{\repassi+1}$)$
= $\{\emptyset\}$;
	  \label{item:funcao-subsetcli}

% , de modo que:
%   \begin{itemize}
%     % se disser que P \subset P_{total} já é suficiente pra ser um P*?
%     \item Um fluxo de dados \setpks é dito \textit{fluxo completo},
% representado por \setpkf, se e somente se \setpks $\leftrightarrow$
% $\exists$\subsetpkalls (relação bijetora), tal que \subsetpkalls $\in$
% \powerset{\setpkallc} e \subsetpkalls $\neq \{\emptyset\}$. Ou seja, um
% \textit{fluxo completo} \setpkfs é um conjunto \textit{toset} e portanto
% não apresenta lacunas;
%
%     \item \subpkfs $: ($\pk$, $\setpk$) \rightarrow ($\subsetpk$, \prec) =
% \{$\pk, \pku{\pki+1}, \pku{\pki+2}, \pku{\pki+3}, $\ldots\}$, tal que
% \subsetpks $\subset$ \setpk, uma função \subpkf$($\pk$, $\setpk$)$ que define
% um sub-fluxo de pacotes de dados \setpks a partir de um determinado pacote
% \pks
% $\in$ \setpk. Neste caso, como \subsetpks $\subset$ \setpk, se \subsetpkfs
% $\rightarrow$ \setpkf.
%   \end{itemize}

	  \item Seja \setrel, o conjunto finito dos nós relatores, definido por
\setrels $= \{\relconst_1, \relconst_2, \ldots, $\rel$\}$. Como todo nó \clis
pode atuar como \rel, tem-se que $\exists$\subsetrels $\in$
\powerset{\setclic_\subsetclii(\repassconst_\repassi)}, tal que \rels $\in$
\subsetrel. Pelo item~\ref{item:funcao-subsetcli}, que determina que dois
nós \clis não podem estar relacionados a mais de um nó \repass, tem-se portanto
que \subsetrels $\subset$ \setrels e \subsetrels $\cup$
\subsetcli$($\repass$)$ $ = $ \subsetcli$($\repass$)$.

      \end{enumerate}

    \item \setway $=$ $\bigcup^{j}_{\setwayii=1}$ \setwayi, onde $j \in
\mathbb{N}$ e corresponde à quantidade de todos os possíveis caminhos \setwayi,
tal que um caminho é definido por um conjunto \textit{toset}
$($\setwayi,$\prec)$, que denota um dos possíveis caminhos por onde um fluxo de
dados \setpks pode ser transmitido, obrigatoriamente a partir de um nó servidor
\serv até um nó \repassu{1}, tal que:

      \begin{enumerate}

	  \item $($\setwayi$,\prec) = \{$\ways $\mid$
\serv$,\repassconst_{1},\repassconst_{2},\repassconst_3,
\ldots, $\repass$\}$, $\forall$\way$,$\waysu{\wayi+1}$\in$ \setwayis $:$
\way$ \prec$ \wayu{\wayi+1} e \setwayis $\neq \{\emptyset\}$ e
$\mid$\setwayi$\mid$ $>$ $1$;

	  \item Um caminho \setwayis é dito \textit{caminho semi-completo},
representado por \setwayisf, se e somente se \setwayis $\leftrightarrow$
$\exists$\setnetr$_{\theta}$ (bijetora), tal que \setnetr$_{\theta}$
$\in$ \powerset{\setnetrc} e \setnetr$_{\theta} \neq \{\emptyset\}$. Isto é,
todos os roteadores \netrs $\in$ \setnetrs são sobrepostos por um nó \repasss
$\in$ \setwayisf;

	  \item Um caminho \setwayis é dito \textit{caminho completo},
representado por \setwayif, se for \setwayisfs e se \setwayis $\subset$
\settrans, tal que \settranss $\subset$ \setservrepasss é o conjunto dos nós que
transmitem ou repassam os pacotes de dados \pks $\in$ \setpk, definido por
\settranss $= \{$\transs$\mid$ \transmitqus{\trans} $ = 1\}$, sendo $\transi \in
\mathbb{N}$ e $\varphi$ uma função booleana que determina se um nó \transs $\in$
\settranss transmite os pacotes \pks $\in$ \setpks de um evento \events para
\trans, ou para pelo menos um \clis $\in$ \subsetcli(\trans), ou seja:

	      \begin{enumerate}

		  \item $\varphi:$ (\trans, \setpk) $\rightarrow \{0, 1\},
\forall ($\trans, \setpk$) \in \{$\settrans$ \times \{$\setpk$\}\}$, onde 0 e 1
denotam, respectivamente, \textit{falso} e \textit{verdadeiro}.

	      \end{enumerate}

      \end{enumerate}

    \item Seja $\sim$, uma função reversa de um conjunto \textit{toset}, tal que
$\sim$ $: ($\setwayi$,\prec)$ $\rightarrow ($\setwayi$,\succ)$. Isto é, para um
conjunto $($\setwayi$, \prec) = \{$\ways $\mid$
\serv$,\repassconst_{1},\repassconst_{2},\ldots, $\repass$\}$, então
\invert{\setwayi} produzirá $($\setwayi$, \succ) = \{$\ways $\mid$ \repass
$,\repassconst_{\repassi-1},\repassconst_{\repassi-2},\ldots,\repassconst_{1},
$\serv$\}$;

    \item Seja $\delta$, uma função que define um sub-caminho de \setwayi,
representado por \setwayid, a partir de um nó \transs $\in$ \setwayis até um nó
\transssu{1} $\in$ \setwayi, tal que $\delta: ($\trans$,$\setwayi$) \rightarrow
($\setwayid$, \prec)$. Ou seja, para um caminho qualquer $($\setwayi$, \prec) =
\{$\transu{\transi+1}$,$\transu{\transi+1}$,$\trans$,$\transu{\transi-1}$,
$\transu{\transi-2}$, \ldots,$\transu{2}$,$\transu{1}$\}$,
$\delta($\trans$,$\setwayi$) = $ \setwayids $ =
\{$\trans$,$\transu{\transi-1}$,$\transu{\transi-2}$,\ldots,$\transu{2}$,
$\transu{1}$\}$. Neste caso, como $\delta$ faz um corte no conjunto \setwayi,
pode-se obter \textit{caminho semi-completo} ou \textit{completo},
representados por \setwayidsfs\space e \setwayidfs\space, respectivamente;

    \item Seja $\zeta$ uma função que calcula o custo total para transmitir um
pacote \pks $\in$ \setpk, através de um caminho \setwayi, definida por $\zeta :
\sum_{\setwayii=1}^{|\setwayc_\setwayii|} \gamma($\way$,$ \wayu{\wayi+1}$)$, tal
que $\gamma$ é uma função que determina o custo para transmitir o pacote \pks
entre dois nós distintos $\forall$\way$,$\wayu{\wayi+1} $\in$ \setwayi. No GMTP,
o custo é calculado pelo RTT entre dois nós distintos, mas podendo-se
utilizar outras métricas, como número total de saltos no caminho \setwayi;

    \item \textit{Conjectura 1}: $\forall$\repasss $\in$ \setrepasss e
$\forall$\clis $\in$ \setcli, \repasss é mais estável que qualquer \clis com
relação a sua disponibilidade e participação em uma rede de favores $\eta$. Em
uma rede comutada por pacotes IP, um nó \netrs $\in$ \setnetr, portanto para o
GMTP um nó \repass, fica menos indisponível se comparado aos seus nós
\subsetcli(\repass). Por exemplo, nas transmissões de dados na Internet, a
participação de um roteador no processo de transmissão de um fluxo de dados
\setpks é fundamental, mesmo que seja apenas para rotear os respectivos pacotes.
Apesar de óbvia, tal observação é importante porque para qualquer nó \clis
receber os pacotes de dados \pks $\in$ \setpk, primeiramente os pacotes de dados
\pks devem, obrigatoriamente, passar pelo roteador de \cli, ou seja, o seu
roteador padrão. Sendo assim, quando um nó \repasss se desconecta, todos seus
nós \subsetcli(\repass) tornam-se capazes de receber \setpk, mas a recíproca não
é verdadeira -- se um nó \clis se tornar indisponível, não necessariamente
\repasss também se torna indisponível. Com base na aceitação dessa conjectura,
especificamente para a rede \net, pretende-se permitir que outros nós \clis
possam continuar recebendo \setpk, mesmo ocorrendo a desconexão de um nó
\clis que esteja recebendo \setpk durante a recepção de um fluxo de dados
\setpk. No GMTP, adota-se tal estratégia quando um nó \repasss passa a manter
estado sobre tal transmissão e não mais por qualquer nó \cli, antes prática
comumente adotada em soluções tradicionais de distribuição de conteúdos
multimídia baseado em uma arquitetura P2P ou em qualquer protocolo de
transporte e rede disponível no estado da arte;
    \label{item:conjecture1}

    \item \textit{Conjectura 2}: as tabelas de roteamento dos nós \ways $\in$
\setwayis não mudam frequentemente e são independentes umas das outras. Em
redes comutadas por pacotes IP, as rotas entre quaisquer nós \cliu{\clii_1} e
\cliu{\clii_2} $\in$ \setclis não se alteram com um nível de frequência que
desestabilize a comunicação entre estes. Mesmo se estas mudanças ocorrerem em
uma rota de um caminho \setwayi, o impacto causado é temporário e insignificante
para a transmissão de um evento \event quando se utiliza um conjunto de
algoritmos que tratem essas mudanças. Com base na aceitação dessa conjectura, é
possível antecipar a formação de parcerias entre os nós em \setservrepasss
antes da efetiva transmissão de um fluxo de dados \setpk. Essa estratégia é
adotada no GMTP.
    \label{item:conjecture2}

%   \item $\zeta:$ $\hat{r}_x$, $\hat{r}_y$, $\hat{t}_i$)} =
% \textit{min$\{$cost($\hat{r}_y$, $\hat{r}_z$, $\hat{t}_i$)}$\}$, uma função
% recursiva que determina o custo para um nó repassador $\hat{r}_x$ obter, a
% partir de um nó repassador parceiro $\hat{r}_y$, um evento $\gamma$,
% transmitido em $\hat{t}_i$. Sendo assim, \textit{cost($\hat{r}_x$,
% $\forall\hat{r}_y$, $\hat{t}_i$)} $ = 0$ para $\hat{r}_x = \hat{t}_i$;


%   \item f: \textit{link($\hat{r}_i$, $\hat{r}_j$)} $ =
% \hat{r}_i \leftrightarrow \hat{r}_j$ ou f: \textit{link($\hat{r}_i$,
% $\hat{s}$)} $ = \hat{r}_i \leftrightarrow \hat{s}$, uma função que relaciona um
% nó $\hat{r}_i$
% a um nó $\hat{r}_j$ $\mid$ $\hat{r}_i$ e $\hat{r}_j \in R_{\tau}$ ou a um nó
% $\hat{s}$ $\mid$ $\hat{s} \in S_{\tau}$, respectivamente. A propriedade de
% comutatividade de \textit{link()} é válida, ou seja, \textit{link($\hat{r}_i$,
% $\hat{r}_j$)} $=$ \textit{link($\hat{r}_j$, $\hat{r}_i$)};;
%   \label{i:linkrepass}

    \end{enumerate}

\end{enumerate}

Desta forma, \nets representa formalmente a rede de sobreposição constituída
pelo GTMP, definindo-se as relações, restrições estabelecidas em \transmissions
e as conjecturas consideradas para a execução de tal protocolo.

Nas próximas seções, detalham-se os aspectos teóricos e computacionais
empregados do GMTP a fim de construir \net, em três partes distintas de acordo
com os blocos funcionais ilustrados na Figura~\ref{fig:blocos-funcionais}:

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=.5]{imgs/blocos-funcionais.pdf}
\end{center}
\vspace{-0.8cm}
\caption{Blocos funcionais do GMTP e as relações com a pilha de protocolos
TCP/IP.}
\label{fig:blocos-funcionais}
\end{figure}

\begin{enumerate}

  \item \textit{Constituição da rede de favores $\eta$:} descobrir, definir,
efetivar e desfazer parcerias entre os nós \repasss $\in$ \setrepasss de acordo
com o evento \events a ser transmitido (Seção~\ref{sec:connformnet});

  \item \textit{Distribuição do fluxo de dados \setpks em \net, através
das Instâncias de Aplicações (sockets):} conectar os nós \clis $\in$ \setclis,
\repasss $\in$ \setrepasss e \servs $\in$ \setserv, bem como transmitir os
pacotes de dados \pks $\in$ \setpks através da rede de sobreposição constituída
na Fase 1 (Seção~\ref{sec:asptransrecep});

  \item \textit{Controle de congestionamento em \net:} controlar a
taxa de transmissão dos fluxos de dados \setpks transmitidos em \nets na Fase
1 (Seção~\ref{sec:ccgmtp}); e

  \item \textit{Segurança em \net:} verificar a autenticidade do conteúdo de
\setpks antes de entregar aos nós \clis $\in$ \setpks
(Seção~\ref{sec:seguranca}).

\end{enumerate}

\section{Constituição da Rede de Favores \net}
\label{sec:connformnet}

A constituição da rede de favores \nets ocorre por meio do registro
de participação de um ou mais nós \repasss $\in$ \setrepasss a um ou mais
nós \servs $\in$ \setserv. Isto pode ocorrer de forma direta ou indiretamente
por meio de outros nós \repassu{q} $\in$ \setrepass. Todo esforço realizado
nesse processo objetiva transmitir um determinado fluxo de dados $P$ para um ou
mais nós \clis $\in$ \setcli, podendo ser distribuído pelos nós \repasss por
meio de diferentes caminhos \setwayis $\in$ \setway.

O GMTP tenta determinar um caminho sub-ótimo \setwayiu{\theta} através do qual
os pacotes de dados \pks $\in$ \setpks sejam entregues o mais rápido possível ao
nó \clis interessado em obter \setpk. Para isto, deve-se determinar
\setwayiu{\theta}, tal que \setwayiu{\theta} $= min(\zeta(\forall$\setwayi$))$
e, sempre que possível, que \setwayiu{\theta} seja um caminho completo
\setwayifu{\theta}. Sempre buscar um caminho completo é importante porque como
todos os nós de tal caminho são nós repassadores sobrepostos em cada roteador
da rota de rede utilizada para transmitir \setpk, consequentemente pode-se
distribuir \setpks para mais nós \clis sem que sejam necessárias múltiplas
conexões em \serv, evitando cenários da tragédia dos bens comuns, discutidos no
Capítulo~\ref{cap:introducao}. Além disso, por possuir mais nós \repass, um
utilizar um caminho completo torna os sistemas que transmitem um fluxo de dados
\setpks menos sensíveis às desconexões.

\subsection{Registro de participação de \repasss em \net}
\label{subsec:registro-participacao}

O procedimento de registro de participação de um nó \repasss em uma rede $\eta$
é o primeiro passo, e um dos mais importante. O registro de participação permite
que um nó \repasss se registre a um nó \servs para sinalizar interesse em
funcionar como um nó repassador de um ou mais fluxos de dados \setpk. O
registro de participação pode ocorrer antes do nó \servs iniciar a transmissão
de um fluxo de dados \setpk, ou durante sua transmissão.

Para realizar um registro de participação, um nó \repasss envia uma mensagem
para um nó \servs utilizando o pacote \pac{GMTP-Register}, o que permite a
descoberta de um caminho \setwayi. Isto porque todos os nós repassadores
existentes no caminho entre \repasss e \servs devem adicionar seu código no
pacote \pac{GMTP-Register}, no momento de rotea-lo para o próximo salto da rota
em direção ao nó \serv. Na prática, o identificador de um nó repassador pode ser
o endereço IP, porém o método mais apropriado seria gerar um código-nome baseado
na combinação dos endereços MAC (\textit{Media Access Control}) das interfaces
de rede do roteador. Quando o pacote \pac{GMTP-Register} alcançar o destino
\serv, o nó \servs conhecerá a lista ordenada dos nós \repasss até \servs e a
armazenará como sendo um dos possíveis caminhos para distribuir um fluxo de
dados \setpk. Como resposta ao nó \repass, o nó \servs deve enviar um pacote do
tipo \pac{GMTP-Register-Reply}, que confirma o registro de participação. O
caminho \setwayis pode ser utilizado futuramente no processo de formação de
parcerias, a ser discutido na Seção~\ref{sec:descparc}. Pelas
conjecturas~\ref{item:conjecture1} e~\ref{item:conjecture2}, apresentadas na
Seção~\ref{sec:defsrests}, o nó \servs pode utilizar os caminhos conhecidos
\setwayis $\in$ \setways para coordenar o processo de formação de futuras
parcerias entre os nós \repasss $\in$ \setrepass.

Sendo assim, um registro de participação ocorre quando um nó deseja participar
da rede de sobreposição, não necessariamente quando se deseja obter um fluxo de
dados \setpk. Mesmo assim, um registro de participação pode ocorre no mesmo
instante que um nó \repasss desejar receber um fluxo de dados \setpk. Em ambos
os casos, o algoritmo de registro de participação é similar, com uma diferença:
se um nó \repasss solicitar previamente um registro de participação a um
\serv, inicialmente sem interesse por um evento \events qualquer, será possível
mapeá-lo antecipadamente e selecionar um subconjunto de possíveis nós
parcerios \repassu{q} para executar a distribuição de um fluxo de dados
\setpk. Neste caso, pode-se utilizar \repasss para repassar pacotes de dados
\pks mesmo quando \subsetcli$($\repass$) = \{\emptyset\}$, ou seja, quando o nó
\repasss não tenha nó clientes para repassar o fluxo de dados \setpk. Assim, os
nós \repasss passam a funcionar como se fossem servidores de uma rede CDN,
porém dinâmicos, que poderiam ser acionados quando fosse conveniente, por
exemplo, se ele for um nó comum entre dois caminhos, necessitando apenas de
enviar apenas um fluxo de dados \setpk.

De forma similar, se $\exists$\clis $\in$ \subsetcli$($\repass$)$ interessado
em obter \setpk, com \transmitr\space $ = 1$, ou seja, quando um nó \repasss já
está recebendo o fluxo de dados \setpk, o registro de participação já terá
ocorrido e o fluxo já estará sendo recebido pelo nó \repasss em questão, vindo
do nó \serv, mas não necessariamente direto de \serv, mas sim podendo ser
repassado por outros nó \repass. Como consequência, reduzindo-se o tempo de
início de reprodução do referido fluxo de dados \setpks para aqueles nós
\clis que solicitarem o mesmo fluxo de dados \setpks após o primeiro pedir,
bastando apenas que os próximos nós \clis ``sintonizem'' sua interface de
comunicação (socket de rede) no canal apropriado e informado por \repass, pois
a transmissão ocorre em modo multicast.

Analogamente, a motivação do registro de participação empregado no GMTP é
transformar cada roteador de uma rede IP como se fosse uma antena de recepção de
uma transmissora de TV. Tal antena é capaz de receber um ou mais sinais de
canais de TV diferentes, nesse caso, os fluxos de dados \setpk, e distribuí-los
para os aparelhos de TV da cidade, ou melhor, distribuí-los para os sistemas
finais da respectiva rede, ou seja, seus nós \clis $\in$ \setcli. Este assunto
será retomado na Seção~\ref{sec:asptransrecep}, onde discute-se as funções de
conectividade IP empregadas no GMTP.

No Trecho de Código \ref{algo:registerRelay}, apresenta-se o pseudo-algoritmo
utilizado por um nó \repasss para se registrar a um nó \serv. Note que o nó
\repasss não é obrigado a informar qual fluxo de dados \setpks está interessado
em obter, tal como explicado anteriormente, lembre-se, o nó \repasss se
comporta, por analogia, como uma antena de TV. Porém, da mesma forma que é
possível uma antena de TV obter apenas o sinal correspondente a um determinal
canal (frequência de TV), também é possível que um nó \repasss especifique
exatamente qual fluxo de dados \setpks deseja começar a receber. Neste caso, o
nó \servs executará um procedimento para determinar se aceita ou não o pedido de
conexão para transmitir \setpk. Caso aceite, a transmissão do fluxo de dados
\setpks entre \servs e \repasss ocorrerá em modo unicast, diretamente entre
eles, caso contrário, o nó \servs delegará a transmissão de tal fluxo de dados
\setpks para algum outro nó repassador \repassu{q} que se tornará parceiro do
nó requisitante \repass.

\newcommand{\attrib}{$\leftarrow$ }

\begin{algorithm}[H]
\label{algo:registerRelay}
\caption{registerRelay(\serv: PeerServer, \pks $=$ \pac{GMTP-Request})}
\SetAlgoLined

\SetKwFunction{Union}{Union}\SetKwFunction{makePkt}{makePkt}
\SetKwFunction{Union}{Union}\SetKwFunction{recvPktRdt}{recvPktRdt}
\SetKwFunction{Union}{Union}\SetKwFunction{sendPktRdt}{sendPktRdt}
\SetKwFunction{Union}{Union}\SetKwFunction{getCurrRegedServers}{getCurrRegedServers}
\SetKwFunction{Union}{Union}\SetKwFunction{parsePath}{parsePath}
\SetKwFunction{Union}{Union}\SetKwFunction{length}{length}
\SetKwFunction{Union}{Union}\SetKwFunction{getPacketFieldValue}{getPacketFieldValue}
\SetKwFunction{Union}{Union}\SetKwFunction{isFlowBeingReceived}{isFlowBeingReceived}
\SetKwFunction{Union}{Union}\SetKwFunction{respondToClients}{respondToClients}
\SetKwFunction{Union}{Union}\SetKwFunction{getChannelOfFlow}{getChannelOfFlow}
\SetKwFunction{Union}{Union}\SetKwFunction{GMTPRegister}{GMTPRegister}
\SetKwFunction{Union}{Union}\SetKwFunction{isWaitingRegisterReply}{isWaitingRegisterReply}
\SetKwFunction{Union}{Union}\SetKwFunction{waitRegisterReply}{waitRegisterReply}
\SetKwFunction{Union}{Union}\SetKwFunction{clientWantsFlow}{clientWantsFlow}

\tcc{The node \repasss executes this function to send a register of participation to
a given node \serv. In case \pks is given, this means that a node \clis
wants to receive the flow \setpk, and this is also signaled to \serv.}

\If(){\pks $\neq$ NULL} {
  \textit{\setpk} \attrib \getPacketFieldValue{\pk, `flow'}\tcc*[r]{Extracts \setpks in \pk}
  \textit{\cli} \attrib \getPacketFieldValue{\pk, `client'}\tcc*[r]{Extracts \clis in \pk}
  \uIf(){\isFlowBeingReceived{\setpk}} {
    \tcc{Let \clis know that \setpks is already registered in this \repass. This means that the \clis can already get the flow \setpks from this node \repass. The function \respondToClients is defined in section \ref{subsec:conexao-requisicao}.}
    \Return{\respondToClients{\setpk, \cli}}\;
  } \Else() {
      \tcc{Add \clis in the list of receivers interested in obtaining \setpk, send request to \servs and wait for \pac{GMTP-Register-Reply}. When received, executes onReceiveGMTPRegisterReply, defined in the Algorithm~\ref{algo:onReceiveGMTPRegisterReply}. If the \pac{GMTP-Register} was already sent, nothing should be done other than wait for \pac{GMTP-Register-Reply}.}
      \clientWantsFlow{\cli, \setpk}\;
      \If() {\textbf{not} \isWaitingRegisterReply{\setpk}} {
	\waitRegisterReply(\setpk)\;
	\Return{\sendPktRdt{\GMTPRegister{\serv, \setpk}}}
      }
  }
}
\If(){\textbf{not} \isWaitingRegisterReply{\serv}} {
  \Return{\sendPktRdt{\GMTPRegister{\serv}}}\;
}
\Return False;

\end{algorithm}

\vspace{0.8cm}

Quando o nó \repasss receber o pacote do tipo \pac{GMTP-Register-Reply},
correspondente ao registro de participação transmitido anterioremente,
aciona-se o procedimento apresentado no Trecho de
Código~\ref{algo:onReceiveGMTPRegisterReply}, executando-se o passos restantes
explicados anteriormente.

\vspace{0.8cm}

\begin{algorithm}[H]
\label{algo:onReceiveGMTPRegisterReply}
\caption{onReceiveGMTPRegisterReply(\pks $=$ \pac{GMTP-Register-Reply})}
\SetAlgoLined

\SetKwFunction{Union}{Union}\SetKwFunction{createMulticastChannel}{createMulticastChannel}
\SetKwFunction{Union}{Union}\SetKwFunction{getAndStoreServerPublicKey}{getAndStoreServerPublicKey}

\tcc{The node \repasss executes this function when receives a packet of type
\pac{GMTP-Register-Reply}, as response for a registration of participation
reply sent to a \serv.}

\uIf(\tcc*[f]{\servs confirmed registration}){\pks = OK} {
  \textit{\setpk} \attrib \getPacketFieldValue{\pk, `flow'}\tcc*[r]{Gets \setpks in \pk}
  \If(){\setpk $\neq$ NULL}{
    \servs \attrib \getPacketFieldValue{\pk, `server'}\tcc*[r]{Gets \serv}
    servs[\length{servs}] \attrib \serv\tcc*[r]{Store the new \serv}
    \uIf(\tcc*[f]{Section~\ref{subsec:obterchavepublica}}){\servs enabled
security layer} {
      \getAndStoreServerPublicKey{\serv}\;
    }
    \textit{channel} \attrib \createMulticastChannel{\serv, \setpk}\;
    \Return{\respondToClients{\textit{channel}}}\;

  }
} \Else() {
  \tcc{\servs refuses to accept the connection. This \repasss must notify the clients waiting for receiving \setpk.}
  \textit{errorCode} \attrib \getPacketFieldValue{\pk, `error'}\;
  \respondToClients{\textit{errorCode}, \setpk}\;
  \Return{-\textit{errorCode}}\;
}

\end{algorithm}
\vspace{0.8cm}

Note que, no GMTP, toda transferência de pacotes de controle ocorre com
garantia de entrega, representando-se tais ações pelas funções com nomes
contendo o sufixo \textit{Rdt} (\textit{Reliable data transfer}). Uma outra
decisão importante tomada no GMTP é que um nó \repasss deve periodicamente
sinalizar sua participação na rede de favores \nets através de uma função
tradicionalmente conhecida por \textit{keep-alive}, comumente utilizado em
outros protocolos de rede consolidados, como o TCP. Nesse aspecto, o GMTP segue
a RFC 1122, \textit{Requirements for Internet Hosts - Communication
Layers}~\cite{RFC1122}.

Além disso, um nó \repasss pode sinalizar explicitamente sua desconexão a
\serv, quando não desejar mais participar da rede de favores $\eta$ ou receber
um fluxo de dados \setpk. Para isto, deve-se enviar um pacote do tipo
\pac{GMTP-Close}. Em qualquer um dos casos de desconexão, por expiração do
tempo (devido ao procedimento de {keep-alive} ou explícita através do envio de
\pac{GMTP-Close}, o nó \servs deve desconsiderar \repasss no processo de
formação de parcerias e enviar para o nó \repasss um pacote do tipo
\pac{GMTP-Reset}.

Para finalizar esse assunto, declara-se que o registro de participação do GMTP
permite que quanto mais nós \repasss se registrarem em nós \serv, mais caminhos
\setwayis sejam conhecidos. Consequentemente, quanto mais caminhos forem
conhecidos, mais parcerias poderão ser formadas entre os nós \repass. E,
portanto, quanto mais parcerias forem formadas, maior será o número de nós \clis
capazes de receber um fluxo de dados \setpks originado em \serv, disponibilizado
indiretamente através dos seus respectivos nós \repasss (antena na cidade!), sem
nenhuma influência da camada de aplicação. No mundo real (Internet), os nós
\repasss podem passar a constituir dinamicamente a rede de distribuição de
conteúdos de uma empresa. Por exemplo, um usuário de uma conexão residencial
xDSL, por exemplo, pode configurar seu roteador para registra-lo em múltiplas
redes de distribuição, como ilustra-se na Figura~\ref{fig:tela-gmtp-inter}.
Nesses casos, as redes de distribuição podem fazer uso do roteador desse usuário
em momentos ociosos de recepção e transmissão de dados através da Internet. Como
consequência, relações comerciais podem ser construídas entre o usuário e os
provedores de rede, mas essa discussão está fora do escopo deste trabalho.

\subsection{Formação de parcerias}
\label{sec:descparc}

A formação de parcerias resulta na constituição de um ou mais caminhos \setwayis
$\in$ \setway, que interligará um nó \servs a um ou mais nós \clis $\in$
\subsetcli(\repass). Tal processo ocorre entre dois ou mais nós \repasss e
consiste na seleção de nós parceiros \repassu{q} para auxiliar \repasss a obter
os pacotes \pks $\in$ \setpk, análogo a ilustração da
Figura~\ref{fig:bucket-brigade-principle-5}.

\begin{figure}[ht]
\begin{center}
\includegraphics[natwidth=421,natheight=240,scale=.72]{imgs/bucket-brigade-principle-5.png}
\end{center}
\vspace{-0.8cm}
\caption{Um nó \repasss precisa descobrir e selecionar seus parceiros
\repassu{q}, resultando na formação é um caminho \setwayis entre um nó \servs e
um ou mais nós \cli.}
\label{fig:bucket-brigade-principle-5}
\end{figure}

No GMTP, a seleção de nós parceiros \repassu{q} ocorre antes e durante a
transmissão de um fluxo de dados \setpk, através dos procedimentos de formação
de parcerias apresentados a seguir, executa concorrentemente.

\begin{enumerate}
 \item Formação de parcerias intra \setwayi;
 \item Formação de parcerias por intersecção de \setwayi; e
 \item Formação de parcerias por combinação de \setwayi.
\end{enumerate}

\subsubsection{\space\space\space\space\space\space1. Formação de parcerias
intra \setwayi}
\label{subsec:parcintra}

No procedimento de formação de parceria intra \setwayi, os nós \ways $\in$
\setwayis são automaticamente considerados parceiros entre si e por isto
qualquer nó \ways pode repassar um fluxo de dados \setpks para o nó \repasss em
questão. A formação da parceria ocorre de forma transparente durante o pedido de
conexão de um nó \clis ao nó \servs para obter \setpk. Dessa forma, qualquer nó
\ways $\in$ \setwayis pode agir como se fosse um nó \serv, sendo este o
procedimento mais simples e direto que um nó \repasss pode obter um fluxo de
dados \setpks através de nós parceiros \repassu{q}.

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=.5]{imgs/esquema-abstrato-formacao-parceria-intra.pdf}
\end{center}
\vspace{-0.8cm}
\caption{Cenário e passos para seleção de nós intra caminhos \setwayi.}
\label{fig:esquema-abstrato-formacao-parceria-intra}
\end{figure}

Na Figura~\ref{fig:esquema-abstrato-formacao-parceria-intra}, ilustram-se os
passos executados por este procedimento de formação de parceria. No Passo 1,
ilustra-se um cenário de rede \nets com 19 nós \repasss e dois nós \serv, sem
qualquer fluxo de dados \setpks transmitido, tampouco nenhuma parceria
efetivada. No Passo 2, ilustra-se a transmissão de um fluxo de dados
\setpks que ocorre entre os nós \servu{2} e \repassu{7}, caracterizando o
caminho \setwayiu{1}, ilustrado pela linha tracejada na cor vermelha. Este
cenário será utilizado como base para todos os exemplos apresentados a seguir.

Com base no exemplo ilustrado, para formar o caminho \setwayiu{1}, o nó
\repassu{7} transmite o pedido de registro de participação ao nó \servu{2}, como
explicado na Seção~\ref{subsec:registro-participacao}. Assim, quando houver um
nó qualquer \repasss interessado por um fluxo de dados \setpk, motivado por
algum nó \clis $\in$ \subsetcli$($\repass$)$, qualquer nó \ways pode interceptar
um pedido de conexão transmitido para \serv, desde que \way,\repasss $\in$
\setwayis e \transmitqu{\way} $=1$. Ao interceptar o pedido de conexão enviado
por \repass, o nó \ways enviar uma resposta a \repass, como se fosse o
servidor \serv, uma vez que o nó \ways já está repassando o fluxo de dados
\setpks para seus nós \clis $\in$ \subsetcli(\way). Para este caso, até antes
do momento em que \ways interceptara o pedido de conexão enviado por \repass, o
 fluxo de dados \setpks estara sendo repassado apenas para os nós \clis $\in$
\subsetcli$($\way$)$. Porém, com o emprego do procedimento de formação de
parcerias intra \setwayi, o mesmo fluxo de dados \setpks é ``estendido'' até
\repass, e tal nó poderá ``estender'' o fluxo de dados \setpks para mais outros
nós \repasss que utilizem o caminho \setwayis para alcançar \serv. Este caso
pode ser observado no Passo 3 da
Figura~\ref{fig:esquema-abstrato-formacao-parceria-intra}. Uma vez que
\transmitqu{\repassu{7}} $=1$ este intercepta o pedido de conexão transmitido
pelo nó \repassu{9}, formando o caminho \setwayidu{2} $= \{$\repassu{9},
\repassu{8}$\}$ $\cup$ \setwayiu{1}.

Note que quando um nó \repasss interceptar um pedido de conexão para um fluxo de
dados \setpk, tal como explicado anteriormente, o nó \repasss deve também
transmitir para o nó \servs uma notificação que informa sobre tal pedido
utilizando o pacote do tipo \pac{GMTP-Register}, como explicado na
Seção~\ref{subsec:registro-participacao}.

Esse procedimento de formação de parceria é muito interessante porque pode
reduzir o tempo de estabelecimento de conexão e reduzir a quantidade de
requisições para o nó \servs que transmite um fluxo de dados \setpk. Isto
ocorre porque se permite que \repasss descubra mais rapidamente outros
candidatos a parceiros \repassu{q}, tal que \transmitru{q} $ = 1$, efetivando-se
parcerias quando ocorrer \subsetcli$($\repass$)\neq \{\emptyset\}$.

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=.5]{imgs/esquema-abstrato-formacao-parceria-intra-falha.pdf}
\end{center}
\vspace{-0.8cm}
\caption{Cenário de falha do nó \repassu{6} em um caminho \setwayiu{1}, seguida
de constituição de um novo caminho \setwayiu{3} formado pelo procedimento de
formação de parceria intra \setwayi.}
\label{fig:esquema-abstrato-formacao-parceria-intra-falha}
\end{figure}

Além disso, uma ação específica é realizada se um nó \ways $\in$ \setwayis
circunstancialmente falhar. Para tratar estes casos, definiu-se que o nó
\repasss pode formar parcerias com os próprios nós \repasss $\in$ \setwayid, tal
que \setwayid\space $=$ \invert{$\delta($\wayu{\wayi+1}, \setwayi$)$}, através
de uma outra rota de rede que também alcance o nó \servs -- isto pode acontecer
devido à execução de algoritmos de roteamento dinâmico \textit{Intra-AS
(Autonomous Systems)}, por exemplo, o OSPF, e \textit{Inter-AS}, por exemplo, o
BGP~\cite{kurose2006}.

Para entender o comportamento do GMTP em caso de falha de um nó \repass,
observe a Figura~\ref{fig:esquema-abstrato-formacao-parceria-intra-falha}. Se o
nó \repassu{6} falhar e o nó \repassu{14} também estiver repassando \setpk, uma
nova parceria é formada transparentemente entre o nó \repassu{7} e o nó
\repassu{14}. Isto porque o nó \repassu{14} interceptará os pacotes de controle
de \textit{keep-aline} que o nó \repassu{7} está transmitindo para o nó \serv.
Mas, pode acontecer o caso de que \transmitru{14} $ = 0$ e \transmitru{13} $ =
0$ para o fluxo de dados \setpk, portanto o pedido de conexão enviado pelo nó
\repassu{9} alcançará o nó \servu{2} como antes. Isto resultará na constituição
de um novo caminho \setwayiu{3} $=$ \setwayidu{1} $\cup$ \setwayidu{2}, tal que
\setwayidu{1} $=$ \invert{$\delta($\repassu{6}, \setwayiu{1}$)$} e \setwayidu{2}
$=$ $\delta($\invert{\setwayiu{2}}, \repassu{15}$)$. Isto fará com que todo o
caminho \setwayiu{3} repasse o fluxo de dados \setpk. Como consequência,
aumenta-se a possibilidade de parcerias futuras com nós \repasss cujo pedido de
conexão para obter \setpks seja roteado pelo caminho \setwayiu{3}. Para este
caso, criou-se o procedimento de formação de parceria por intersecção de
caminhos \setwayi, detalhado mais adiante.

Na Seção~\ref{subsec:desconexao}, apresenta-se uma discussão geral sobre o
comportamento do GMTP em outros casos de desconexões. O procedimento de formação
de parceria intra \setwayi, apresentado nesta seção, está intimamente
relacionado com o processo de estabelecimento de conexão do GMTP, detalhado mais
adiante na Seção~\ref{subsec:conexao-requisicao}.

\subsubsection{\space\space\space\space\space\space2. Formação de parcerias por
intersecção de \setwayi}
\label{subsec:parcintersec}

O procedimento de formação de parcerias por intersecção consiste na
identificação de um nó \ways comum a dois ou mais caminhos \setwayi. Esse caso
foi parcialmente introduzido no final da seção anterior, quando apresentou-se um
cenário de falha de um nó \repass. Porém, o procedimento de formação de
parceria introduzido nesta seção permite que o referido nó \ways comece
replicar o fluxo de dados \setpks mesmo quando \subsetcli$($\way$) = 0$. Para
este caso, o nó \servs transmite apenas um único fluxo de dados \setpk para
duas ou mais sub-caminhos que contém o nó \way. Para entender melhor este
caso, acompanhe a explicação a seguir com base na ilustração da
Figura~\ref{fig:esquema-abstrato-formacao-parceria-interseccao}.

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=.5]{imgs/esquema-abstrato-formacao-parceria-interseccao.pdf}
\end{center}
\vspace{-0.8cm}
\caption{Cenário e passos para seleção de nós por interseção de caminhos
\setwayi.}
\label{fig:esquema-abstrato-formacao-parceria-interseccao}
\end{figure}

Seja o caminho \setwayiu{1}, ilustrado no Passo 1 da
Figura~\ref{fig:esquema-abstrato-formacao-parceria-interseccao}. A formação de
parceria por intersecção ocorre quando um nó \repasss transmite um pedido de
registro de participação ou um pedido de conexão para obter um fluxo de dados
\setpk, através de um caminho \setwayis que já esteja repassando \setpk. Assim,
após o registro de participação de \repassu{9} e a consequente constituição de
\setwayiu{1} (Passo 1), se qualquer um dos nós \repassu{10..12}, suponha
\repassu{11}, enviar um registro de participação ou um pedido de conexão para
obter \setpks (Passo 2 da
Figura~\ref{fig:esquema-abstrato-formacao-parceria-interseccao}), \repassu{7}
se tornará candidato a parceiro de \repassu{11} (se ocorrer apenas o registro
de participação), ou automaticamente comecará a repassar o fluxo de dados
\setpks para \repassu{11}, caso \repassu{11} envie um pedido de conexão para
obter \setpk, em vez do simples registro de participação. Com o registro de
participação de \repassu{9} e \repassu{11}, o nó \servs descobrirá, por
intersecção, um sub-caminho de nós \repasss $\in$ $($\setwayiu{1} $\cap$
\setwayiu{2}$)$ (Passo 2).

No Trecho de Código~\ref{algo:findPartnerIntersectPath}, apresenta-se um
pseudo-algoritmo para o procedimento de formação de parcerias por
intersecção, executado no nó \servs ao receber um pedido de conexão originado
por um nó \repasss qualquer para obter um fluxo de dados \setpk. O nó \servs
compara os caminhos conhecidos \setwayis $\in$ \setways com o caminho
\textit{\setwayiu{\repassconst_\repassi}} contido no pedido de conexão
transmitido por \repass. Se \servs determinar um nó \ways em comum entre algum
\setwayis e \textit{\setwayiu{\repassconst_\repassi}}, \servs instrui o nó
\ways a interceptar os próximos pedidos de conexão para obter \setpks, caso
contrário, \servs aceita o novo pedido de conexão e todo o caminho
\textit{\setwayiu{\repassconst_\repassi}} passa a ser alimentado com o fluxo de
dados \setpk para permitir futuras parcerias intra, por intersecção ou por
combinação, a ser apresentada mais adiante. Note que após este procedimento, o
nó \servs passa a conhecer o caminho \textit{\setwayiu{\repassconst_\repassi}}.

Para o cenário ilustrado na
Figura~\ref{fig:esquema-abstrato-formacao-parceria-interseccao}, o
algoritmo identifica um sub-caminho \setwayidu{1} $=$ \setwayidu{2} =
\invert{$\delta($\repassu{7}, \setwayiu{1}$)$} $\cup$
\invert{$\delta($\repassu{7}, \setwayiu{2}$)$} = $\{$\repassu{7}, \repassu{6},
\repassu{5}, \servu{2}$\}$. Ao identificar tal intersecção, o nó \servu{2} deve
enviar apenas um fluxo de dados \setpks para \repassu{7}, que o repassará para
os nós \repasss que enviar um pedido de conexão para obter \setpk, ou seja,
qualquer requisição originada a partir de qualquer \repasss $\in$
$\delta($\repassu{7}, \setwayi$)$, $\forall$\setwayi. No caso específico do
pedido de conexão transmitido pelo nó \repassu{11}, na resposta a este pedido
transmitida pelo nó \servu{2} em direção ao nó \repassu{11}, \servu{2} deve
sinalizar que os pacotes de dados \pks $\in$ \setpks também devem ser
repassados para \repassu{11}. Para isso, \repassu{7} deve manter um mapeamento
entre o nome do fluxo de dados \setpks e a lista dos nós \repasss que tal fluxo
deve ser repassado. Um aspecto técnico muito importante que deve ser ressaltado
é que apenas o nó \repasss que precisar repassar \pks $\in$ \setpks para seus
nós \clis $\in$ \subsetcli$($\repass$)$ deve manter um mapeamento entre o fluxo
de dados \setpks, o endereço e porta em que tal fluxo deve ser entregue. Como
a transmissão de um fluxo de dados \setpks entre um nó \repass e seus nós
\clis $\in$ \subsetcli$($\repass$)$ ocorrerá em modo multicast, faz-se
necessária apenas uma entrada no mapeamento do nó \repass por fluxo de dados
\setpk, portanto utilizando-se pouco recurso de memória de um roteador.

O algoritmo explicado anteriormente, foi originalmente concebido no processo de
concepção do GMTP, que permite repasse de pacotes de dados \pks levando em
consideração o fluxo de dados de interesse \setpk, portanto trata-se de uma
abordagem centrada no conteúdo \textit{(content centric networks)}, e não
centrada no sistema final \textit{(host centric networks)}. Essa proposta
quebra um paradigma que tradicionalmente os pacotes de dados de uma aplicação
são roteados com base no sistema final de destino. No caso do GMTP,
diferentemente de qualquer outros protocolo existente, para o cenário ilustrado
no exemplo supracitado, quando qualquer nó \clis $\in$
$\sum^{12}_{\repassi=8}$\subsetcli$($\repass$)$ solicitar o fluxo de dados
\setpk, apesar de tal pedido ser enviado em direção ao nó \serv, o nó
\repassu{7} analisará o pedido pelo nome do fluxo de dados \setpk e decidirá por
encaminhar os pacotes de dados \pks $\in$ \setpks para o respectivo nó \repasss
solicitante, naquele caso o nó \repassu{11}. Isto só é possível porque o nó
\servs instrui o nó \repassu{7}, que é o primeiro nó comum entre os caminhos
\setwayiu{1} e \setwayiu{2}, de tal forma que \transmitqu{\repassu{7}} $=1$.
Como resultado, o nó \repassu{7} aciona um filtro para interceptar todo pacote
de requisição para obter o fluxo de dados \setpk. A partir desse instante,
como o nó \repassu{7} interceptará todos os pedidos de conexão com interesse em
obter \setpk, \repassu{7} responderá ao nó \repasss solicitante como se
\repassu{7} fosse o nó \servu{2}. Salienta-se também que há originalidade nesse
algoritmo a partir do momento em que se permite que um nó \servs se
comunique com um nó \repasss a fim de o delegar a responsabilidade em
distribuir um determinado fluxo de dados \setpk.

% Esse procedimento também cobre o caso em que dois (ou mais) nós \repasss podem
% formar
% parcerias entre si, quando apenas parte dos seus caminhos se interceptam, mas
% não fazem parte do sub-caminho produzido por tal intersecção. Por exemplo,
% considere o cenário ilustrado no Passo 3 da
% Figura~\ref{fig:esquema-abstrato-formacao-parceria-interseccao}). Nesse caso, o
% nó \repassu{4} recebe o fluxo de dados \setpks originado em \servu{1}, ao passo
% que o nó \repassu{9} recebe o mesmo fluxo originado em \servu{2}. Por meio de
% troca de informações sobre os caminhos conhecidos \setwayi entre os nós
% \servu{1} e \servu{2}, o nó \servu{1} pode instruir o nó \repassu{4} a enviar
% um pedido de conexão ao nó \repassu{6}, resultando no cenário ilustrado no
% Passo 4 da Figura~\ref{fig:esquema-abstrato-formacao-parceria-interseccao}.
% Após a negociação entre os nós \repassu{4} e \repassu{6}, o nó \servu{1}
% suspende a transmissão do fluxo de dados \setpk em direção ao nó \repassu{4}.
% Note que este procedimento constituirá um novo caminho, representado por
% \setwayiu{4} $=\{$\repassu{4}, \repassu{3},\repassu{2},\repassu{6}$\}$, que só
% será efetivado se o nó \servsu{1} constatar a condição $\zeta($\setwayiu{3}$)
% \geq \zeta($\setwayiu{3}$)$.

%  - ENVIAR EMAIL HYGGO/ANGELO

\begin{algorithm}[H]
\label{algo:findPartnerIntersectPath}
\SetAlgoLined
\tcc{\servs executes this function to finds the first node \ways common to a known path \setwayis and the path \setwayiu{\repassconst_\repassi}. \setwayis is already used for transporting \setpks to node in $\delta($\way, \setwayi$)$, and \setwayiu{\repassconst_\repassi} contains all nodes between \repasss (requester) and \serv. The packet \pks carries \setwayiu{\repassconst_\repassi} and the name for \setpk.}
\textit{done} \attrib \textit{false}\tcc*[r]{It becomes true when \ways is found}

\SetKwFunction{Union}{Union}\SetKwFunction{makePkt}{makePkt}
\SetKwFunction{Union}{Union}\SetKwFunction{getPacketFieldValue}{getPacketFieldValue}
\SetKwFunction{Union}{Union}\SetKwFunction{recvPktRdt}{recvPktRdt}
\SetKwFunction{Union}{Union}\SetKwFunction{sendPktRdt}{sendPktRdt}
\SetKwFunction{Union}{Union}\SetKwFunction{length}{length}
\SetKwFunction{Union}{Union}\SetKwFunction{getKnownPathsOfFlow}{getKnownPathsOfFlow}
\SetKwFunction{Union}{Union}\SetKwFunction{GMTPResponse}{GMTPResponse}

\textit{\setpk} \attrib \getPacketFieldValue{\pk, `flow'}\tcc*[r]{Extracts \setpks in \pk}
\textit{\setwayiu{\repassconst_\repassi}} \attrib \getPacketFieldValue{\pk, `path'}\tcc*[r]{Extracts \setwayiu{\repassconst_\repassi} in \pk}

\textit{\setwayiu{\setpkc}} \attrib \getKnownPathsOfFlow{\setpk, \setway}\tcc*[r]{\setwayiu{\setpkc} $\subset$ \setway}
% \tcc*[r]{For a given flow and all the known paths \setways in this \serv, get a sub set of paths used to transmit \setpk}

\ForEach{\setwayis $\in$ \setwayiu{\setpkc}}{
    \ForEach{\ways $\in$ \setwayi} {
      \If(){\ways $\in$ \textit{\setwayiu{\repassconst_\repassi}}} {
	\tcc{The node \ways is common in \setwayis and in \textit{\setwayiu{\repassconst_\repassi}}.}
	\textit{done} \attrib \textit{true}\;
	break\;
      }
    }
    \If(){\textit{done}} {
%       \tcc{Create a \pac{GMTP-Response} and send it to \way. After receiving \textit{\pk}, \ways becomes a relay of the flow \setpk.}
%       \pks \attrib \makePkt{\pac{GMTP-Response}(1), \ways}\;
      \tcc{\servs stores \textit{\setwayiu{\repassconst_\repassi}} as a known path and replies to \repass, asking \ways to act as a relay for \setpk. \servs actives the flag 'relay' of the \pac{GMTP-Response} packet.}
      \setway[\length{\setway}] \attrib \textit{\setwayiu{\repassconst_\repassi}}\;
      \Return{\GMTPResponse{\way, relay=1}}\;
%       \sendPktRdt(\pk)\;
%       \exit{}\;
    }
}
\tcc{\servs must register \textit{\setwayiu{\repassconst_\repassi}} as a known path and reply to \repasss by accepting its connection request, since no node \ways is intersecting \textit{\setwayiu{\repassconst_\repassi}}.}
\setway[\length{\setway}] \attrib \textit{\setwayiu{\repassconst_\repassi}}\;
\Return{\GMTPResponse{\repass, relay=0}}\;
% \pks \attrib \makePkt{\pac{GMTP-Response}(0), \repass}\;
% \sendPktRdt(\pk)\;

\caption{matchPartnersByPathIntersection(\repass: PeerRelay, \pk $=$
\pac{GMTP-Request})}
\end{algorithm}
\vspace{0.8cm}

\subsubsection{\space\space\space\space\space\space3. Formação de parcerias por
combinação de \setwayi}
\label{subsec:parccombina}

O procedimento de formação de parcerias por combinação considera um nó
\textit{pivot} \servs e consiste em combinar dois (ou mais) caminhos
distintos \setwayiu{1} e \setwayiu{2} tal que \setwayiu{1} $\cap$ \setwayiu{2}
$= \{$\serv$\}$, ou seja, os caminhos se interceptam apenas em \serv, como
ilustra-se na Figura~\ref{fig:esquema-abstrato-formacao-parceria-combinacao},
Passo 1. Dessa forma, dado um conjunto de caminhos conhecidos \setway, o nó
\servs executa as combinações e instrui alguns nós \ways $\in$ $($\setwayiu{1}
$\cup$ \setwayiu{2}$)$ a se tornarem parcerios entre si a fim de compartilharem
o mesmo fluxo de dados \setpk, entregando os pacotes de dados \pks $\in$
\setpks mais rapidamente aos nós \clis interessados em obtê-los. Tal
procedimento pode ajudar os nós \repasss a expandirem suas possibilidades de
parcerias, incluindo a possibilidade de obter pacotes de dados \pks $\in$
\setpks de múltiplos nós parceiros \repassu{q}.

Com o registro de participação de cada nó \repasss em \serv, o nó \servs
conhece os caminhos \setwayis $\subset$ \setways através dos quais se
transmite o fluxos de dados \setpk. Sendo assim, \servs pode determinar
candidados a parcerios \repassu{q} de um determinado nó \repass. Por exemplo,
se dois nós quaisquer \wayu{1} $\in$ \setwayiu{1} e \wayu{2} $\in$ \setwayiu{2}
estiverem recebendo o fluxo de dados \setpk, o nó \servs pode instruir que
ambos se tornem parceiros e apenas um fluxo de dados \setpks é transmitido, em
vez de dois.

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=.5]{imgs/esquema-abstrato-formacao-parceria-combinacao.pdf}
\end{center}
\vspace{-0.8cm}
\caption{Cenário e passos para seleção de nós por combinação de caminhos
\setwayi.}
\label{fig:esquema-abstrato-formacao-parceria-combinacao}
\end{figure}

Em geral, o algoritmo funciona da seguinte forma: o nó \servu{2} processa os caminhos
\setwayis conhecidos e determina quais são os melhores parceiros \repassu{q}
para um determinado nó \repass, sendo tal informação enviada para \repass. No
caso do cenário ilustrado na
Figura~\ref{fig:esquema-abstrato-formacao-parceria-combinacao}, Passo 2, é
possível combinar os caminhos \setwayiu{1} e \setwayiu{2} pelos nós \repassu{6}
e o \repassu{15}. Ao combinar dois caminhos \setwayiu{1} e \setwayiu{2}, sempre
haverá duas direções para a transmissão do fluxo de dados \setpk, uma ilustrada
no Passos 3 e outra ilustrada no Passo 4 da
Figura~\ref{fig:esquema-abstrato-formacao-parceria-combinacao}. Para decidir
qual opção escolher, o nó \servu{2} compara os custos $\zeta($\setwayiu{1}$)$ e
$\zeta($\setwayiu{2}$)$. Se $\zeta($\setwayiu{1}$) \geq \zeta($\setwayiu{2}$)$,
então o nó \servu{2} solicita que \repassu{9} envie um pedido de conexão para
\repassu{16} (Passo 4). Por fim, o nó \repassu{15} deve enviar uma notificação
para o nó \servu{2} informando sobre a constituição do novo caminho \setwayi. Em
caso de $\zeta($\setwayiu{1}$) \leq \zeta($\setwayiu{2}$)$, então o nó \servu{2}
solicitará que \repassu{16} envie um pedido de conexão para \repassu{9} (Passo
3), ao passo que o restante do procedimento ocorrerá de forma similar ao que
acabara de ser explicado.

Esta é a grande motivação da formação de parceria por combinação, pois quando o
pedido de conexão do nó \repassu{9} alcançar o nó \repassu{15}, este o
interceptará e, nesse instante, constitui-se um novo caminho \setwayis $=
\{$\repassu{15}$,$\repassu{14}$,$\repassu{6}$,$\repassu{7}$,$\repassu{8}$,
$\repassu{9}$\}$.

É importante salientar que o pedido de conexão enviado pelo nó \repassu{9}
para o nó \repassu{15} deve conter uma sinalização (\textit{flag}) que
instruirá o nó \repassu{6} a não interceptar tal pedido de conexão. Para
tal sinalização, dá-se o nome de \textit{ignorar pedido de conexão},
do inglês \textit{bypass connection request}.

Nessa estratégia de formação de parceria, permite-se que um nó \repasss obtenha
os pacotes \pks $\in$ \setpks de duas ou mais fontes distintas. No caso do
exemplo supracitado, o nó \repassu{6} pode continuar recebendo o fluxo de dados
através do caminho \setwayiu{1} e também através do novo caminho \setwayis que
acabara de ser constituído.

Para generalizar, apresenta-se no Trecho de
Código~\ref{algo:findPartnerCombinePath}, um pseudo-algoritmo para a formação
de parceria por combinação, executado em qualquer nó \serv.\\

\begin{algorithm}[H]
\label{algo:findPartnerCombinePath}
\SetAlgoLined
\KwData{\textit{relayPartners} \attrib [ ]}

\SetKwFunction{Union}{Union}\SetKwFunction{make_pkt}{make\_pkt}
\SetKwFunction{Union}{Union}\SetKwFunction{recv_pkt_rdt}{recv\_pkt\_rdt}
\SetKwFunction{Union}{Union}\SetKwFunction{send_pkt_rdt}{send\_pkt\_rdt}
\SetKwFunction{Union}{Union}\SetKwFunction{getKnownPaths}{getKnownPaths}
\SetKwFunction{Union}{Union}\SetKwFunction{matchSimilarPath}{matchSimilarPath}
\SetKwFunction{Union}{Union}\SetKwFunction{parse_path}{parse\_path}
\SetKwFunction{Union}{Union}\SetKwFunction{length}{length}

mspf \attrib 0.4\tcc*[r]{paths are considered similar if similarity level is
equal or above mspf value}
pathSet \attrib \getKnownPaths{}\tcc*[r]{get \setways known in this \serv}

\ForEach{\setwayiu{x} $\in$ \setway}{
  \If(){\matchSimilarPath{\setwayiu{x}, \setwayis} >= mspf}{
    \tcc{Get the closest partner in the path (intersection between \setwayiu{x}
and \setwayi) and add to the list of prospective partners for \repass.}

    prosRelay = NULL\;
    \ForEach{\ways $\in$ \setwayiu{x}} {
      \If(){\ways $\in$ \setwayi} {
	\textit{relayPartners}[\length{relayPartners}] \attrib prosRelay\;
      }
    }
  }
}

pkt $ \leftarrow$ make\_pkt(GMTP\_ADV\_RELAY(\textit{relayPartners}), \repass)\;

send\_pkt\_rdt(pkt)\;

\caption{matchPartnersByPathCombination(\setwayi, \repass)}
\end{algorithm}
\vspace{0.8cm}



\subsection{Sobre o melhor caminho \setwayi}
\label{subsec:melhorcaminho}

De acordo com os procedimentos empregados de seleção de nós, é possível obter
diferentes caminhos \setwayi, partindo-se de um nó \repasss para um nó \serv.
Por este motivo, é importante definir, a partir de um conjunto de caminhos
possíveis, qual é o melhor caminho a utilizar e ordená-los de acordo com a
prioridade de uso. Com isto, é possível obter \setpks a partir de múltiplos
\repasss e usar caminhos alternativos em caso de falha de algum caminho, por
exemplo, por desconexão. No GMTP, a ordem de prioridade para uso de cada
caminho \setwayis é determinada de acordo com dois critérios:

\begin{enumerate}
  \item Menor atraso fim-a-fim entre \repasss e \serv; \label{i:c-atraso}
  \item Maior tempo de disponibilidade dos nós \ways $\in$ \setwayi;
\label{i:c-uptime}
  \item Menor número de nós \ways $\in$ \setwayi; \label{i:c-nnos}
  \item Se o caminho for \setwayif; \label{i:c-waycomp}
  \item Escolha aleatória de \setwayis entre os \setways conhecidos.
\label{i:c-aleat}
\end{enumerate}

O critério~\ref{i:c-atraso} é determinado através da medição do RTT. O
critério~\ref{i:c-uptime} é obtido através de tal informação compartilhada por
cada nó \ways $\in$ \setwayi. O critério~\ref{i:c-nnos} é determinado pela
contagem simples do número de \ways $\in$ \setwayi. O
critério~\ref{i:c-waycomp} é determinado através da verificação da condição
$\mid$\setwayi$\mid$ $=$ $ttl($\repass$,$\setwayi$)$, onde \textit{ttl} é uma
função que determina o número de saltos entre o nó \repasss até o último nó
\ways $\in$ \setwayi, que é um nó \serv. Na prática, este valor pode ser obtido
através do valor do campo TTL (\textit{Time-to-Live}), disponível no cabeçalho
IP de qualquer pacote. O critério~\ref{i:c-aleat} é utilizado em caso de não
determinação do melhor \setwayis até o critério anterior.

Note que no GMTP é possível que um nó \repasss tenha simultaneamente mais de um
nó parceiro \repassu{q}, porém não mais do que uma certa qualidade configurável
devido ao fato de que os pacotes \pks dos fluxos \setpk serem transientes,
portanto não faz sentido realizar muitas parcerias. No caso do GMTP, a
quantidade máxima padrão de parcerias que um nós \repasss realiza é $5$, valor
praticado em outros soluções similares para transmissão de fluxos de dados ao
vivo baseados em arquitetura P2P.

\section{Distribuição do fluxo de dados \setpks através de \net}
\label{sec:asptransrecep}

No GMTP, a transmissão de dados é feita utilizando uma estratégia híbrida
\textit{pull/push} para obtenção do fluxo de dados \setpk. O método
\textit{push} é adotado como padrão, onde os nós \servs iniciam a
transmissão de \pks $\in$ \setpks para os demais nós \ways
$\in$ \setwayi, onde \wayu{1} $=$ \serv. Já o método \textit{pull} é utilizado
quando um nó \clis precisa obter parte de uma mídia que está prestes a ser
reproduzida e ainda não foi repassada por um nó \repasss via \textit{push}, de
acordo com o seu mapa de \textit{buffer}. Os nós \repasss e \clis mantêm seus
próprios mapas de \textit{buffer}, sendo que um no \repasss sempre terá um mapa
de \textit{buffer} mais atualizado do que os mapas de \textit{buffer} dos
seus clientes.

Nessa seção, apresentam-se detalhes sobre como o GMTP realiza a disseminação de
\setpks e como os nós \clis recebem tal conteúdo para reprodução, discutindo-se
aspectos sobre indexação de conteúdos, requisição e recepção de uma mídia,
compartilhamento e controle de congestionamento.

\subsection{Indexação de Conteúdo}
\label{subsec:content-index}

No GMTP, um fluxo de dados \setpks tem um nome único que o identifica em
qualquer nó, seguindo o princípio das redes centradas no conteúdo. Sendo assim,
todo evento \events é identificado por um nome que é utilizado por qualquer nó
para solicitar o fluxo de dados \setpks corresponte a \event.

No caso do GMTP, um nome para o evento é definido por um UUID
(\textit{Universally Unique IDentifier}) de 128 bits~\cite{RFC4122}. Na sua
forma canônica, um evento \events é representado por uma sequência de 32
dígitos hexadecimal, exibidos em cinco grupos separados por hífen, na forma de
\{8\}-\{4\}-\{4\}-\{4\}-\{12\}. Por exemplo, \events $=$
641f931f-d3ac-50e3-b625-537574541f1f.

O identificador de um evento \events é criado pelo nó \servs que gera a mídia,
que o divulga através de um serviço similar ao DNS ou por meio de uma busca
de diretório. Além disso, um nó GMTP poderá requisitar uma lista dos fluxos
transmitidos por \serv. De posse de um identificador para um evento \event, um
nó GMTP poderá solicitar \setpks de \events aos seus nós parceiros \repassu{q}
ou diretamente a um nó \serv. A divulgação dos identificadores de todos os
eventos transmitidos por um nó \serv é feito no seguinte formato textual e
consultado pelo registro do tipo SID (\textit{Streaming IDentifier}) do DNS. Por
exemplo, suponha um serviço de distribuição de conteúdos multimídia da Rede
Globo de Televisão, uma requisição poderá ocorrer como ilustrado no Trecho de
Código~\ref{algo:requestDNS}, utilizando qualquer ferramenta de resolução de
nomes por tipo de registro a um servidor DNS. Note que três eventos estão
registrados, identificados pelos seus respectivos nomes.\\

\newcommand{\bigspace}{~~~~~}

\begin{algorithm}[H]
\label{algo:requestDNS}
\SetAlgoLined

\textbf{dig} -t SID globo.com\\
\textbf{QUESTION SECTION:}\\
\bigspace globo.com.\bigspace IN\bigspace SID\\

\textbf{ANSWER SECTION:}\\
\bigspace globo.com.\bigspace IN\bigspace SID\bigspace
"111f931f-d3ac-10e3-b62f-f17f74541f1f"\\
\bigspace globo.com.\bigspace IN\bigspace SID\bigspace
"72c44591-7d82-427c-825f-722f015787c1"\\
\bigspace globo.com.\bigspace IN\bigspace SID\bigspace
"0bb0b9f5-f57d-4da5-8a6c-13acf1965188"\\

\textbf{SUMMARY:}\\
\bigspace Query time: 4 msec\\
\bigspace SERVER: 192.168.1.252:53(192.168.1.252)\\
\bigspace WHEN: Tue Jul 16 15:44:25 2013\\

\caption{Requisição da lista de eventos de um distribuidor de conteúdo.}
\end{algorithm}
\vspace{0.8cm}

\subsection{Estabelecimento de conexão e compartilhamento para obter \setpk}
\label{subsec:conexao-requisicao}

==============

Após o registro de participação, o nó \repasss deve enviar periodicamente
sinalizações de controle (\textit{polling}) sobre sua participação na rede de
favores $\eta$. Este procedimento deve ser feito usando o pacote do tipo
\pac{GMTP-Ack} em um tempo $t = max(300, t_{user}) - RTT$, onde $t$ e $RTT$ são
definidos em segundos, e $t_{user}$ é um parâmetro de tempo definido pelo
usuário. Quando \servs receber um pacote do tipo \pac{GMTP-Ack} do nó \repass,
este deve enviar um pacote do mesmo tipo. Caso \repasss não receba
\pac{GMTP-Ack} no período de $4 \times RTT$, deve-se repetir tal procedimento
por no máximo 3 vezes, quando \repasss deve considerar a conexão finalizada por
tempo de expiração (\textit{timeout}) e enviar um pacote do tipo
\pac{GMTP-Reset}. Na RFC 5482~\cite{RFC5482}, discute-se sobre outros aspectos
de expiração no tempo que podem ser adaptadas para o GMTP.

Implementar o algoritmo da função \respondToClients:
\respondToClients{\textit{channel}} % nessa tem que buscar os clientes esperando por resposta
\respondToClients{\setpk, \cli}

tem que ter: getClientsWaitingForFlow(\setpk) mandar o leitor ver a linha 7 do algoritmo algo:registerRelay

% \textit{channel} \attrib \getChannelOfFlow{\setpk}\;
% \textit{\pk} \attrib \makePkt{GMTP-Response(), \cli}\;
% servs \attrib \getCurrRegedServers()\tcc*[r]{servs $\subset S$}
% pkt \attrib \makePkt{GMTP-Register, \serv}\tcc*[r]{register request}


==============

O processo de conexão do protocolo \mudccps é separado em três fases. A
primeira acontece quando um nó qualquer \cliu{1} deseja obter \setpks
transmitido por um nó \servs e não existe nenhum outro nó \clis em sua rede
local recebendo \setpks (passos 1 e 2 da Figura~\ref{fig:processo-conexao})
através de um nó \repass, tal que \cliu{1} $\in$ \subsetcli$($\repass$)$. A
segunda fase acontece quando um novo nó \cliu{2} $\in$
\subsetcli$($\repass$)$ deseja obter o mesmo fluxo \setpks do nó \cliu{1}
(passos 3 e 4 da Figura~\ref{fig:processo-conexao}). E, por fim, a terceira
fase acontece quando o nó \repasss começa a buscar novos nós parceiros
\repassu{q} a fim de obter \setpks.

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=.8]{imgs/processo-conexao.pdf}
\end{center}
\vspace{-1cm}
\caption{Processo Básico de Estabelecimento de Conexão do \mudccp.}
\label{fig:processo-conexao}
\end{figure}

\subsection{Fase 1: primeira requisição a um fluxo \setpk}
\label{subsec:conn-fase1}

Na primeira fase, o nó \cliu{1} envia um pedido de conexão para o nó \serv, que
é interceptado por \repass, cuja principal responsabilidade é repassar \setpks
para quaisquer outros nós \clis $\in$ \subsetcli$($\repass$)$.

O estabelecimento de uma conexão \mudccps ocorre quando um nó \clis cria um
socket e envia um pacote do tipo \pac{GMTP-Request} contendo o nome do fluxo
\setpk (camada de transporte), destinado ao nó \serv (camada de rede). Como na
fase $1$ assume-se que não existe nenhum nó \clis recebendo o fluxo \setpks, o
pacote \pac{GMTP-Request} alcança obrigatoriamente seu nó \repassu{1}, que
verifica a inexistência do registro de recepção do fluxo \setpks e por isso
roteia o pacote \pac{GMTP-Request} com destino ao nó \servs correspondente. À
medida que o pacote \pac{GMTP-Request} é repassado através dos nós \repasss
$\in$ \setway, selecionado conforme discutido na Seção~\ref{sec:descparc}, cada
nó \repasss que o processar tal pacote, verifica se existe registro de recepção
do fluxo \setpk. Em caso positivo, o respectivo nó \repasss envia um pacote do
tipo \pac{GMTP-Response} para \repassu{1} que, ao recebê-lo, registra a recepção
de \setpk, envia um pacote do tipo \pac{GMTP-Request-Notify} para notificar
\cliu{1} que o fluxo \setpk será iniciado. Neste ponto, conclui-se a fase
$1$ do processo de estabelecimento de conexão e o fluxo \setpk começa a ser
transmitido entre os nós \repassu{1} e \repass. Note que, por serem pacotes de
controle, estes pacotes são transmitidos com garantia de entrega, similar ao
mecanismo adotado pelo TCP.

\subsection{Fase 2: próximas requisições para obter \setpk}

A fase $2$ de conexão ocorre quando futuras requisições a \setpk ocontecerem
após a fase $1$, originadas por qualquer nó \clis $\in$
\subsetcli$($\repassu{1}$)$. Tais solicitações são também interceptadas por
\repassu{1}, que confirma a existência de recepção
de fluxo \setpks e o repassa também para o nó \clis solicitante, notificando
\clis, por exemplo, \cliu{2}, usando o pacote do tipo \pac{GMTP-RequestNotify},
tal como ocorreu na fase $1$, porém com uma diferença: a configuração de um
canal de transmissão multicast na rede local.

O canal de transmissão multicast é configurado para atender ao mesmo tempo os
nós \cliu{1} e \cliu{2}, ao permitir o envio do fluxo de dados \setpks para um
grupo multicast configurado dinamicamente pelo nó \repass. A configuração
automática consiste em gerar aleatoriamente um número de porta e enviar um
pacote do tipo \pac{GMTP-RequestNotify} contendo tal informação e com a flag
binária chamada multicast ativada. Após a crição de tal pacote, \repassu{1} o
envia para o nó \cliu{2} e também notifica \cliu{1}, que então realiza as
configurações devidas para receber o fluxo em modo \textit{multicast}. Além do
bit de sinalização multicast, o pacote do tipo \pac{GMTP-RequestNotify} também
contém um campo de endereço IP (\ut{32}{bits}), que especificará qual endereço
IP o nó \repass passará a transmitir os dados (canal de repasse), e mais um
campo para especificar o número de porta (\ut{16}{bits}), que especifica a porta
correspondente ao canal de repasse.

\subsection{Fase 3: busca por mais parceiros \repasssu{q} para obter \setpk}

Na fase $3$, o nó \repasss inicia um processo de aumentar suas parcerias a fim
de obter mais rapidamente os pacotes \pks $\in$ \setpks e caminhos \setways alternativos
em caso de falha e/ou desconexões de algum nó parceiro \repassu{q}. Ao
considerar os aspectos discutido na Seção~\ref{sec:descparc}, nota-se que na
Fase $1$ e $2$ utiliza-se os modos de formação de parcerias intra \setways e por
intersecção, porém ainda resta fazer uso do modo de formação de parceria por
combinação de \setway
(Figura~\ref{fig:esquema-abstrato-formacao-parceria-combinacao}). Na fase $3$ de
conexão, o GMTP explora tal recurso.

Nesse contexto, seja um nó \repassu{3} que esteja recebendo \setpks originado
em um nó \serv. Para conseguir mais nós parceiros \repassu{q}, o nó \repassu{3}
envia uma requisição do tipo \pac{GMTP-RelayQuery} para \servs e obtém um
subconjunto de nós \repasssu{q} candidatos a parceiro de \repassu{3}, como
ilustrado na Figura~\ref{fig:conn-phase3-1}. Note que a lista de nós parceiros
enviada pelo nó \servs é construída usando o
algoritmo~\ref{algo:findPartnerCombinePath} e,
portanto, os nós \servs funcionam como um indexador (\textit{tracker}) de nós
parceiros \repassu{q}, executando uma pré-seleção de nós parcerios para
\repassu{3}. Esta pré-seleção ajuda o nó \repassu{3} a selecionar os melhores
parcerios disponíveis, de acordo com os critérios definidos
em~\ref{subsec:melhorcaminho}.

Diante do exposto, faz-se necessário registrar três procedimentos importantes
realizados pelo GMTP na Fase $3$:

\begin{enumerate}

  \item um nó \repasss pode enviar periodicamente requisições do tipo
\pac{GMTP-RelayQuery} para o servidor a fim de descobrir melhores parceiros e
aumentar seu leque de opções. Apesar disso, a quantidade de possíveis parcerios
de um nó \repasss não significa, necessariamente, que tal nó mantém a mesma
quantidade de parcerias efetivas para obter um fluxo de dados \setpk. Os
parâmetros de periodicidade de requisições do tipo \pac{GMTP-RelayQuery} e a
quantidade máxima de parcerias efetivas pode ser alteradas pelo administrador
de \repasss e tem valores padrões de 10 minutos e 5 nós, respectivamente;

  \item como ilustra-se na Figur~\ref{fig:conn-phase3-2}, apenas na Fase $3$,
permite-se requisições do tipo \pac{GMTP-Request} partindo de um nó
\repassu{\repassi_{3}} em direção a outro nó \repassu{\repassi_{2}}, que irá
enviar um resposta do tipo \pac{GMTP-Response} se \repassu{\repassi_{1}} enviar
uma chave secreta aceita por \repassu{\repassi_{2}} e encaminhada para
\repassu{\repassi_{1}} pelo nó \serv, que a obteve de \repassu{\repassi_{2}} no
processo de registro de participação discutido na
Seção~\ref{subsec:registro-participacao}. Note que nesse caso, mesmo se nó
\repassu{\repassi_{2}} não estiver recebendo o fluxo de dados \setpks de
interesse de \repassu{\repassi_{1}}, o nó \repassu{\repassi_{2}} deve
estabelecer uma conexão (Fase 1) para obtê-lo e então repassar \setpks para
\repassu{\repassi_{1}};

  \item como se considera uma arquitetura híbrida P2P/CDN, o nó \servs pode
facilmente realizar um mecanismo de balanceamento de carga, incluindo na lista,
como se fosse um nó \repass, um outro nó \serv, levando-se em consideração,
inclusive, todos os critérios estabelecidos na
Seção~\ref{subsec:melhorcaminho}.

\end{enumerate}

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=0.9]{imgs/gmtp-conn-phase3-1.pdf}
\end{center}
\vspace{-1cm}
\caption{Fase 3 de conexão do GMTP (Passo 1).}
\label{fig:conn-phase3-1}
\end{figure}

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=0.9]{imgs/gmtp-conn-phase3-2.pdf}
\end{center}
\vspace{-1cm}
\caption{Fase 3 de conexão do GMTP (Passo 2).}
\label{fig:conn-phase3-2}
\end{figure}

\subsection{Compartilhamento de \setpks entre \servs}

Além do processo transparente para se obter um fluxo de dados \setpks
empregado
no GMTP, como os nós \servs constituem uma rede CDN, estes podem negociar entre
si o envio e a recepção de um fluxo de dados \setpks de acordo com as
requisições submetidas aos nós \repass. Desta forma, se um nó \repasss enviar
uma requisição para obter \setpks de um evento \events a um nó \servs e este não
esteja recebendo tal fluxo, \servs poderá solicitá-lo a outros nós \servs da
CDN que participa. A partir desse ponto, o nó \servs passará a servir o nó
\repasss normalmente. Como no GMTP se faz uso indireto dessa função das redes
CDNs, a qual já está consolidada, resolveu-se suprimir maiores detalhes a
respeito deste assunto. Para maiores informações sobre a função de distribuição
de conteúdos ao vivo entre os servidores de uma rede CDN, o leitor pode
consultar as
referências~\cite{Nygren:2010:ANP:1842733.1842736,1250586,Pathan2008}.

\vspace{0.5cm}

Desta forma, o processo de conexão do GMTP é fundamental para a efetiva
distribuição de mídias ao vivo, pois permite-se que as aplicações compartilhem
fluxos de dados entre si, mesmo que tais aplicações não tenham sido
desenvolvidas pela mesma equipe. Esta unificação ajuda no processo de
distribuição do fluxo de dados \setpk, pois, na prática, até mesmo uma aplicação
\textit{standalone} e um objeto de vídeo imbutido em uma página Web podem obter
o mesmo fluxo de dados sem que estas conheçam um a outra. Como resultado,
reduz-se para 1 o número de transmissões para um mesmo fluxo de dados \setpks
destinados a uma mesma rede ou para um subconjuntos de redes adjacentes. Além
dessa diferença substancial, a forma de conexão do GMTP supre uma antiga
deficiência das soluções tradicionais de transmissão multicast, as quais os
nós clientes, camada de aplicação, tinham que se adaptar às configurações
estáticas dos canais multicast definidos pelo administrador de rede, e até os
próprios administradores de rede tinham que fazer tal configuração de forma
manual, que obrigatoriamente tem que ser realizada em todos os nós roteadores
de um determinado caminho. Até o presente momento, não se conhece nenhuma
solução que permita configuração dinâmica de canais multicast da forma que foi
explicada nesta seção, com benefícios diretos para a aplicação e para a rede,
fazendo-se uso dos recursos computacionais e de rede de forma mais apropriada,
como será discutido no Capítulo~\ref{cap:analisedesemp}.

\subsection{Envio e recebimento de \pks $\in$ \setpks em \net}
\label{subsec:trocdados}

Após o estabelecimento de conexão, os nós \repasss trocam dados entre si em modo
unicast a fim de obter \setpk, constituído de pacotes \pks do tipo
\pac{GMTP-Data} e \pac{GMTP-DataAck}. De forma similar, os nós \repasss
utilizam os mesmos tipos de pacotes para enviar \pks $\in$ \setpks para os nós
\cli, porém em modo multicast. Nesta seção, detalha-se como o GMTP executa as
funções para transmissão que, em ambos os casos, realiza-se controle de
congestionamento, sendo tal função descrita na Seção~\ref{subsec:ccgmtp}.

Após o processo de estabelecimento de conexão, o \mudccps entra no
estado de transmissão de dados. Se o \mudccps estiver em funcionamento em
um nó \servs ou em um \repass, o estado é o de \textit{transmitindo dados}, ao
passo que quando executado em um cliente o estado é o de \textit{recepção de
dados}. Nesta seção, discute-se o funcionamento do mecanismo de transmissão e
recepção de dados no \mudccp.

Para o transporte de dados da aplicação, um \servs ou um \repasss deve criar
pacotes do tipo \pac{GMTP-Data} ou o \pac{GMTP-DataAck} e enviá-los aos nós
\clis através do socket correspondente à conexão estabelecida. Embora o
protocolo \mudccps transmite dados sem garantia de entrega, em alguns casos,
dados de controle podem ser transmitidos de forma confiável. Nestes casos,
durante a transmissão de dados, um nó \mudccps utiliza-se do pacote do
tipo \pac{GMTP-Data} para enviar dados, ao passo que utiliza-se pacote
\pac{GMTP-Ack} para confirmar a recepção de pacotes, ou ainda, utiliza-se
\pac{GMTP-DataAck} para enviar pacotes de dados e ao mesmo tempo confirmar a
recepção de pacotes de dados vindos da direção oposta (\textit{piggyback}).

\subsubsection{Buffer de Envio e Recepção:}

A transmissão de um evento \events consiste no processo de disseminação
dos pacotes \pks $\in$ \setpks através dos nós interessados em obtê-lo. Para
isto, cada nó GMTP controla um buffer de envio e recepção no formato de uma
estrutura de dados do tipo array, onde cada posição é utilizada para armazenar
um pacote \pks (Figura~\ref{fig:buffer-envio-recepcao}). Ao receber \pk, um nó
GMTP armazena-o no buffer e posteriormente o entrega para a aplicação, que o
reproduz para o usuário final. Para o envio ou repasse de um pacote, o nó GMTP
consome os pacotes \pks do buffer e transmite para o(s) nós interessados, seja
em modo unicast e/ou em modo multicast. Isto porque é possível que um nó
\repassu{\repassi_{1}} repasse \pks para um outro nó \repassu{\repassi_{2}}
(unicast) ao mesmo tempo que \repassu{\repassi_{1}} pode repassar \setpks para
seus nós \clis (multicast).

O buffer de envio e recepção do GMTP tem seu tamanho definido no processo de
estabelecimento de conexão, sendo determinado um valor mínimo e um valor
máximo, sendo estes permanecendo fixos durante todo o ciclo de vida de uma
conexão GMTP. Essa decisão é importante porque permite um nó \repasss alocar
previamente o recurso necessário para um determido fluxo de dados \setpk. O
tamanho do buffer é especificado pelo nó \servs e sempre é propagado para os
demais nós no cabeçalho do pacote do tipo \pac{GMTP-MediaDesc}, como discutido
a seguir. Este aspecto é muito importante, pois a aplicação que deve tomar tal
decisão, de acordo com o tipo e formato da mídia a ser transmitida. Para o GMTP,
é importante apenas ter conhecimento sobre o tamanho do buffer para executar
ações de descarte de \pk.

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=0.76]{imgs/buffer-envio-recepcao.pdf}
\end{center}
\vspace{-1cm}
\caption{Exemplo da estrutura do buffer de envio e recepção de um nó GMTP com
tamanho de 17 \pk.}
\label{fig:buffer-envio-recepcao}
\end{figure}

\subsubsection{Mapa de \textit{buffer}:}

O mapa de buffer do GMTP descreve o estado atual do buffer de envio e recepção
de um nó GMTP. Como ilustrado na
Figura~\ref{fig:mapa-buffer-envio-recepcao}, trata-se de uma estrutura de dados
binária que determina se um pacote \pks está ou não presente no buffer de um
respectivo nó GMTP.

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=0.76]{imgs/mapa-buffer-envio-recepcao.pdf}
\end{center}
\vspace{-1cm}
\caption{Exemplo do mapa de buffer de um nó GMTP com tamanho de 17 \pk.}
\label{fig:mapa-buffer-envio-recepcao}
\end{figure}

O mapa de buffer é utilizado por um nó GMTP para sinalizar seu atual estado com
relação a um determinado fluxo de dados \setpk. Um nó GTMP pode enviar o mapa de
buffer completo, como ilustrado na Figura~\ref{fig:mapa-buffer-envio-recepcao},
ou o mapa de buffer apenas dos \pks presentes ou ausentes. Na prática,
um nó \repasss envia para um nó parceiro \repassu{q} o mapa de buffer dos \pks
presentes quando deseja indicar a sua atual disponibilidade; ao passo que envia
o mapa de buffer dos \pks ausentes quando desejar obtê-los. Para diferençar o
tipo de requisição, utiliza-se uma sinalização binária (\textit{flag}) chamada
\textit{request-type}, onde $0$ significa que o mapa de buffer contém pacotes
disponíveis e $1$, pacotes ausentes;

As trocas do mapa de buffer entre os nós GMTP ocorrem sob demanda, utilizando o
método \textit{pull}, uma vez que o método \textit{push} é utilizado por padrão.
Neste caso, quando um nó \repasss percebe a falta de um ou mais pacotes \pk,
este pode solicitar a um ou mais nós \repasss os pacotes \pks ausentes e então
obtê-los usando o método \textit{pull}. Para isso, um nó \repasss enviar aos
seus nós parceiros \repasssu{q} o mapa de buffer dos pacotes \pks ausentes e
aguarda as respostas sobre tal disponibilidade. Essa sinalização ocorre através
do uso do pacote do tipo \pac{GMTP-DataPull-Request}, que é preenchido com o mapa
de buffer dos pacotes ausentes e transmitido aos respectivos nós parceiros. Ao
receber esse tipo de requisição, um nó parceiro avalia seu conteúdo e responde
com o pacote do tipo \pac{GMTP-DataPull-Response}, o qual contém o mapa de buffer
dos pacotes disponíveis, seguido dos pacotes \pks do tipo \pac{GMTP-Data}. Note
que os pacotes do tipo \pac{GMTP-DataPullRequest} e \pac{GMTP-DataPull-Response}
são transmitidos com garantia de entrega, ou seja, caso sejam perdidos, o GMTP
garante sua retransmissão. Para isto, o GMTP utiliza o mecanismo básico de
envio e confirmação utilizando o pacote do tipo \pac{GMTP-DataAck} ou
\pac{GMTP-DataAck}. No caso de falha na execução de uma requisição utilizando o
método \textit{pull}, o nó GMTP pode reavaliar a necessidade de retransmitir o
pedido, pois é possível que os \pks ausentes já tenham sido expirados e
requisitá-los novamente não fará mais sentido.

Na prática, o mapa de buffer utilizado para sinalizar a presença ou ausência de
\pks é representado por faixas de acordo com o índice do buffer. Por exemplo,
para representar o mapa de buffer dos pacotes ausentes ilustrados na
Figura~\ref{fig:mapa-buffer-envio-recepcao}, o nó GMTP preenche o pacote do
tipo \pac{GMTP-DataPull-Request} com a sequencia \textit{2;6-10;12}. Ao receber
esta sequência, o nó parceiro \repasssu{q} responde com o pacote do tipo
\pac{GMTP-DataPull-Response}, que contém o mapa de buffer de quais
pacotes serão enviados e começa a transmití-los.

% * RELATAR TAXA DE RECEPCAO	- NO RELATA QUAL A TAXA DE RECEPÇÃO
% (PREENCHIMENTO+ATUALIZAÇÃO DO BUFFER)
% * USA ESSA INFO PARA SELECIONAR OS MELHORES PARCEIROS (FILTRO APRIMORADO)

\subsubsection{Descarte de pacotes:}

O descarte de pacotes \pks ocorre sempre no nó \repasss e em duas situações:

\begin{enumerate}

 \item \textbf{Por transbordo do buffer:} descartar os primeiros pacotes \pks
recebidos se o buffer alcançou seu limite, mesmo que ainda não tenham
sido repassados. Uma otimização não explorada neste trabalho, mas que é
possível de ser realizada, é o descarta seletivo de pacotes, primeiro os que
tenham menos impacto na qualidade da mídia, por exemplo, pacotes de dados
contendo quadros B (codificação mpeg). Isto não impede que o vídeo seja
reproduzido, porém com perda de qualidade, ao passo que permite-se a transmissão
de conteúdo com os recursos disponíveis;

 \item \textbf{Por duplicação:} ocorre quando o pacote \pks já foi recebido
anteriormente. Tal verificação é feita de acordo com o número de sequência
presente em cada pacote \pk.

\end{enumerate}

\subsubsection{Descrição do fluxo \setpk:}
\label{subsubsec:desc-conteudo}

O GMTP é um protocolo de transporte e por isto não precisa conhecer o tipo da
mídia a ser transmitida. Porém, levando-se em consideração que uma das
principais motivação do GMTP é promover a compatibilidade entre diferentes
aplicações que o utiliza, faz-se necessário que as aplicações conheçam o tipo
da mídia e assim permitir que qualquer aplicação consiga reproduzir o fluxo de
dados \setpk.

Nesse contexto, incorporou-se no GMTP um mecanismo para descrever \setpk e
permitir que a camada de aplicação receba tal descrição. Para isto, utiliza-se o
padrão SDP (\textit{Session Description Protocol}), definido na RFC
2327~\cite{RFC2327}, uma vez que já é um padrão utilizado pela maioria das
aplicações multimídia e portanto facilita a adaptação destas para o uso do GMTP.
Apesar de ter um propósito geral para descrever sessões multimídia, no GMTP, o
SDP tem o propósito de descrever o conteúdo de \setpk para permitir que os nós
\clis interessados em \setpk interpretem seu conteúdo e sejam capazes e
reproduzi-lo.

Desta forma, o GMTP utiliza o pacote do tip \pac{GMTP-MediaDesc} para
encapsular o conteúdo de descrição SDP. O conteúdo SDP é gerado pelo nó \servs
e disseminado para os nós \repass, que os repassam para os nós \clis no
processo de estabelecimento de conexão, descrito na
Seção~\ref{subsec:conexao-requisicao}. Com isto, o nó \clis obtém as
seguintes informações sobre \setpk:

\begin{itemize}

 \item Identificador do fluxo de dados \setpk;

 \item A codificação e endereçamento da mídia:

\begin{itemize}

 \item O formato da mídia (H.261 video, MPEG video, etc.);

 \item O endereço e porta para obter a mídia (multicast); e

\end{itemize}

 \item Informação para validação de cada pacote \pks $\in$ \setpk. Este assunto
será retomado na Seção~\ref{subsec:seguranca}.

\end{itemize}

Um exemplo de uma mensagem SDP transmitida pelo GMTP é apresentado no Trecho de
Código~\ref{algo:sdp-mediadesc}, onde:

\begin{itemize}

  \item \textit{v}, a versão do SDP;

  \item \textit{o}, a lista de nós \servs que a distribui;

  \item \textit{s}, o nome da mídia, como discutido na
Seção~\ref{subsec:content-index};

  \item \textit{i}, o título da mídia;

  \item \textit{u}, a URI que descreve detalhes sobre a mídia;

  \item \textit{c}, as informações de conexão, como o tipo da rede, a versão do
protocolo de rede e o endereço do nó \repass;

  \item \textit{k}, a chave de criptografia se os pacotes \pks $\in$ estiverem
criptografados;

  \item \textit{f}, o certificado digital emitido pelo nó \servs para validação
do conteúdo de \pks, se desejado;

  \item \textit{m}, o tipo da mídia, a porta de conexão e protocolo de
transporte; e

  \item \textit{a}, atributos adicionais sobre a mídia como, por exemplo,
qualidade, idioma, taxa de bits mínima e máxima necessária para transmitir a
mídia, em bytes.

\end{itemize}

\vspace{0.5cm}

\begin{algorithm}[H]
\label{algo:sdp-mediadesc}
\SetAlgoLined

\bigspace v=0\\
\bigspace o=- IN IP4 177.135.177.241,
IP4 186.192.82.163, IP6 2001:0db8:85a3::7344\\
\bigspace s=72c44591-7d82-427c-825f-722f015787c1\tcc*[r]{ver
Seção~\ref{subsec:content-index}}
\bigspace i=An Introduction about Global Media Transmission Protocol (GMTP).\\
\bigspace u=http://www.ic.ufal.br/projects/gmtp/introduction.ps\\
\bigspace c=IN IP4 200.17.113.100\\
\bigspace k=base64:aGVsbG8gd29ybGQK\\
\bigspace f=x509:http://vid12.akamai.com/certs/cert.crt\tcc*[r]{ver
Seção~\ref{subsec:seguranca}}
\label{line:sdp-mediadesc:f}
\bigspace m=audio 49170 GMTP/RTP/AVP 16000-20000\\
\bigspace m=video 51372 GMTP/RTP/AVP 163840-655360\\
\bigspace a=type:multicast\\
\bigspace a=sendrecv\\
\bigspace a=quality:10\tcc*[r]{ver Seção~\ref{subsec:adapt-flow}}
\bigspace a=lang:en\tcc*[r]{ver RFC1766~\cite{RFC1766}}
\bigspace a=framerate:23.0\\

\caption{Exemplo de uma mensagem SDP no pacote \pac{GMTP-MediaDesc}.}
\end{algorithm}
\vspace{0.8cm}

Nesse exemplo do Trecho de Código~\ref{algo:sdp-mediadesc}, utiliza-se a
primeira versão do protocolo SDP e descreve-se a transmissão de dois fluxos
\setpks (Linhas 10 e 11), sendo um deles de áudio e outro de vídeo. Os fluxos
estão sendo distribuídos por três nós \servs (Linha 2), dos quais dois são
acessíveis através de endereços IPv4 e um através de um endereço IPv6. Os dois
fluxos de áudio e vídeo \setpks são repassados por um nó \repasss acessível por
um endereço IPv4 (Linha 6) através das portas 49170 e 51372, respectivamente
(Linhas 9 e 10). Os nós \repasss podem verificar a autenticidade do conteúdo
de cada pacote \pks através do certificado digital disponível no campo URL
definido na Linha 8 (este assunto será retomadod na Seção~\ref{sec:seguranca}).
Além disso, alguns parâmetros adicionais da mídia são especificados entre as
Linhas 13 e 17, como a qualidade da mídia, que varia entre 1 e 10. Além disso,
informações importantes relacionadas as mídias são as taxas de bits sendo, neste
exemplo, o áudio variando entre \ut{16000}{Bytes} à \ut{20000}{Bytes} e o vídeo
entre \ut{156250}{Bytes} e \ut{625000}{Bytes} (Linhas 10 e 11).

É importante salientar que os nós \repasss utilizam as informações de taxa de
bits para determinar o tamanho do buffer necessário para permitir a transmissão
da mídia, como discutido anteriormente. Note que o tamanho do buffer é definido
em consonância com os parâmetros determinados pelo algoritmo de controle de
congestionamento executado no módulo GMTP-Inter, a ser discutido em detalhes na
Seção~\ref{subsec:ccgmtp}.


\section{Controle de Congestionamento em \net}
\label{sec:ccgmtp}

No \mudccp, disponibiliza-se um arcabouço para adição de novos algoritmos de
controle de congestionamento de forma modularizada. Desta forma, permite-se a
adição e remoção de novos algoritmos de controle de congestionamento.
Atualmente, o GMTP oferece dois algoritmos, um voltado para transmissões em modo
unicast e outro voltado para transmissões em modo multicast.

Na prática, definiu-se um algoritmo para controle de congestionamento híbrido,
cujo comportamento dependerá se o nó que o executa está transmitindo em modo
unicast ou em multicast. Em modo de transmissão unicast, utilizado na
comunicação entre os nós \repass, defini-se a taxa de transmissão de um nó
\mudccps através de um algoritmo de janela deslizante baseado em uma equação
cúbica, com suporte aos protocolos RCP~\cite{REF} e ConEx~\cite{REF}. Já em modo
de transmissão multicast, executa-se um algoritmo baseado em relatórios
transmitidos pelos nós \rel, eleitos em cada rede controlado por um nó \repass,
tal que \rels $\in$ \subsetcli$($\repass$)$. Como ilustrado na
Figura~\ref{fig:ucc-mcc-esquema}, para a parte do algoritmo que funciona em modo
unicast, dar-se o nome de \textit{\mudccps Unicast Congestion Control}
(GMTP-UCC), ao passo que para a parte do algoritmo que funciona em modo
multicast, dar-se o nome de \textit{\mudccps Multicast Congestion Control}
(GMTP-MCC).

\begin{figure}[htb!]
\begin{center}
\includegraphics[scale=.7]{imgs/ucc-mcc-esquema.pdf}
\end{center}
\vspace{-1cm}
\caption{Organização do algoritmo de controle de congestionamento no \mudccp.}
\label{fig:ucc-mcc-esquema}
\end{figure}

\subsection{Controle de Congestionamento Unicast}
\label{subsec:mudccp-ucc}

O \mudccp-UCC funciona de forma similar ao protocolo RCP (Rate Control
Protocol)~\cite{Dukkipati:2008:RCP:1368746}, porém com alguns diferenciais a
serem discutidos a seguir. O RCP é um protocolo para controle de
congestionamento assistido pela rede que tenta emular um \textit{Processor
Sharing} (PS), como um roteador. Nesse caso, se um roteador pudesse obter a
informação exata sobre o número de fluxos de entrada em um dado instante $t$, a
taxa de transmissão ideal para cada fluxo de dados seria $R_{ps}(t) =
\frac{C}{N(t)}$, onde $C$ corresponde à capacidade do link e $N(t)$ ao número de
fluxos no instante $t$.

Dessa forma, Nandita et. al\cite{Dukkipati:2008:RCP:1368746} argumenta que para
um roteador funcionar de forma equânime, tal roteador deve oferecer a
mesma taxa de transmissão para todos os fluxos transmitidos através dele,
mantendo-se a fila de roteamento perto de zero a fim de evitar que apenas os
fluxos que tem pacotes na fila de repasse compartilhem a largura de banda
disponível. Com base nisso, Nandita et. al\cite{Dukkipati:2008:RCP:1368746}
determinou a Equação~\ref{eq:cc-rcp-teoria}, onde $R(t)$ é a taxa de transmissão
que deve ser oferecida para cada fluxo de dados que passa pelo roteador. Com
base na Equação~\ref{eq:cc-rcp-teoria}, estima-se a largura de banda disponível
em um determinado canal, representado pela porção $\alpha(C - y(t)) - \beta
\frac{q(t)}{d_0}$ (mudança agregada) e a dividir por $N(t)$. Como é
impossível determinar o valor exato de $N(t)$, estima-se $\hat{N}(t) =
\frac{C}{R(t-T)}$ e para atualizar $R(t)$ com mais frequência do que no tempo de
um RTT, escala-se a mudança agregada por $\frac{T}{d_0}$, resultando na
Equação~\ref{eq:cc-rcp}, onde:

  \begin{equation}
  R(t) = R(t - d_0) + \frac{\alpha(C - y(t)) - \beta
\frac{q(t)}{d_0}}{\hat{N}(t)}
  \label{eq:cc-rcp-teoria}
  \end{equation}

  \begin{equation}
  R(t) = R(t -T) \left[1+\frac{\frac{T}{d_0}\left(\alpha(C - y(t)) -
\beta \frac{q(t)}{d_0}\right)}{C}\right]
  \label{eq:cc-rcp}
  \end{equation}

  \begin{itemize}

    \item $d_0$, é a média móvel dos valores de $RTT_{s}$, calculada através da
Equação~\ref{eq:calcrtt-rcp}, onde $\theta$ é o ganho e corresponde a $0.02$.
Note que quanto maior o valor de $\theta$, mais rápida será a convergência de
$d_0$ ao valor de $RTT_{s}$.

      \begin{equation}
      d_0 = \theta \times RTT_{s} + (1 - \theta) \times d_0
      \label{eq:calcrtt-rcp}
      \end{equation}

    \item $T = min(RTT_{user}$, $d_0))$, sendo $RTT_{user}$ um tempo definido
pelo usuário caso seja necessário atualizar $R(t)$ mais rápido do que o tempo de
$d_0$;

    \item $R(t - T)$, é a última taxa de transmissão medida;

    \item $y(t)$, é a taxa de tráfego de entrada medida no intervalo entre a
última atualização da taxa de transmissão e $d_0$;

    \item $q(t)$, é o tamanho instantâneo da fila de repasse, em bytes;

%     \item $\hat{N}(t)$, é uma estimativa do número de fluxos em um tempo $t$,
% por exemplo, o número de fluxos enviando pacotes de dados \pk;

    \item $\alpha$ e $\beta$, são parâmetros pré-definidos que determinam
a estabilidade e o desempenho;

    \item $C$, é a capacidade do link.

  \end{itemize}


No GMTP-UCC, o algoritmo para controle de congestionamento, adaptado do
RCP, funciona da seguinte forma:


\begin{enumerate}[{\tab}1$^{\circ}$]

  \item Todo nó \repasss mantém uma única taxa de transmissão $R(t)$, que é
oferecida para todos os fluxos de dados passando por \repasss em um certo
instante $t$. Cada nó \repasss atualizada $R(t)$ aproximadamente a cada RTT.
  \label{step:rcp-gmtp-0}

  \item Todo pacote dos tipos \pac{GMTP-Ack}, \pac{GMTP-Data} ou
\pac{GMTP-DataAck} carrega duas informações de controle (campo no cabeçalho):
  \label{step:rcp-gmtp-1}
  \begin{itemize}

    \item \textit{taxa de transmissão proposta} ($R_{p}$):
corresponde à taxa de transmissão necessária para transmitir um fluxo de dados
\setpk, em geral, calculada pelo nó \serv;

    \item \textit{RTT na fonte} ($RTT_{s}$): corresponde ao RTT
estimado entre quaisquer nós \transu{\transi},\transu{\transi+1} $\in$
\setwayi, ou seja, o RTT entre dois nós \transu{\transi} e \transu{\transi+1}
que processam o respectivo pacote \pks de um fluxo de dados \setpks para
repassar aos seus nós \clis $\in$ \subsetcli(\trans) e em
\subsetcli(\transu{\transi+1}), respectivamente.

%     \item \textit{Diferença de RTT} (RTT$_{d}$): corresponde à diferença entre
% RTT$_{s}$ e o RTT medido entre dois nós \way. Por exemplo, seja um
% caminho \setwayis por onde o fluxo de dados \setpks é transmitido, com
% \waysu{1}=\space \servu{1}, \waysu{2}=\space \repassu{1}, \waysu{3}=\space
% \repassu{2} e \waysu{4}=\space \repassu{3}, tal que
% \wayu{1},\wayu{2},\wayu{3},\wayu{4} $\in$ \setwayi. Considere que o RTT entre
% \wayu{1} e \wayu{2} corresponda a um valor qualquer \textit{x}, o RTT entre
% \wayu{2} e \wayu{3} corresponda a um valor qualquer \textit{y} e o RTT entre
% \wayu{3} e \wayu{4} corresponda a um valor qualquer \textit{z}. Para esse caso,
% \wayu{1} deve especificar RTT$_{s}$ = \textit{x} e RTT$_{d}$ = 0, \wayu{2} deve
% especificar RTT$_{s}$ = \textit{x} e RTT$_{d}$ = \textit{y}; e \wayu{3} deve
% especificar RTT$_{s}$ =
% \textit{x+y} e RTT$_{d}$ = \textit{z}. Com isto, é possível que o nó
% \wayu{4} saiba qual é o RTT acumulado entre \wayu{1} até seu nó parceiro
% \wayu{3} (RTT$_{s}$) e também o RTT apenas entre \wayu{3} e \wayu{4}
% (RTT$_{d}$). Com essas informações expostas para cada nó \ways em um caminho
% \setway, qualquer nó \repasss poderá fazer uso de tais informações para decidir
% com quais nós devem fazer parcerias ou quais são seus melhores parceiros.

  \end{itemize}

  \item No início de uma transmissão de um fluxo de dados \setpk, o nó \servs
transmite um pacote \pks com o valor de $R_{p}$ correspondente à taxa de
transmissão desejada para transmitir o referido fluxo \setpk, com o valor para
$RTT_{s}$ = $\infty$. A taxa de transmissão desejada $R_{p}$ deve ser calculada
pela aplicação, de acordo com a taxa de bits da mídia a ser transmitida e
repassada à instância do GMTP no nó \serv.
  \label{step:rcp-gmtp-2}

  \item Todo nó \ways = \repasss que receber um pacote \pk, se $R(t) <
R_{p}$, então $R_{p} \leftarrow R(t)$, caso contrário nenhuma
modificação é realizada nesse campo. Nesse ínterim, se existir pelo menos um nó
$\in$ \subsetcli$($\way) interessado em obter os pacotes \pks $\in$ \setpks
(Seção~\ref{subsec:conexao-requisicao}), \ways executa as seguintes ações:
  \label{step:rcp-gmtp-3}

  \begin{enumerate}

    \item repassa \pks para seus nós \clis em modo multicast
(Seção~\ref{subsec:trocdados});

    \item cria um pacote \pac{GMTP-Ack} contendo $R_{p}$ e o envia de volta
para seu nó parceiro \repasssu{q} $=$ \wayu{\wayi-1}. O pacote \pac{GMTP-Ack}
também carrega um campo de $RTT_{s}$. Quando \ways receber um pacote
\pac{GMTP-Ack}, deve-se utilizar $RTT_{s}$ para atualizar a média móvel do RTT
para os fluxos que passam por ele, representado por $d_0$.

  \end{enumerate}

  \item O nó \ways deve usar $R_{p}$ como a nova taxa de transmissão para
enviar os próximos pacotes de dados \pks para seu nó parceiro \repasssu{q} $=$
\wayu{\wayi+1}. Na prática, $R_{p}$ é a menor taxa de transmissão oferecida ao
longo do caminho \setwayi.

  \item Todo nó \repasss atualiza periodicamente sua taxa de transmissão local
$R(t)$ de acordo com a Equação~\ref{eq:cc-rcp}.

\end{enumerate}


Sendo assim, no caso do GMTP, a ideia básica é a seguinte: para quaisquer
dois nós \transu{1},\transu{2} $\in$ \setwayi, a taxa de transmissão a ser
utilizada por \transu{1} e \transu{2} será definida pela menor taxa de
transmissão oferecida pelos nós \ways $\in$ \setwayis posicionados entre
\transu{1} e \transu{2}. Com isto, se existir largura de banda disponível entre
\transu{1} e \transu{2}, ou seja, $C - y(t) > 0$, então o GMTP compartilhará
igualmente o canal entre todos os fluxos, inclusive para o fluxo entre
\transu{1} e \transu{2}. Caso contrário, ou seja, se $C - y(t) < 0$, o canal
é considerado saturado e o GMTP reduzá a taxa de transmissão igualmente para
todos os fluxos, inclusive para o fluxo entre \transu{1} e \transu{2}.
Especificamente, no intervalo de tempo T, a largura de banda necessária para
repassar todos os pacotes \pks que estão na fila de repasse em um certo instante
$t$ corresponde à $\frac{q(t)}{d_0}$.

% \subsubsection{Diferença entre o RCP e o GMTP-UCC}
%
% Como discutido, o RCP é um protocolo para controle de congestionamento
% fim-a-fim, % onde os sistemas finais de origem e destino se comunicam e trocam
% pac tes de ACK % para determinar a nova taxa de transmissão $R(t)$ que o nó
% transmissor deve  utilizar para transmitir um fluxo de dados \setpk. Porém, no
% caso do GMTP um nó % \repassu{1} tem como principal função repassar os pacotes
% de dados \pks $\in$ % \setpks do tipo \pac{GMTP-Data/DataAck} para seus nós
% parceiros \repass, em c so % de $\mid$\subsetcli$($\repassu{1})$\mid$ $>$ $0$
% para o fluxo de % dados setpk. Nesse interím, tais nós realizam ações para dar
% suporte ao % ecanismo de controle de congestionamento da rede, como por exemplo
% atualizar o % valor de $R_p$ e $RTT_s$. No RCP, o valor de $RTT_s$ é calculado
% pelo sistema  final de origem, mas no GMTP, quando um nó \repassu{1} forma uma
% parceria co % outros nós \repass, é como se \repassu{1} funcionasse como o nó de
% origem \se vs % e portanto também deveria atualizar o valor para $RTT_s$. Para
% isto, um nó % \repasss precisaria manter estado para cada fluxo de dados \setpk,
% o que % significa manter um temporizador para cada fluxo de dados \setpks %
% compart lhado. Do ponto de vista computacional, delegar tal responsabil dade %
% para um roteador seria uma atividade onerosa porque múltiplos fluxo de dados, %
% originados por diversas fontes \serv, podem passar por um roteador e facilment %
% este se tornaria um ponto de gargalo por ter que processar cada pacote, ca cular
% e atualizar o valor para $RTT_s$ para cada um deles.
%
% Diante desta questão, no GMTP-UCC, em vez de um nó \repasss manter o
% temporizador para cada fluxo de dados \setpk, os nós relatores \rels, tal
% que \rels $\in$ \subsetcli$($\repass) são responsáveis por tal atividade. Isto
% significa que um nó cliente \cli=\rel, localizado na rede de \repass,
% realizará a computação para obter o valor de $RTT_s$, bastando o nó \repasss
% notificar qual nó \rels será responsável por manter tal estado. Isto só é
% possível porque quando um nó \repasssu{1} se torna parceiro de outro nó
% \repassu{2}, a condição $\mid$\subsetcli$($\repassu{1})$\mid$ $>$ $0$ é
% satisfeita para um fluxo de dados \setpk.

\subsubsection{Escolha do algoritmo RCP em detrimento ao XCP:}

Tanto o RCP quanto o XCP são os protocolos mais famosos do estado da arte que
tentam emular um PS entre os fluxos que passam por ele, e por este motivo as
equações de controle tanto do RCP quanto do XCP são similares. O grande dilema
foi decidir qual dos dois poderia ser adotado no GMTP-UCC. A diferença entre
eles é o modo que cada um tenta convergir $R_{rcp}(t)$ e $R_{xcp}(t)$ para
$R_{ps}(t)$. Especificamente, a diferença está no tipo de informação enviada
para um nó transmissor de um fluxo de dados \setpks para atualizar o valor de
$R_{rcp}(t)$ ou de $R_{xcp}(t)$. O XCP continuamente tenta convergir
a taxa de transmissão para um ponto de equilíbrio onde todos os transmissores
transmitirão pacotes de dados a uma taxa de transmissão $R_{xcp}(t)$, ao passo
que o RCP calcula uma única taxa de transmissão que deve ser utilizada por
todos os nós transmissores.

No caso do XCP, o protocolo aumenta ou diminui a janela de congestionamento de
um fluxo \setpks de acordo com o tamanho atual da sua janela de
congestionamento. Isto ocorre porque o XCP reduz gradativamente os tamanhos da
janela de congestionamento dos fluxos com $R_{xcp}(t)$ maior do que $R_{ps}(t)$
e gradativamente aumenta o tamanho das janelas de congestionamento dos fluxos
com $R_{xcp}(t)$ menor do que $R_{ps}(t)$. Porém, o tamanho da janela de
congestionamento é sempre menor para os fluxos iniciados mais recente. Assim, em
qualquer momento, os fluxos XCP podem ter diferentes tamanhos de janela de
congestionamento e de RTTs, portanto diferentes taxas de transmissão
$R_{xcp}(t)$.

No RCP, todos os fluxos (novos e antigos) recebem a mesma taxa de transmissão
$R_{rcp}(t)$ baseada no estado atual do nó \repasss com menor largura de banda
disponível em um certo instante $t$. Isto permite que um fluxo de dados de
curta duração termine o mais rápido possível ao passo que os fluxos de dados
mais longos não influenciam diretamente no compartilhamento equânime do PS,
alocando para estes também um taxa de transmissão sem permitir que parte da
largura de banda disponível fique ociosa por muito tempo.

O XCP é computacionalmente mais complexo do que o RCP, uma vez que define
diferentes valores de \textit{feedback} para cada fluxo, envolvendo operações
matemáticas (multiplicação e soma) para cada pacote, o que torna um XCP mais
lento que o RCP. Pela estratégia de mudança no tamanho da janela de
congestionamento, o XCP pode leva múltiplos RTTs para a maioria dos fluxos
alcançarem a taxa de transmissão equânime entre eles, mas que mudam com o passar
do tempo à medida que novos fluxos são injetados na rede e outros são
finalizados, devido à natureza dinâmica das redes. No caso do RCP, esses
problemas não ocorrem porque mantém-se uma única taxa de transmissão para todos
os fluxos, não envolvendo qualquer computação adicional por pacote \pks que
passa por \repass.

Desta forma, os aspectos que determinam o funcionamento do RCP são fundamentais
quando se trata de transmissão de conteúdos multimídia ao vivo, aliado às outras
estratégias adotadas no GMTP para a distribuição de conteúdos multimídia ao
vivo. Isto porque, ao tempo que o RCP define uma taxa de transmissão equânime
para todos os fluxos, sua reação é rápida às mudanças circunstanciais na rede,
tanto para uma super-utilização de um canal quanto para a sua sub-utilização.
Como o RCP escala naturalmente com relação à capacidade de transmissão do canal
e ao RTT, o seu desempenho é invariante com relação ao tamanho de um fluxo,
portanto não importa qual tipo de fluxo as aplicações geram. Isto permite que
fluxos de dados GMTP+RCP e TCP+RCP coexistam na Internet de forma equânime,
além do GMTP evitar sobrecarga nos nós \servs devido às outras funções
de distribuição de fluxos de dados empregadas, explicadas anteriormente.

%
% =====>> PAREI AQUI. LER O ARQUIVO http://yuba.stanford.edu/rcp/RCP-IWQoS.pdf,
% SEÇÃO 2.2
%
% Rate Control Protocol (RCP) is a congestion control algorithm designed for fast
% download times (i.e. aka user response times, or flow-completion times). Whereas
% other modifications to TCP (e.g. STCP, Fast TCP, XCP) are designed to work for
% specialized applications that use long-lived flows (scientific applications and
% supercomputer centers), RCP is designed for the typical flows of typical users
% in the Internet today. For example, a mid-size flow in the Internet today
% contains 1000 packets and TCP typically makes them last 10x longer than need-be
% (XCP is even worse). RCP makes flows finish close to the minimum possible,
% leading to a perceptible improvement for web users, distributed computing, and
% distributed file-systems. We believe RCP is the only congestion control
% algorithm to do this.
% The main properties of RCP are:
%
% Typical Internet flows will see 10 times faster download times than TCP and 30
% times faster than XCP. Winners are the greater than 90% of sessions that never
% leave slow-start today.
% Efficiently uses high bandwidth-delay product networks such as the long haul
% optical links
% Provably stable network independent of link-capacities, round-trip times and
% number of flows
% Flows are easy to police, to ensure they adhere to congestion control (not
% generally possible with other schemes)
% Network operators can give preference (or weighted preference) to some
% flows/aggregates.
% RCP has two components: (1) End-host congestion control layer that sits between
% IP and TCP/UDP. During introduction, the end-host could adapt by testing for RCP
% at each end and along the path, falling back to TCP if need-be. (2) Each router
% maintains a single fair-share rate per link. Each packet carries the rate of the
% bottleneck link. For each packet, the router compares the two values. If the
% router's fair-share rate is smaller, it overwrites the value in the packet. This
% way, the source learns the fair-share rate of bottleneck link. It is simple,
% requires a very minor change to switches/routers and requires no per-flow
% state.

% \subsubsection{Considerações do GMTP-UCC em caminhos \setwayisfs e \setwayif}

% \subsubsection{Integração do GMTP-UCC com o ConEx}
%
% COMPARAR O GMTP AO TCP NO QUE DIZ RESPEITO COMO AS INFORMAÇÕES SÃO EXPOSTAS VIA
% CONEX.
%
% ========== REVER ===========
%
% No GMTP, os nós \repasss transmitem os vetores de ACKs para o seus nós \repasss
% parceiros e não para o nó \servs que origina o fluxo de dados \setpk. Esta é
% uma diferença considerável se o GMTP-UCC for comparado a qualquer variante do
% protocolo TCP, onde um sistema final transmite os pacotes de ACK para o sistema
% oposto e vice-versa. O ponto é o seguinte: sejam todos os caminhos \setwayis tal
% que um nó \repasss= \ways $\in$ \setwayi. No GMTP, um nó \ways enviará o vetor
% de ACKs apenas para seus nós parceiros \waysu{\wayi-1}. Essa estratégia é
% fundamental para uma transmissão de um fluxo de dados ao vivo que leva em
% consideração uma arquitetura P2P e o uso de um mecanismo para controle de
% congestionamento. Quando um nó \way expõe o seu vetor de ACK apenas para seus
% nós parceiros \waysu{wayi-1}, permite-se uma regulação da taxa de transmissão
% específica apenas entre eles. Isto significa que o GMTP-UCC realiza controle
% de congestionamento regulando a taxa de transmissão entre dois nós \repass
% visinhos a fim de controlar apenas aquelas que estão envolvidos em um
% congestionamento. Com isto, evita-se o aumento ou a redução da taxa de
% transmissão de um fluxo \setpks para todo um caminho \setway, que ocorreria com
% o uso de algoritmos de congestionamento fim-a-fim, como os adotados no TCP.
% Consequentemente, o GMTP-UCC não sobrecarrega a rede com uma taxa de
% transmissão acima do esperado e também não sub-utiliza a rede com uma taxa de
% transmissão inferior a que a rede pode suportar.
%
% ============================
%
% Uma das funcionalidades do
% TCP é computar os pacotes que alcançam o sistema de destino, uma vez que se
% trata de um protocolo com suporte a garantia de entrega cujo mecanismo funciona
% com base na retransmissão de cada pacote perdido. No caso de protocolos como
% o \mudccp, a computação dos pacotes recebidos e perdidos pelo nó receptor é
% realizada pelo algoritmo de controle de congestionamento. No \mudccp-UCC,
% utiliza-se um mecanismo de vetores de ACKs, computado pelo nó receptor e
% transmitido para o nó transmissor, que então são repassados para o algoritmo
% Cubic a fim de definir a próxima taxa de transmissão. Os vetores de ACKs contém
% informações sobre pacotes perdidos ou pacotes marcados com ECN. Para maiores
% detalhes de como funciona o mecanismo de vetores de ACKs, o leitor pode
% consultar a RFC4341~\cite{RFC4341}.
%
%
% O ConEx é um protocolo que permite um nó remetente informar à rede sobre o
% congestionamento experimentado por pacotes anteriormente transmitindo em uma
% determinada transmissão de dados. No GMTP, especificamente no módulo
% GMTP-Inter, discutido na Seção~\ref{subsec:gmtp-intra-inter}, incorporou-se o
% ConEx para permitir que um nó \repasss possa obter as informações de
% congestionamento experimentada pelos seus nós \repasss parceiros. Com tais
% informações expostas aos nós \repass, é possível utilizá-las para realizar
% gerenciamento de tráfego, por exemplo.

% \subsubsection{Justificativa de uso do TCP-Cubic no GMTP}
%
% Por se tratar de um algoritmo já consolidado, decidiu-se omitir explicações
% detalhadas do funcionamento do algoritmo Cubic no \mudccp. Embora não será
% apresentada uma explicação detalhada do algoritmo TCP Cubic, considera-se de
% suma importância justificar os motivos que levaram a escolha do TCP Cubic para
% transmissões unicast no \mudccp.
%
% O primeiro motivo está relacionado com os diversos resultados de pesquisas
% anteriores, incluindo uma série de resultados obtidos no contexto deste
% trabalho. Nos últimos anos diversas pesquisas científicas constataram a eficácia
% do TCP Cubic em termos da sua equidade para com outros fluxos TCP e, ao
% mesmo tempo, para com fluxos de dados TCP transmitidos utilizando outras
% variantes do TCP, como o TCP Vegas~\cite{Low:2002:UTV:506147.506152}, TCP
% HSTCP~\cite{RFC3649} e o recém lançado TCP Compound~\cite{4146841,5472999},
% utilizado na versão do sistema operacional Windows Vista em diante. O TCP Cubic
% não degrada os fluxos de dados transmitidos utilizando estas variantes do TCP e
% também não é degradado quando em disputa com fluxos de dados não-controlados,
% como os transmitidos utilizando o protocolo UDP.
%
% O segundo motivo é que o TCP Cubic tem sido utilizado pela maioria dos sistemas
% em execução na Internet da atualidade, uma vez que este é o algoritmo para
% controle de congestionamento utilizado por padrão para o sistema operacional
% Linux. Diante disto, desenvolver um protocolo cujo mecanismo para controle de
% congestionamento seja compatível com a maioria dos fluxos de dados é uma decisão
% primordial para o correto funcionamento e aproveitamento dos recursos de rede,
% em especial na Internet.

\subsection{Controle de Congestionamento Multicast}
\label{subsec:mudccp-mcc}

Da mesma forma que no \mudccp-UCC, o objetivo principal do \mudccp-MCC é
determinar uma taxa de transmissão equânime entre os fluxos de dados
transmitidos pelo GMTP e por outros protocolos, como o TCP, porém
em modo de transmissão multicast. No caso GMTP-MCC, trata-se de um algoritmo
responsável pelo controle de congestionamento em uma rede local constituída por
\net$_{sub}$ = \repasss $\cup$ \subsetcli(\repass). Na prática, os nós da rede
\net$_{sub}$ formam um grupo multicast para a transmissão e recepção de um ou
mais fluxos de dados \setpk, onde o nó \repasss sempre será o transmissor e os
nós \clis $\in$ \subsetcli(\repass) os receptores. A estratégia é que o
valor da taxa de transmissão para um fluxo de dados \setpks seja tão próximo ao
valor da taxa de transmissão que o fluxo TCP utilizaria caso fosse
transmitido na rede, portanto um algoritmo \textit{TCP-Friendly}. Um fluxo de
dados é considerado \textit{TCP-Friendly} quando este não degrada a taxa de
transmissão de um fluxo de dados TCP mais do que outro fluxo TCP degradaria
se começasse a ser transmitido na rede.

O \mudccp-MCC foi inspirado em um protocolo publicado pela IETF chamado
\textit{TCP-friendly Rate Control protocol (TFRC)} (RFC 3448~\cite{RFC3448}). O
TFRC é um mecanismo para controle de congestionamento de fluxos unicast que
tenta prevê a taxa de transmissão de um fluxo TCP e utilizá-la em protocolos
diferentes do TCP~\cite{CONG:Floyd00:TFRC:art}. Trata-se de uma abordagem
diferente da utilizada em algoritmos baseados em janela deslizante e que
utilizam pacotes de confirmação para determinar a taxa de transmissão de uma
conexão, como acontece no TCP. No TFRC, o receptor envia para o transmissor
relatórios sobre as perdas observadas e, com base nesse relatório, o transmissor
calcula a nova taxa de transmissão. O TFRC é categorizado com um protocolo
de controle de congestionamento baseado em uma equação matemática
(\textit{Equation Based Congestion Control}). Algoritmos desse tipo são adotados
em diversos protocolos, como é o caso dos CCIDs 3 e 4 do
DCCP~\cite{RFC4341,RFC4342}. Em linhas gerais, o algoritmo TFRC funciona da
seguinte forma:

\begin{enumerate}[{\tab}1$^{\circ}$]
 \item o receptor mede a taxa de perda de pacotes e envia essa informação para o
transmissor;
 \item o transmissor usa esse relatório para medir o RTT até o
receptor;
 \item o transmissor utiliza a Equação~\ref{eq:trfcmudccp} para determinar qual
será a sua próxima taxa de transmissão em função do relatório de perdas e o
RTT obtidos anteriormente;
 \item o transmissor então ajusta sua taxa de transmissão para o valor
calculado no passo anterior.
\end{enumerate}

\begin{equation}
R(p) = \frac{s}{RTT \times \left(\sqrt{\frac{2 \times p}{3}} + \left(12 \times
\sqrt{\frac{3 \times p}{8}}\right) \times p \times (1 + 32 \times p^2)\right)}
\label{eq:trfcmudccp}
\end{equation}

\vspace{0.5cm}

Na Equação~\ref{eq:trfcmudccp}~\cite{Padhye98model}, $T$ é a taxa de transmissão
medida em bytes/segundo definida em função de \textit{s}, que é o tamanho do
pacote medido em bytes; $RTT$, é o RTT entre o nó transmissor e o receptor,
medido em segundos e $p$, a taxa de perda de pacotes observado pelo nó receptor.

Apesar de ser uma estratégia interessante e funcionar em conexões unicast, em
transmissões multicast o algoritmo descrito anteriormente não é eficiente. O
algoritmo é limitado devido a um problema conhecido por \textit{explosão de
retorno} (\textit{feedback implosion}). Esse problema ocorre quando há muitos
receptores enviando relatórios de perdas para o mesmo transmissor, o que resulta
em uma inundação de relatórios, os quais o transmissor é incapaz de processar em
tempo hábil.

Nesse contexto, para evitar o problema da \textit{explosão de retorno},
determinou-se que apenas alguns nós \clis são obrigados a enviar tais
relatórios ao nó \repass. Estes nós são chamados de nós GMTP Relatores e
representados por \rel. No GMTP-MCC, a versão original do TFRC foi alterada e
funciona da segunte forma:

\begin{enumerate}[{\tab}1$^{\circ}$]

  \item O nó \repasss executa um algoritmo de eleição de nós relatores \rels
$\in$ \subsetcli(\repass). Na Seção~\ref{subsec:electrelsreps}, descreve-se o
procedimento para eleger os nós \rel.

  \item Os nós \rels calculam a taxa de transmissão utilizando a
Equação~\ref{eq:trfcmudccp}, ao invés do transmissor realizar este cálculo,
como na versão original do TFRC;
  \label{step:gmtp-mcc2}

  \item Os nós \rels determinam a taxa de eventos de perda, e não todos os
receptores do grupo multicast. Para calcular o evento de perda $p$, utiliza-se
o mesmo procedimento feito pelo TFRC~\cite{RFC3448,Padhye98model}, onde um
intervalo de perda é determinado por consecutivas perdas de pacotes, desde do
primeiro pacote perdido até o último pacote perdido, seguido de um pacote
recebido com sucesso;

  \item O RTT é calculado entre o nó \rels e o nó \repass, com o temporizador
controlado pelos nós \rels e não pelo nó \repass. Isto evita que o nó \repasss
tenha que manter estado de temporizador para cada fluxo de dados \setpks
transmitido para os nós \clis $\in$ \subsetcli(\repass). Para determinar o valor
do parâmetro RTT e calcular a taxa de transmissão através da
Equação~\ref{eq:trfcmudccp}, o GMTP-MCC utiliza a
Equação~\ref{eq:calcrtt-rcp}, com $\theta = 0.25$, padrão do TCP;

  \item A taxa de transmissão a ser utilizada pelo nó \repasss é a média
aritmética de todas as taxas enviadas pelos nós \rel;

  \item Repete-se todos os passos a partir do passo~\ref{step:gmtp-mcc2} a cada
intervalo igual ao RTT ou quando um intervalo de perda $p$ é determinado.

\end{enumerate}

Teoricamente, o GMTP-MCC seria um protocolo \textit{TCP-Friendly} se $R(RTT, p)$
fosse o valor máximo entre as taxas de transmissão relatadas pelos nós \rel.
Porém, optou-se por utilizar a média aritimética dos valores relatados pelos
nós \rels porque, na prática, diversos fatores podem alterar o estado da rede no
instante da transmissão usando o valor máximo da taxa de transmissão reportada
pelos nós \rel. Com esta decisão, define-se uma margem de segurança
evitando-se que o GMTP-MCC alcance o limite superior para o valor da taxa de
transmissão de um fluxo transmitido com TCP. Além disso, a média aritimética
suaviza os valores subsequentes para a taxa de transmissão a ser utilizada pelo
nó \repass.

Um aspecto importante na medição do RTT está relacionado com o início de uma
conexão GMTP, pois não se sabe o valor para inicial para RTT até o final do
processo de estabelecimento de uma conexão. Nesse caso, deve-se utilizar um
valor consideravelmente alto para evitar taxas de transmissões maiores do
que a rede tem capacidade de suportar. No GMTP, utiliza-se o valor inicial de
RTT igual a \ut{150}{ms}. Quando um nó \clis envia um pedido de conexão
utilizando o pacote do tipo \pac{GMTP-Request}, o mesmo deve realizar a sua
primeira medição do valor de RTT, iniciando-se o marcador de tempo para o
cálculo do RTT quando enviar o primeiro \pac{GMTP-Request} e parando-o quando
receber o pacote do tipo \pac{GMTP-Response}. Em seguida, deve-se acionar o
mecanismo de cálculo da taxa de transmissão através da
Equação~\ref{eq:trfcmudccp}, caso o respectivo nó \clis seja eleito um
nó relator.

% No caso do \mudccp-MCC, cada nó \rels
% agrega as perdas de pacotes que ocorrem dentro de um evento de perda, definido
% por uma ou mais perdas de pacotes no espaço de tempo de um RTT. Para o cálculo
% de $p$, utiliza-se a média dos tamanhos dos intervalos de perda, calculada
% através da média ponderada dos $m$ mais recentes intervalos de perdas $l_k,
% \dots, l_{k-m+1}$ seguindo a Equação~\ref{eq:losseventmean}. O conjunto de todos
% os intervalos de perda é chamado de \textit{histórico de perdas}.
%
% \begin{equation}
% l_{avg} = \frac{\sum_{i=0}^{m} w_i \times l_{k-i}}{\sum_{i=0}^{m} w_i}
% \label{eq:losseventmean}
% \end{equation}
%
% Os pesos $w_i$ são escolhidos de tal forma que os intervalos de perdas mais
% recentes recebem pesos mais altos, decrescendo-os gradualmente até $1$
% para os intervalos de perdas mais antigos. Por exemplo, para $8$ intervalos de
% perda $m$, pode-se utilizar os pesos $w = [5, 5, 5, 5, 4, 3, 2, 1]$. Ao
% utilizar-se da média ponderada para o cálculo da média dos tamanhos dos
% intervalos de perda, obtem-se mudanças mais suaves para o valor de $l_{avg}$ à
% medida que os tamanhos dos intervalos de perdas se tornam mais antigos. Para
% grandes valores de $m$, obtem-se mudanças mais suaves para $p$ ao longo do
% tempo, porém isto também reduz a capacidade de resposta e portanto a equidade do
% protocolo. No TFRC, recomenda-se utilizar valores de $m$ entre $8$ e $32$ e por
% este motivo no \mudccps é considerada esta recomendação. A
% Equação~\ref{eq:losseventmean} é definida na RFC 3448~\cite{RFC3448} e foi
% mantida no \mudccp. O protocolo DCCP também utiliza essa mesma abordagem no
% algoritmo de controle de congestionamento CCID-3~\cite{RFC4342}.
%
% Uma vez definido como determina-se a média dos tamanhos dos intervalos de
% perda, a taxa dos eventos de perda $p$ é definido pelo inverso de $l_{avg}$,
% definido na Equação~\ref{eq:losseventrate}. Como um intervalo de perda é
% definido em função do número de pacotes entre de eventos de perdas consecutidos,
% o mais recente evento de perda não pode influenciar na taxa do evento de perda,
% por isto utilizou a função \textit{max} no denominador da
% Equação~\ref{eq:losseventrate}.
%
% \begin{equation}
% p = \frac{1}{max(l_{avg}(k), l_{avg}(k-1))}
% \label{eq:losseventrate}
% \end{equation}
%
%
% Uma outra observação com relação ao ajuste da nova taxa de transmissão de $s_i$
% está relacionado ao fato de um nó $\hat{r}_i$ se desconectar ou perder
% repentinamente sua conexão. Caso isto aconteça com algum nó $\hat{r}_x$, seu
% valor $T_{\hat{r}_x}$ deverá ser desconsiderado no cálculo da nova taxa de
% transmissão $T_{s_{i}}$. Existem duas formas que um relay $s_i$ pode perceber a
% desconexão de um ou mais nós $\hat{r}_i$. A primeira forma é quando um nó
% $\hat{r}_x$ envia explicitamente um pedido de desconexão para $s_i$,
% tal processo é discutido na Seção~\ref{subsec:mudccp-desconexao}, ao passo que a
% segunda forma é quando um contador de tempo de manutenção de conexão, mantido
% pelo relay $s_i$ se expira, tal processo é discutido na
% Seção~\ref{subsec:electrelsreps}. Com esta medida, evita-se utilizar um taxa de
% transmissão $T_{s_{i}}$ incorreta, portanto não correr o risco de utilizar uma
% taxa de transmissão não condizente com o estado atual da rede.
%
% \subsection{Taxa de Eventos de Perda $p$}
% \label{subsec:mcclossevent}


% Para mais discussões acerca de como funciona o mecanismo para medição dos
% intervalos de perda, consulte a referência~\cite{CONG:Floyd00:TFRC:art}.

% Um aspecto importante no cálculo do valor de $p$ é determinar o seu valor
% inicial.

% \subsection{Cálculo do RTT}
% \label{subsec:mccrtt}
%
% O cálculo do RTT realizado no \mudccp-MCC é feito apenas pelos nós
% reporters e funciona da seguinte forma. Um nó $\hat{r}_i$ transmite ao seu
% respectivo relay $\hat{s}_i$ um pacote de controle e inicia um marcador de
% tempo. Ao receber uma resposta do nó relay $\hat{s}_i$, o nó reporter
% $\hat{r}_i$ pára o marcador de tempo e utiliza este tempo chamado de
% $RTT_{instant}$ para calcular o valor do próximo $RTT$ de acordo com a
% Equação~\ref{eq:calcrtt}.
%
% \begin{equation}
% RTT = \beta \times RTT_{instant} + (1 - \beta) \times RTT
% \label{eq:calcrtt}
% \end{equation}
%
% Note que no \mudccp-MCC não se utiliza o valor de $RTT$ instantâneo
% ($RTT_{instant}$) como o valor do $RTT$, mas sim utiliza-se de um mecanismo
% para suavizar as mudanças do $RTT$ ao longo do ciclo de vida de uma conexão.
% Desta forma, procura-se evitar que valores absurdos de $RTT_{instant}$ -- muito
% baixos ou muito altos com relação aos valores medidos anteriormente --
% influenciem demasiadamente na taxa de transmissão $T_{\hat{s}_i}$.
%
% O mecanismo mencionado anteriormente para suavizar as medições do valor de
% $RTT$ é chamado de Médias Móveis Exponencialmente Ponderadas ou
% \textit{Exponentially Weighted Moving Average} (EWMA). O EWMA foi primeiramente
% utilizado para índices financeiros de medição de risco, onde a série de retornos
% diários com $n$ observações é ponderada por um fator de decaimento. As
% observações mais recentes no tempo são ponderadas com um peso maior que as
% observações mais antigas. O peso de uma observação decai exponencialmente com
% $n$. Em seguida, utilizou-se EWMA em medições de tempo do $RTT$ em protocolos
% como o TCP. Como trata-se de uma estratégia conhecida para medição de RTT, no
% \mudccp-MCC manteve-se o mesmo mecanismo, principalmente por já ter sido
% exaustivamente testado e utilizado. Tanto no TCP quanto no caso do \mudccp,
% utiliza-se $\beta = 0.25$ para o cálculo do valor de $RTT$ através da
% Equação~\ref{eq:calcrtt}~\cite{kurose2006}.

% Porém, diferentemente do mecanismo de medição de $RTT$ no TCP e no TFRC, os nós
% reporters $\hat{r}_i$ são os responsáveis pela medição do $RTT$ e não o nó
% transmissor. Um aspecto importante na medição do RTT está relacionado com o
% início de uma conexão \mudccp, pois não se sabe o valor para $RTT_{instant}$
% até o final do processo de estabelecimento de uma conexão. Nesse caso, deve-se
% utilizar um valor consideravelmente alto para evitar taxas de transmissões
% $T_{\hat{s}_i}$ muito maiores do que a rede tem capacidade de suportar. No
% \mudccp, utiliza-se o valor inicial de $RTT_{instant}$ igual a \ut{150}{ms}.
% Quando um nó $\hat{r}_i$ enviar um pedido de conexão utilizando o pacote do tipo
% \mudccp-Request, o mesmo deve realizar a sua primeira medição do valor de
% $RTT_{instant}$, iniciando-se o marcador de tempo para o cálculo do RTT quando
% enviar o primeiro \mudccp-Request e parando-o quando receber o pacote do tipo
% \mudccp-Response. Em seguida, deve-se acionar o mecanismo de cálculo de
% $T_{\hat{r}_i}$, caso o respectivo nó $\hat{r}_i$ seja eleito como reporter.

% \subsubsection{Confirmação de recepção de \pk}
%
% O GMTP realiza confirmação de recepção de pacotes \pks para avaliar a
% capacidade de entrega e realizar controle de congestionamento.
%
% Nesse contexto, o GMTP é um protocolo orientado a mensagem, como o UDP e o DCCP,
% e não a cadeia de bytes, como é o caso do TCP. Dessa forma, a unidade básica de
% transporte no GMTP é um segmento completo e não cada byte individualmente. O
% tamanho de um segmento varia de acordo com o MTU (\textit{Maximum Transport
% Unit}) da rede, que em geral tem tamanho de \ut{1500}{bytes}, contando com o
% espaço ocupado pelo cabeçalho.
%
% Vetor de ACK \pac{GMTP-DataAck}

\section{Autenticidade de \setpk}
\label{sec:seguranca}

Em uma solução baseada em um modelo de serviço P2P, é possível que nós
mal-intencionados \repasss poluam o sistema com conteúdos que não foram
gerados pelo nó servidor (Figura~\ref{fig:bucket-brigade-principle-4}).

\begin{figure}[ht]
\begin{center}
\includegraphics[natwidth=797,natheight=213,scale=.74]{imgs/bucket-brigade-principle-4.png}
\end{center}
\vspace{-0.8cm}
\caption{Um nó \repasss mal-intencionados podem poluir o sistema com conteúdos
que não foram gerados pelo nó \serv.}
\label{fig:bucket-brigade-principle-4}
\end{figure}

Para evitar esse tipo de ataque, executa-se um procedimento para verificar a
autenticidade de um fluxo de dados \setpk. Para isto, os próprios nós \ways
$\in$ \setwayis verificam se o conteúdo de um pacotes de dados \pks $\in$
\setpks foi alterado por algum nó \ways anterior, durante o procedimento de
repasse. Apenas após comprovar a autenticidade de um pacote \pk, o nó \ways
repassa tal pacote de dados \pks para o próximo nó \wayu{\wayconst+1},
transmitindo-os também para seus nós \clis $\in$ \subsetcli$($\way$)$, se houver
demanda. Este procedimento evita que todos os nós \clis que receberem o fluxo de
dados \setpks tenham que verificar a autenticidade dos pacotes \pk.

Porém, na prática, o ideal seria que todos nós \ways verificassem a
autenticidade de cada pacote \pk, porém, tal ação pode onerar os recursos
computacionais de cada nó \ways e aumentar o tempo de entrega de \pks aos nós
\clis $\in$ \subsetcli$($\way$)$. Isto porque os nós \ways também processam cada
pacote de dados \pks para decidir sobre seu repasse, como discutido nas
Seções~\ref{sec:connformnet} e~\ref{sec:asptransrecep}.

Para reduzir a sobrecarga de verificação de autenticidade de um fluxo de dados
\setpks em cada nós \way, definiu-se duas regras, uma para decidir quais
nós devem realizar a verificação de autenticidade (Regra 1) e a outra para
determinar a quantidade de pacotes que se deve realizar tal procedimento
(Regra 2). Tais regras são definidas a seguir.

\begin{enumerate}

  \item apenas os nós \way, tal que \transmitqu{\way} = 1, devem realizar o
procedimento de verificação de autenticidade do fluxo de dados \setpk; e

  \item os nós \way, definidos pela Regra 1, não devem verificar todos os
pacotes \pks $\in$ \setpk, mas apenas uma quantidade $pc(t)$ de pacotes de dados
\pks $\in$ \setpk, em um instante $t$. Nesse caso, defini-se
$pc(t)$, apresentada na Equação~\ref{eq:qtpxcheck}, em função de:

  \begin{itemize}

    \item $bs(t, \setpkc)$, o número de pacotes \pks $\in$ \setpks presentes no
buffer de repasse de \ways em um instante $t$;

    \item $\frac{1}{\mid \setwayc^{\lhd}_{\setwayii} \mid -1}$, a probabilidade
de um nó \repasss $\in$ \setwayids ter alterado o conteúdo de um ou mais \pks
presente(s) no buffer de repasse de \way, onde \setwayids $=$
\invert{$\delta(\wayconst_{\wayi+1}$, \setwayi$)$} e \setwayis é o caminho
através do qual se transmite os pacotes de dados \pks $\in$ \setpk;

  \end{itemize}

\end{enumerate}

\begin{equation}
pc(t) = \floor*{bs(t) \times \left(1 - \frac{1}{\mid
\setwayc^{\lhd}_{\setwayii} \mid -1}\right)}
\label{eq:qtpxcheck}
\end{equation}

\vspace{0.5cm}

Sendo assim, quanto mais distante um nó \ways estiver do nó \serv, que gera o
fluxo de dados \setpk, mais pacotes \pks $\in$ \setpks deve-se verificar sua
autenticidade. Antes de entender o procedimento para verificar a autenticidade de
um pacote \pk $\in$ \setpk, deve-se entender como o nó \servs deve gerar
manipular os referidos pacotes de dados para que seja possível verificar sua
autenticidade. Este procedimento é explicado a seguir.

\subsection{Transmissão e assinatura de autenticidade de \pks $\in$ \setpk}
\label{subsec:gerar-pacote-assinado}

Quando o nó \servs gerar cada pacote de dados \pks $\in$ \setpk, este deve
gerar uma assinatura digital dos dados da aplicação a serem transportados. Em
seguida, o nó \servs deve incluir a assinatura digital gerada no cabeçalho do
pacote de dados \pk, no campo assinatura (\textit{signature}). Para assinar
digitalmente o conteúdo da aplicação, utiliza-se o método de criptografia
assimétrica RSA, onde $K^{-}_{\servconst_{\servi}}$ e
$K^{+}_{\servconst_{\servi}}$ representam a chave privada e a chave pública de
\serv, respectivamente. No Trecho de Código~\ref{algo:digitalSignPacket},
apresenta-se o procedimento de assinatura de um pacote \pks $\in$ \setpk.

\vspace{0.5cm}

\begin{algorithm}[H]
\label{algo:digitalSignPacket}
\caption{digitalSignPacket(\pk: \pac{GMTP-Data})}

\SetAlgoLined
\tcc{\servs executes this function to digital sign the packet content using
its private key $K^{-}_{\servconst_{\servi}}$ and a pre-defined hash function,
such as the well-know md5 or sha1 function. \servs get the value of data field,
which is the content that application wants to transport and generates a
signature by encrypt the hash of the data using the \servs private key. After,
put the generated signature in the signature field of the packet \pk. The
signature field will be used later by a note \repasss to verify the packet \pks
authenticity executing the function verifyPacketAuthenticity(), defined in
Algorithm~\ref{algo:verifyPacketAuthenticity}.}

\SetKwFunction{Union}{Union}\SetKwFunction{getPacketFieldValue}{getPacketFieldValue}
\SetKwFunction{Union}{Union}\SetKwFunction{setPacketFieldValue}{setPacketFieldValue}
\SetKwFunction{Union}{Union}\SetKwFunction{hash}{hash}
\SetKwFunction{Union}{Union}\SetKwFunction{encrypt}{encrypt}

\textit{data} \attrib \getPacketFieldValue{\pk, `data'}\;
\textit{hashValue} \attrib \hash{\textit{data}}\;
\textit{signature} \attrib encrypt($K^{-}_{\servconst_{\servi}}$,
\textit{hashValue})\;
\setPacketFieldValue{\pk, `signature', \textit{signature}}\;
\Return{\pk}\;

\end{algorithm}
\vspace{0.8cm}

\subsection{Verificação de autenticidade de \pks $\in$ \setpk}
\label{subsec:verifyPacketAuthenticity}

Após definir as regras para verificação de autenticidade do fluxo de dados
\setpk, a quantidade de pacotes $pc(t)$ que um nó \ways deve verificar, nesta
seção discute-se como ocorre o procedimento de verificação de autenticidade de
um ou mais pacotes de dados \pks $\in$ \setpk.

Dada a quantidade $pc(t)$ de pacotes que \ways deve verificar suas respectivas
autenticidades, o nó \ways escolhe aleatoriamente (distribuição uniforme) os
pacotes \pks disponíveis no buffer de recepção, gerendo um conjunto \setpk'
$\subset$ \setpk. Uma vez definido \setpk', \ways executa o procedimento de
verificação de autenticidade que funciona a seguinte forma. Para cada pacote
\pks $\in$ \setpk', extrai-se a assinatura do pacote \pk, gerada pelo nó \serv,
como explicado na Seção~\ref{subsec:gerar-pacote-assinado}. Em seguida,
extrai-se o campo de dados para que se possa verificar sua autenticidade. Para
isto, gera-se o valor de \textit{hash} do campo de dados e compara-se com o
valor de \textit{hash} gerado pelo nó \servs no momento da transmissão do
pacote \pk. Note que o valor de \textit{hash} gerado pelo nó \servs é obtido
através de processo de decriptar a assinatura do pacote de dados \pks utilizando
a chave pública do nó \serv. Assim, se o valor de \textit{hash} gerado com base
no conteúdo transportado no pacote \pks for igual ao valor de \textit{hash}
disponível na assinatura do pacote, conclui-se que o pacote \pks não foi
alterado por nenhum nó \ways $\in$ \setwayids $=$
\invert{$\delta(\wayconst_{\wayi+1}$, \setwayi$)$}. Se o pacote de dados \pks
não foi alterado, marca-o como aprovado para ser repassado, caso contrário,
marca-o como desaprovado e deve ser descartado. No Trecho de
Código~\ref{algo:verifyPacketAuthenticity}, apresenta-se o procedimento de
verificação de autenticidade de um pacote \pks $\in$ \setpk.

\vspace{0.5cm}

\begin{algorithm}[H]
\label{algo:verifyPacketAuthenticity}
\caption{verifyPacketAuthenticity(\setpk': \textbf{array of} \pac{GMTP-Data})}

\SetAlgoLined
\tcc{\ways executes this function to check if the content of a subset of packets
\setpk' $\subset$ \setpks was modified. It marks each \pks $\in$ \setpk' to be
relayed or discarded. \ways uses the \servs public key to decrypt the \pks
signature and compares it to the hash value of the \pks content. It marks \pks
to be relayed if \pks content was not modified, otherwise it marks \pks to be
discarded, because \pks was modified by a node in \setwayids $=$
\invert{$\delta(\wayconst_{\wayi+1}$, \setwayi$)$}.}

\SetKwFunction{Union}{Union}\SetKwFunction{getPacketFieldValue}{getPacketFieldValue}
\SetKwFunction{Union}{Union}\SetKwFunction{GMTPResponse}{GMTPResponse}
\SetKwFunction{Union}{Union}\SetKwFunction{hash}{hash}
\SetKwFunction{Union}{Union}\SetKwFunction{decrypt}{decrypt}
\SetKwFunction{Union}{Union}\SetKwFunction{destroy}{destroy}

verifiedPackets \attrib \textbf{array of} boolean;

\ForEach{\pks $\in$ \setpk} {
  \textit{signature} \attrib \getPacketFieldValue{\pk, `signature'}\;
  \textit{data} \attrib \getPacketFieldValue{\pk, `data'}\;
  \textit{verifiedPackets[$x$]} \attrib $($\hash{\textit{data}} =
\decrypt{$K^{+}_{\servconst_{\servi}}$, \textit{signature}}$)$\;
}
\Return{\textit{verifiedPackets}}\;

\end{algorithm}
\vspace{0.8cm}


\subsection{Habilitar ou desabilitar o procedimento de segurança}

A função de verificação de autenticidade de um fluxo de dados \setpks do GMTP é
opcional e desabilitada por padrão. Isto porque um sistema de transmissão, em
execução na camada de aplicação, pode ou não desejar tal função. Por isso,
considera-se que apenas o nó \servs tem o controle de habilitar tal
funcionalidade, e este procedimento requer sinalizar os nós \ways para que
estes executem o procedimento de verificação de autenticidade descrito
na Seção~\ref{subsec:verifyPacketAuthenticity}. Para isto, o nó \servs ativa o
da opção assinado (\textit{signed}) disponível no pacote de dados
\pac{GMTP-Register-Reply}, sinalizando que todos os pacotes de dados \pks
$\in$ \setpks conterá a assinatura do conteúdo de dados sendo transportados e
que poderá ser verificado pelos nós \ways $\in$ \setwayi, desde que
\transmitqu{\way} $=$ 1.

Note que quando um nó \clis $\in$ \subsetcli$($\repass$)$ solicitar um fluxo
de dados \setpk, em resposta a tal pedido, o nó \repasss retornará um pacote do
tipo \pac{GMTP-Request-Notify}. No cabeçalho desse pacote, o nó \repasss deve
também ativar a opção assinado (\textit{signed}) para que o nó \clis seja
notificado e entenda que seu nó \repasss realizará a verificação de
autenticidade do fluxo de dados \setpks da forma descrita anteriormente na
Seção~\ref{subsec:verifyPacketAuthenticity}. Este procedimento permitirá que a
aplicação em execução no nó \clis possa informar ao usuário final que tal
funcionalidade está habilitada, por exemplo.

Além disso, como parâmetros de configuração, o usuário administrador do nó
\repasss pode habilitar ou desabilitar a opção de verificação de autenticidade
dos fluxos de dados \setpk, mesmo que o nó \servs possibilite tal verificação,
como descrito anteriormente.

\subsection{Obter a chave pública $K^{+}_{\servconst_{\servi}}$ de \serv}
\label{subsec:obterchavepublica}

Um nó \repasss obtem a chave pública $K^{+}_{\servconst_{\servi}}$ de \servs
através do certificado digital disponível na URI especificada no parâmetro
\textit{f} da descrição da mídia, como ilustrou-se no Trecho de
Código~\ref{algo:sdp-mediadesc}, Linha~\ref{line:sdp-mediadesc:f}, da
Seção~\ref{subsubsec:desc-conteudo}. Isto ocorre após o nó \repasss receber o
pacote \pac{GMTP-Register-Reply}, que confirma o registro de participação ou a
conexão para obter um fluxo de dados \setpk, como apresentou-se no Trecho de
Código~\ref{algo:registerRelay}, Linha X,
Seção~\ref{subsec:registro-participacao}.

Após obter o referido certificado digital do nó \serv, o nó \repasss pode
realizar \textit{cache} de tal conteúdo para que os próximos nós \clis e evitar
ter que obtê-lo a todo instante. De forma alternativa, o usuário administrador
do nó \repasss pode obter o arquivo de certificação digital do nó \repass e
salvá-lo, por meio de \textit{upload}, por exemplo, manualmente nas
configurações do nó \repass. Deve ser opcional também para o usuário
administrador do nó \repasss escolher se tal nó deve ou não realizar
\textit{cache} dos certificados digitais dos nós \serv.

%
% Para evitar esta situação, empregou-se no GMTP um mecanismo para validação do
% conteúdo de \pks antes que o mesmo seja transmitido para os nós \clis $\in$
% \subsetcli(\repass). Esta função é opcional no GMTP e funciona da forma
% apresentada a seguir.
%
% \begin{enumerate}
%  \item
% \end{enumerate}


\section{Outras considerações sobre o GMTP}
\label{sec:outros-aspectos}

Nesta seção, apresentam-se brevemente outras funcionalidades do GMTP, tais como
o procedimento de desconexão, adaptação de fluxo, eleição de nós relatores.

\subsection{Procedimentos para desconexão de nós \cli, \rels e \repass}
\label{subsec:desconexao}

% \begin{figure}[ht]
% \begin{center}
% \includegraphics[natwidth=797,natheight=173,scale=.73]{imgs/bucket-brigade-principle-3.png}
% \end{center}
% \vspace{-0.8cm}
% \caption{Um usuário pode desconectar e é preciso um mecanismo de tolerância à
% desconexão.}
% \label{fig:bucket-brigade-principle-3}
% \end{figure}
%
% \vspace{0.5cm}


O processo de finalização de uma conexão \mudccps ocorre com algumas
diferenças se comparado com outros protocolos orientados à conexão. Para
sinalizar uma desconexão, um nó \clis transmite um pacote do tipo
\pac{GMTP-Close} pelo canal de controle, contendo o nome do fluxo que deseja
se desconectar. Ao receber este tipo de pacote, o nó \repasss transmite ao nó
\clis um pacote do tipo \pac{GMTP-Reset}, sinalizando que está ciente do
fechamento da conexão. Nesse interim, os nós desalocam recursos relacionados à
respectiva conexão. Este procedimento é suficiente para o pedido de finalização
de uma conexão de um cliente \mudccp, porém para finalizar uma conexão de um nó
\rel e \repasss outros procedimentos são necessários.

\subsubsection{Desconexão de um nó \rel}

Como apresentado na Seção~\ref{subsec:mudccp-mcc}, um nó \rels é responsável
por relatar ao nó \repasss as condições de recepção de pacotes \pks $\in$
\setpk em uma transmissão multicast e assim determinar a taxa de transmissão
que deve ser utilizada para repassar o referido fluxo de dados. Sem os nós
\rel, tal procedimento não seria possível. Sendo assim, deve-se realizar um
procedimento para eleger um novo nó \rels quando um nó com tal responsabilidade
solicite desconexão. São candidatos a nó \rels os nós \clis já recebendo
o fluxo de dados \setpk, e o nó \rels em procedimento de desconexão deve
esperar que o procedimento de nova eleição seja concluído. Nesse
interim, o nó \rels em processo de desconexão deve continuar enviando pacotes
do tipo \pac{GMTP-Ack} para o nó \repass.

\subsubsection{Desconexão de um nó \repass}

Um nó \repasss realiza o procedimento de desconexão não por intervenção da
aplicação, mas sim quando \subsetcli(\repass) $= 0$ para um determinado
fluxo de dados \setpk. Neste caso, pode ocorrer uma situação crítica para todos
os nós parceiros \repasssu{q} de \repass, pois teoricamente estes não poderão
mais receber os pacotes de dados \pks $\in$ \setpk. Para evitar um período de
instabilidade na recepção de \setpk por parte dos nós parceiros de \repass,
define-se no GMTP um parâmetro chamado de período de carência para novas
parcerias (\textit{grace period for new partnerships}). Trata-se de um parâmetro
que determina o tempo que um nó \repasss continuará repassando o fluxo de dados
\setpks para seus parceiros.

O valor para o \textit{período de carência para novas parcerias} é transmitido
para os nós parceiros \repasssu{q} de \repass, que por sua vez deve iniciar o
procedimento de realizar outras parcerias a fim de continuar recebendo o fluxo
de dados \setpk. Opcionalmente, um nó \repasss pode aceitar receber de seus nós
parceiros \repasssu{q}, o valor para o período de carência, desde que não
ultrapasse um limite máximo definido pelo administrador de \repass.

\subsection{Eleição de nós \rel}
\label{subsec:electrelsreps}

Para um fluxo de dados \setpk, o primeiro nó \rels será o nó \clis que iniciar a
primeira conexão unicast para obter o referido fluxo. Os seguintes nós \rels
serão os próximos nós \clis que se conectar para receber o fluxo de dados
\setpk, até atingir um parâmetro que determinará a quantidade máxima de nós
\rels por fluxo de dados \setpk. Tal parâmetro pode ser determinado pelo
administrador do nó \repass.

Sendo assim, à medida que um nó \repass recebe pacotes do tipo
\pac{GMTP-Request}, no pacote de resposta \pac{GMTP-Response}, o nó
\repasss ativa um indicador sinalizando que o referido nó \clis em processo de
conexão deverá se comportar como um nó \rel, passando a enviar relatórios
da taxa de transmissão calculada por ele. Note que este modo de transmissão deve
ser implementado com garantia de entrega, ou seja, com a confirmação de recepção
de pacotes e retransmissão caso este tipo de pacote seja perdido. Assim, um nó
\repasss poderá ter controle sobre a quantidade de nós \rels e receber
relatórios apenas dos nós \rels $\in$ \setrel.

Uma outra situação que se faz necessária a eleição de nós \rels é no
procedimento de desconexão, como explicado na Seção~\ref{subsec:desconexao}.
Para esse caso, quando o nó \repasss receber o pacote do tipo
\pac{GMTP-Close}, este deve verificar se o referido nó \clis é um nó \rel. Em
caso afirmativo, o nó \repasss deve transmitir para um dos nós \clis que
também recebe o referido fluxo de dados \setpk (se houver), um pacote do tipo
\pac{GMTP-Elect-Request} e aguardar por um \pac{GMTP-Elect-Response}. Este procedimento
deve ocorrer com garantia de entrega.






% Ao \mudccps foi incorporado um mecanismo de tolerância a desconexão que
% funciona de modo a evitar que os nós clientes deixem de receber dados da
% transmissão em questão, caso um nó relay desconecte repentinamente sem conseguir
% transmitir um pacote do tipo \mudccp-ElectAck, tal como explicado na
% Seção~\ref{subsec:mudccp-desconexao}. Considere $T$ uma variável corresponde a
% $4$ vezes o valor do tempo do RTT. Um nó relay deve transmitir no canal de
% controle um pacote do tipo \mudccp-AdvConn a cada instante de $T$, anunciando
% aos demais nós da rede que está ativo e operando corretamente. Caso um nó relay
% secundário não receba o pacote do tipo \mudccp-AdvConn durante o período de
% tempo $T$, assume-se que o relay atual foi desconectado por algum motivo
% desconhecido e o relay secundário que não recebeu o pacote do tipo
% \mudccp-AdvConn deverá transmitir um pacote do tipo \mudccp-ElectAck. Na
% prática, o nó relay secundário torna-se um nó relay primário do o grupo de
% clientes, incluindo os nós reporters, conectados ao relay que foi desconectado.
% Neste caso, o novo nó relay deve iniciar um novo processo de estabelecimento de
% conexão. Após o estabelecimento dessa conexão, como descritos na
% Seção~\ref{sec:conexaomudccp}, o novo nó relay deve criar o canal de repasse e
% começa a repassar os dados da transmissão multimídia.


% \subsection{Adaptação de Fluxo de Dados}
% \label{subsec:adapt-flow}
%
% \begin{figure}[ht]
% \begin{center}
% \includegraphics[natwidth=794,natheight=170,scale=.73]{imgs/bucket-brigade-principle-2.png}
% \end{center}
% \vspace{-0.8cm}
% \caption{Uma aplicação pode não ter recurso suficiente, adaptações devem ser realizadas.}
% \label{fig:bucket-brigade-principle-2}
% \end{figure}
%
%
% Uma funcionalidade peculiar do \mudccps é sua capacidade de permitir a
% realização de adaptação de fluxos multimídia de forma distribuída. A maioria
% das soluções para transmissão de dados multimídia, além de realizar controle
% de congestionamento no nível de aplicação, realizam adaptação de fluxo
% multimídia na fonte geradora dos dados. Em diversas soluções
% existentes, os autores consideram a transmissão de fluxos de dados multimídia
% adaptados e transmitidos em diferentes canais, sendo que em cada canal
% transmite-se os fluxos multimídia em uma determinada qualidade. Dependendo da
% qualidade desejada pelo nó receptor, o sistema cliente solicita a transmissão em
% um determinado canal. O problema dessa abordagem é que o nó transmissor,
% necessariamente deve transmitir os dados em múltiplos canais, o que aumenta a
% complexidade da aplicação e a quantidade de fluxos de dados sendo transmitidos a
% partir do servidor.
%
% No \mudccp, é possível realizar a adaptação de fluxo de dados de forma
% distribuída, na prática, em cada relay. Por exemplo, considere duas redes
% adjacentes, rede 1 e rede 2. Considere que existe um nó relay na rede 1 e entre
% a rede 1 e o nó transmissor a largura de banda de transmissão disponível seja de
% \ut{100}{Mbps}. Caso a largura de banda disponível na rede 2 seja de no
% máximo \ut{10}{Mbps}, um nó receptor na rede 2 teria que solicitar um fluxo
% multimídia em um canal diferente, considerando as soluções que adotam a
% estratégia de adaptação de fluxo com o uso de múltiplos canais de transmissão.
% No caso do \mudccps é possível que um nó na rede 2 obtenha o fluxo multimídia
% através do relay presente na rede 1, com o relay da rede 1 adaptando o fluxo
% multimídia de acordo com a capacidade do canal de transmissão disponível para a
% rede 2. Desta forma, pode-se diminuir o tráfego na rede do nó transmissor e
% ainda permitir que nós em redes com largura de banda limitada consigam obter o
% fluxo multimídia adaptado (caso mais comum para clientes residenciais).
%
%
%
%
%
%
%
%
%
%
% Com essa estratégia, fica óbvio que quanto mais requisições de
% \textit{pull} por uma parte da mídia, mais urgente é o seu conteúdo para
% reprodução. Muitas requisições via \textit{pulling} é um sinal que a rede não
% está sendo capaz de entregar \pks tão rápido quanto o suficiente para permitir
% a reprodução sem que haja interrupções. Essa informação pode ser utilizada para
% adaptar o fluxo de dados \setpk, reduzindo-se sua qualidade e consequentemente
% exigindo menos da rede.
%
%
%
%
%

% \section{Implemetação e Implantação}
% \label{sec:impl}
%
% PROVER API PARA SETAR AS INFOS DO SDP
%
% O \mudccp\space não necessita explicitamente da instalação de um nó na rede para
% encaminhar o conteúdo de uma rede externa para uma rede interna
% (\textit{proxy}). Além disso, o \mudccp\space mantém a \textit{interface} de
% programação com a camada de aplicação inalterada, apenas adicionando uma
% extensão na API padrão de socket BSD para preservar a compatibilidade
% com as aplicações multimídia existentes e, ao mesmo tempo, permitir que as
% aplicações façam uso dos novos recursos do \mudccp. Esta decisão pode ajudar em
% uma rápida adoção do GMTP nas aplicações multimídia, permitindo-se simples
% alterações das aplicações existentes e, ao mesmo tempo, a efetiva padronização
% da forma como algumas funcionalidades hoje em dia são implementadas.


% \section{Benefícios, Aplicabilidade e Justificativas}
% \label{sec:benef}


%\subsection{Seleção de Parceiros e de \textit{Chunks}}

% \subsection{Balanceamento de Carga}
%
% Um outro aspecto interessante do protocolo \mudccps é sua capacidade em
% permitir divisão de carga entre nós relays. Como os nós relays recebem e
% repassam os fluxos de dados oriundos de um servidor, obtem-se natualmente uma
% solução de distribuição de conteúdo multimídia sem sobrecarregar a fonte
% geradora de dados (geralmente o servidor). Porém, mesmo considerando o
% mecanismo atualmente empregado no \mudccps para divisão de carga entre nós
% relays, atualmente estuda-se um mecanismo complementar de balanceamento de
% carga a fim de evitar que os nós relays entre em colapso de congestionamento
% devido ao grande número de clientes conectados a um determinado nó relay.
%
% Considerando isso, está em estudo no contexto do protocolo \mudccps um
% mecanismo
% de balanceamento de carga que quando um nó relay possui muitas conexões de
% clientes permite-se que outro nó cliente seja... PROBLEMA: UM RELAY POR REDE!


% \subsection{Outra Estratégia para Descoberta de Nós Relays}
% \label{sec:arcdescorels}
%
% Um aspecto primordial do \mudccps é a capacidade de obter fluxos de
% dados multimídia através de nós relays, os quais repassam esses dados vindo de
% uma fonte geradora. No processo de conexão, esses nós relays são encontrados,
% aceitam conexões de clientes e repassam dados da aplicação como se fossem o
% nó servidor. Um gargalo no procedimento padrão adotado no \mudccps é que pode-se
% demorar até que um cliente \mudccps encontre um nó relay e comece a receber o
% fluxo de dados desejado devido ao mecanismo de busca por profundidade por nós
% relays utilizando transmissões multicast, utilizando-se valores incrementais
% para o campo de TTL presente no cabeçalho IP.
%
% Diante disso, está em estudo no contexto desse trabalho um mecanismo alternativo
% para permitir que um nó cliente encontre um nó relay mais rapidamente. Este
% mecanismo consiste em permitir que um nó cliente solicite diretamente ao nó
% servidor a lista de nós relays conectados a ele, ou seja, a lista dos nós
% relays de primeiro nível (Figura~\ref{fig:cenario-global-detailed}).
%
% O mecanismo de busca por nós relays permitirá que o cliente consulte, ao longo
% dos níveis dos nós relays, aquele nó relay que mais se adequa aos requisitos da
% aplicação, principalmente com relação ao atraso observado desde do servidor até
% um determinado relay. Um nó cliente que desejar solicitar esse tipo de
% requisição, utiliza o pacote do tipo \mudccp-RelayQuery e transmite o pedido de
% consulta ao nó servidor, o qual responde ao cliente com a lista dos nós relays
% de primeiro nível utilizando o pacote do tipo \mudccp-RelayReply. Com isto, é
% possível encontrar um melhor relay cujo atraso não ultrapasse um determinado
% limiar de tempo definido pela aplicação, o que não necessariamente será o nó
% relay mais próximo geograficamente do nó cliente.



% , dentre
% outros referenciados em~\cite{REF, REF, REF, REF, REF}.

% discutir aqui sobre o que o protocolo trás de bom para as aplicações
%
% - cloud computing
%
% - transmissão de casa
%
% - vod
%
% - youtube/copa america
%
% - twitcam

% \section{Outros Aspectos Importantes do \mudccp}
%
% \subsubsection{Uso do Campo \textit{Offset} de Dados}
%
% \subsubsection{Uso do Campo \textit{CCVal} de Dados}
%
% \subsubsection{Soma de Verificação e Validação de Pacotes}
%
% \subsection{Compatibilidade com outras recomendação da IETF}
%
% - NAT - http://www.brynosaurus.com/pub/net/p2pnat/
% - 4340
% - GERAÇÃO DO NÚMERO DE SEQUÊNCIA
% - RFC2365
% - RFC4086
% - RFC2119
% - TFMCC 4654
% - 5166
% - TFRC 3448

%\section{Considerações sobre redes de distribuição de conteúdo}

%\section{Considerações sobre a escolha do DCCP como base para o \mudccp}

% \section{Considerações sobre implementação}

\section{Sumário do Capítulo}

Neste capítulo, apresentou-se os fundamentos do \textit{Global Media
Transmission Protocol} (\mudccp), um protocolo de transporte e rede baseado em
uma arquitetura híbrida P2P/CDN para distribuição de fluxos de dados multimídia
ao vivo. Tal arquitetura é caracterizadas por um conjunto de nós servidores que
obtém o conteúdo multimídia da fonte geradora e o transmite para muitos nós
receptores (\mys). O GMTP foi proposto para operar principalmente na Internet,
permitindo a transmissão de pacotes de dados com suporte a controle de
congestionamento sem garantia de entrega, tudo ocorrendo de forma transparente
para a aplicação. O GMTP opera na camada de transporte e rede da pilha de
protocolos GMTP, realizando transmissão em modo multicast ou de múltiplos fluxos
unicast compartilhados entre os nós participantes da transmissão. Neste segundo
caso, tal ação ocorre através de uma rede de favores constituída dinamicamente
entre os roteadores da rede, evitando a relação de uma conexão por cliente ao nó
servidor.

Ao contrário de todos os outro protocolos de transporte e das soluções de
aplicação para redes P2P, o foco de definição do GMTP foi reduzir
responsabilidade dos nós clientes e aumentar a responsabilidade dos roteadores
de rede no processo para distribuição de um determinado conteúdo multimídia.
Este foco teve como principal motivação a proposta das Redes Centradas no
Conteúdo (CCN), onde o roteador passa a ter um papel com maior participação no
processo de entrega de um conteúdo para os nós interessados. Com vistas nos
aspectos da CCN, o GMTP oferece um mecanismo de conexão separado em duas fases,
quando se decide a forma como um determinado nó cliente obterá o conteúdo de
interesse, contando com o suporte dos roteadores nesse processo. Nesse interim,
uma grande peculiridade do GMTP é a função que os nós roteadores
passam a ter de realizar parcerias entre si a fim de obter um determinado
conteúdo multimídia de interesse, identificado por um nome, como especificado
pela teoria das redes centradas no conteúdo.

Diversas estratégias adotadas no GMTP e apresentadas neste capítulo discutidas
são diferenciais que permitem a disseminação mais rapidamente de um determinado
fluxo de dados originado em um nó servidor. Incorporou-se um mecanismo de
\textit{registro de participação} que, após um nó repassador se registrar em um
nó servidor, permite-se que os servidores determinem quais são os candidatos a
parceiros de um nó repassador, o que ocorre periodicamente. A vantagem é que,
\textit{a priori}, permite-se que os nós repassadores avaliem seus parceiros sem
necessariamente um nó estar recebendo um fluxo de dados de um determinado
evento. Com isto, um nó repassador pode repassar um fluxo de dados para um outro
nó repassador sem que o primeiro tenha interesse no referido fluxo, mas devido
ao seu posicionamento na rede e sua capacidade computacional e de vazão, pode
melhorar o processo de disseminação de um determinado fluxo de dados. Além
disso, como se trata de uma rede de favores e os dados são trocados de forma
distribuída, ou seja, nem sempre com a participação de um nó servidor, pode-se
empregar um mecanismo para validação dos dados transmitidos pelo servidor,
evitando-se ataques de poluição, por exemplo.

Um aspecto importante do GMTP são seus dois algoritmos para controle de
congestionamento de fluxos de dados sem garantia de entrega, o \mudccp-UCC e o
\mudccp-MCC. No primeiro, a ser aplicado na transmissão de fluxos de dados
unicast entre os nós roteadores, emprega-se uma solução para controle de
congestionamento assistido pela rede, onde oferta-se para cada fluxo de dados
uma taxa de transmissão igual para todos os fluxos passando por todos os
roteadores de um caminho. Nesse caso, a taxa de transmissão é determinada de
acordo com a capacidade de transmissão do menor roteador em uma determinada
rota. Já no segundo algorimo, a ser aplicado em fluxos de dados multicast,
utiliza-se um algoritmo de controle de congestionamento baseado na equação TFRC
(\textit{TCP Friend Rate Control}), fazendo-se uso de nós especiais chamados de
relatores para determinar a próxima taxa de transmissão que o roteador deverá
utilizar para distribuir o conteúdo multimídia para os nós clientes diretamente
conectados a ele.

Por fim, discutiu-se sobre outras funcionalidades do protocolo \mudccp, tais
como seu mecanismo para finalização de conexão dos tipos de nós do GMTP, eleição
de nós relatores e considerações sobre segurança. No próximo capítulo,
apresentam-se os resultados e discussões acerca do uso do protocolo GMTP para a
distribuição de conteúdos multimídia ao vivo.