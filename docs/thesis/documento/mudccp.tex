\chapter{Global Media Transmission Protocol (\mudccp)}
\label{cap:mudccp}

O \textit{Global Media Transmission Protocol} (\mudccp) atua nas camadas de transporte e de rede (\textit{cross-layer}) da pilha TCP/IP, projetado para operar na Internet em sistemas de distribuição de mídias ao vivo. Trata-se de um protocolo baseado em uma arquitetura de rede híbrida P2P/CDN, através da qual se transmitem pacotes de dados de um ou mais sistemas. Para isto, constituem-se redes de favores formadas por roteadores de rede, que cooperam entre si a fim de entregarem o conteúdo multimídia de interesse comum aos seus clientes. Nesse cenário, os servidores atuam como super nós para os nós da rede P2P, auxiliando-os no envio e recebimento dos fluxos de dados. Uma aplicação cliente reproduz o conteúdo multimídia ao usuário final à medida que recebe pacotes de dados contendo partes da mídia, geradas por um ou mais servidores. Os clientes não, necessariamente, recebem os pacotes de dados diretamente dos servidores, mas podem recebê-los de roteadores já envolvidos na transmissão da mídia. Nesse contexto, os servidores instruem os roteadores a efetivarem as parcerias com outros roteadores que possuem clientes também interessados no mesmo conteúdo multimídia, o que ocorre com base no conhecimento sobre as rotas já utilizadas para disseminar a referida mídia.

As trocas de dados entre os nós GMTP ocorrem por meio do envio e recebimento de partes de uma mídia (\textit{chunks}), transmitidas por diferentes nós da rede. Os roteadores GMTP transmitem os fluxos de dados para outros roteadores em modo \textit{unicast}, ao passo que distribuem os pacotes de dados a seus clientes em modo \textit{multicast}, caracterizando um modo de transmissão \textit{multi-unicast}. Em ambos os modos de transmissão, o GMTP realiza controle de congestionamento em transmissões sem garantia de entrega e a escolha do modo de transmissão para disseminar um fluxo de dados ocorre sem a influência da aplicação. Nesse contexto, a aplicação precisa simplesmente ``sintonizar'' sua conexão em um determinado canal \textit{multicast} configurado automaticamente pelo roteador, de acordo com a demanda de seus clientes. Tal abstração para a camada de aplicação ocorre de modo que os processos em execução utilizam o GMTP através de uma API compatível com as especificações de \textit{socket} BSD e POSIX, facilitando-se seu uso nos atuais e futuros sistemas, onde os clientes se tornam compatíveis para reproduzir um conteúdo independente do servidor que o transmite, tal como acontece no serviço Web.

Com o uso do GMTP, a estratégia é permitir o estabelecimento de conexões e a cooperação entre diferentes fornecedores de aplicações, obtendo-se os \textit{chunks} a serem reproduzidos nos sistemas finais tão logo quanto possível. Isto significa que o GMTP torna as aplicações interoperáveis, mesmo entre diferentes fornecedores, uma vez que o protocolo desacopla a forma como se transportam os dados da aplicação da forma como se deve exibi-los aos usuários finais (uma decisão meramente de aplicação). Sendo assim, promove-se a integração do GMTP em aplicações existentes, quando se consideram futuras adoções de tal protocolo, ao passo que se permite a utilização dos novos recursos introduzidos no protocolo, reduzindo-se a complexidade na construção de sistemas de distribuição de mídias ao vivo, especialmente aqueles baseados em arquitetura P2P/CDN.

Com base na ilustração da Figura~\ref{fig:blocos-funcionais}, nas próximas seções deste capítulo, detalham-se os aspectos teóricos e computacionais empregados no GMTP, a fim de construir uma rede de favores formada por roteadores, pela execução de quatro grandes etapas:

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=.5]{imgs/blocos-funcionais.pdf}
\end{center}
\vspace{-0.8cm}
\caption{Blocos funcionais do GMTP e as relações com a pilha de protocolos
TCP/IP.}
\label{fig:blocos-funcionais}
\end{figure}

\begin{enumerate}

  \item \textit{Constituição da rede de favores:} descobrir, definir, efetivar e desfazer parcerias entre os roteadores de acordo com o evento ao vivo a ser transmitido.

  \item \textit{Distribuição de fluxos de dados através de uma camada de \textit{socket}:} conectar os clientes interessados em receber um fluxo de dados de um evento ao vivo, bem como transmitir tal fluxo de dados através da rede de favores constituída no Passo 1.

  \item \textit{Controle de congestionamento:} controlar a taxa de transmissão dos fluxos de dados distribuídos e utilizar as informações sobre a capacidade de transmissão de um canal para sugerir favores entre roteadores.

  \item \textit{Autenticidade do conteúdo:} verificar a autenticidade do fluxo de dados antes de repassá-los aos clientes, evitando-se ataques de poluição.

\end{enumerate}

Com base nessas etapas, organizou-se a estrutura deste capítulo da seguinte forma:

\begin{itemize}

  \item Na Seção~\ref{sec:visaogeral}, apresenta-se uma visão geral do protocolo, como cenário de atuação, arquitetura, canais de comunicação e tipos de nós e pacotes.

  \item Na Seção~\ref{sec:defsrests}, formalizam-se as definições e restrições do protocolo.

  \item Na Seção~\ref{sec:connformnet}, descrevem-se os aspectos de conexão multi-ponto através da introdução de conceitos como \textit{sockets} P2P, o processo de constituição da rede de favores, o registro de participação de um nó e a seleção de nós parceiros.

  \item Na Seção~\ref{sec:asptransrecep}, discutem-se os aspectos de transmissão e recepção de fluxos de dados, relacionando o algoritmo de compartilhamento dados às estratégias de disponibilização e obtenção das partes de uma mídia.

  \item Na Seção~\ref{sec:ccgmtp}, apresentam-se detalhes de funcionamento dos algoritmos de controle de congestionamento utilizados no GMTP; as influências de tais algoritmos no processo de formação de parcerias; e discussões sobre a escolha do RCP em detrimento ao XCP, o qual foi adaptado para suportar o conceito de sub-fluxo.

  \item Na Seção~\ref{sec:seguranca}, discutem-se os aspectos relacionados à autenticidade de um fluxo de dados.

  \item Na Seção~\ref{sec:outros-aspectos}, apresentam-se outros aspectos relacionados ao GMTP, tais como finalização de conexão, tolerância à desconexão e eleição de relatores para o funcionamento do algoritmo de controle de congestionamento \textit{multicast}.

  \item E, por fim, na Seção~\ref{sec:sumario-gmtp}, apresenta-se o sumário deste capítulo, elencando-se brevemente os principais pontos discutidos.

\end{itemize}

\section{Visão Geral}
\label{sec:visaogeral}

O protocolo GMTP é composto por dois módulos chamados de \textit{GMTP-Intra} e \textit{GMTP-Inter}, que operam na camada de transporte e de rede, respectivamente, definindo assim sua arquitetura, ilustrada na
Figura~\ref{fig:arq_geral_gmtp}.

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=.8]{imgs/protocolo-arquitetura.pdf}
\end{center}
\vspace{-1cm}
\caption{Arquitetura do Protocolo \mudccp.}
\label{fig:arq_geral_gmtp}
\end{figure}

As responsabilidades dos módulos GMTP-Intra e GMTP-Inter são:

\begin{itemize}

  \item \textbf{GMTP-Intra:} fornecer serviços às aplicações de rede a fim de abstrair a complexidade na execução de tarefas comuns a qualquer sistema final, tais como conexão multi-ponto, multiplexação/demultiplexação de segmentos IP entre as camadas de transporte/rede/aplicação e controle de congestionamento. Este módulo compreende a instância do GMTP em execução no sistema operacional do cliente, acessível através de uma API de \textit{socket} GMTP. Nesse contexto, um \textit{socket} é a representação de uma instância do protocolo GMTP em execução, sendo responsável por gerenciar todas as atividades de comunicação da aplicação correspondentes ao meio externo (outros processos GMTP). No contexto de uma conexão, o GMTP-Intra mantém diversas variáveis de estado relacionadas à execução dos algoritmos, para gerenciamento de conexão (estabelecimento e desconexão), controle de congestionamento \textit{multicast}, multiplexação e demultiplexação de datagramas, eleição de relatores e determinação do formato e preenchimento dos parâmetros que definem uma mídia, permitindo-se que a aplicação defina os valores de tais parâmetros ou obtenha acesso aos seus valores.

  \item \textbf{GMTP-Inter:} constituir redes de favores P2P compostas por roteadores, os quais funcionam como pontes de acesso aos servidores de uma rede CDN. Trata-se do módulo em execução nos roteadores, que cooperam entre si a fim de constituírem as redes de favores, com base no interesse comum de um determinado conteúdo, aceitando conexões originadas por seus clientes, bem como instruções dos servidores sobre formar parcerias com outros roteadores a fim de disseminar um determinado conteúdo. No contexto de uma conexão, o GMTP-Inter mantém variáveis de estado relacionadas às funções de sua responsabilidade, tais como estabelecimento de conexão com servidores ou entre roteadores; seleção e gerenciamento de roteadores parceiros; eleição de relatores; compartilhamento de fluxos multimídia; e controle de congestionamento assistido pela rede. Além disso, permite-se a definição de parâmetros iniciais de configuração da rede de favores e da integração com servidores de uma ou mais CDNs, como ilustra-se na Figura~\ref{fig:tela-gmtp-inter}. Nesse caso, o usuário administrador de um roteador pode definir os seguintes parâmetros:

\begin{itemize}

  \item configurações sobre registro de participação em uma ou mais redes CDNs;

  \item largura de banda máxima (\textit{download} e \textit{upload}) que o roteador está autorizado à compartilhar;

  \item o período que o roteador está autorizado a participar das redes de favores, em dias e horários;

  \item quantidade máxima de parcerias que podem ser realizadas e quantidade máxima de fluxos de dados que podem ser compartilhados;

  \item parâmetros das equações utilizadas para executar os algoritmos de controle de congestionamento; e

  \item tamanho máximo do \textit{cache} de mídia a ser compartilhado;

  \item configurações acerca dos certificados digitais disponibilizados pelos servidores, tais como \textit{download} automático e realização de \textit{cache}.

\end{itemize}

\begin{figure}[ht]
\begin{center}
\includegraphics[natwidth=664,natheight=340,scale=.5]{imgs/tela-gmtp-inter.png}
\end{center}
\vspace{-.5cm}
\caption{Tela da ferramenta de administração da distribuição Linux OpenWRT com
suporte ao GMTP. Nessa tela, permite-se que o administrador do roteador configure
parâmetros do módulo GMTP-Inter.}
\label{fig:tela-gmtp-inter}
\end{figure}

\end{itemize}

Para viabilizar a disseminação de conteúdos multimídia, cada nó roteador, localizado no caminho entre o servidor da mídia e o cliente interessado em obtê-la, pode repassar os pacotes de dados para seus clientes de acesso direto (um salto) e replicá-los para outros roteadores interessados em recebê-los, motivados pelos interesses de seus respectivos clientes. Sendo assim, permite-se que um roteador atenda à demanda dos seus clientes locais, ao passo que ajuda os outros roteadores a fazerem o mesmo, evitando-se múltiplas conexões ao servidor.

% \vspace{0.2cm}
%
% \begin{figure}[ht]
% \begin{center}
% \includegraphics[natwidth=706,natheight=152,scale=.71]{imgs/bucket-brigade-principle-1.png}
% \end{center}
% \vspace{-0.8cm}
% \caption{Analogia do Princípio da Cooperação de Brigadas utilizado no \mudccps
% para distribuição de conteúdos multimídia ao vivo.}
% \label{fig:bucket-brigade-principle-1}
% \end{figure}

Em um contexto geral, como ilustra-se na Figura~\ref{fig:protocolo-tipos-nos}, definem-se os seguintes tipos de nós GMTP:

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=.6]{imgs/protocolo-tipos-nos.pdf}
\end{center}
\vspace{-1cm}
\caption{Tipos de nós e modos de conexões do GMTP.}
\label{fig:protocolo-tipos-nos}
\end{figure}

\begin{itemize}

%   \item \textbf{Nó GMTP ou Processador GMTP:} qualquer processador de rede que
% implementa o protocolo GMTP. É um sistema computacional que implementa parte ou
% todo o protocolo GMTP, sendo capaz de interpretar os cabeçalhos dos pacotes
% definidos pelo GMTP e realizar ações pré-definidas. Não há restrições de qual
% tipo de processador de rede pode implementar qual(is) parte(s) do GMTP.

  \item \textit{Cliente GMTP:} é capaz de reproduzir e gerar conteúdos multimídia ao vivo. Em geral, um \textit{Cliente GMTP} é um sistema final que executa um processo em nível de sistema operacional, representando uma aplicação manipulada pelo usuário final. Um \textit{Cliente GMTP} recebe os pacotes de dados e os entrega ao processo de aplicação em execução, sendo que alguns destes clientes, chamados de \textit{Relatores GMTP}, auxiliam na execução do algoritmo de controle de congestionamento em transmissões \textit{multicast}, como descreve-se a seguir.

  \item \textit{Relator GMTP:} é um \textit{Cliente GMTP} com habilidades de enviar relatórios periódicos ao nó \textit{Repassador GMTP} sobre o estado da transmissão.

  \item \textit{Repassador GMTP:} roteadores que participam efetivamente da rede de favores, com a responsabilidade de repassar os fluxos de dados originados em um ou mais \textit{Servidores GMTP} para outros  \textit{Repassadores GMTP} até que os pacotes de dados alcancem os \textit{Clientes GMTP}.

  \item \textit{Servidor GMTP:} é um sistema final que participa de uma rede CDN e obtém a mídia a ser transmitida através de três formas: i) diretamente a partir de uma unidade geradora de conteúdo (filmadora e/ou microfone); ii) a partir de um \textit{Cliente GMTP}; e/ou iii) a partir de outro \textit{Servidor GMTP} (troca de dados entre os servidores da CDN). Os \textit{Servidores GMTP} recebem sinalizações de controle contendo requisições dos \textit{Repassadores GMTP} que, ao receberem uma resposta correspondente à sua requisição, atendem à demanda de um ou mais \textit{Clientes GMTP}.

\end{itemize}

Deste ponto em diante, os termos \textit{Cliente GMTP}, \textit{Servidor GMTP}, \textit{Repassador GMTP} e \textit{Relator GMTP} serão utilizados em sua forma simplificada, ou seja, \textit{cliente}, \textit{servidor}, \textit{repassador} e \textit{relator}, respectivamente. Quando o termo \textit{transmissão} ou \textit{transmissão de um evento ao vivo} for mencionado, denotar-se-á a transmissão de um fluxo de datagramas IP correspondente a um evento ao vivo com o uso do protocolo GMTP. Embora alguns autores considerem os termos \aspas{repasse} e \aspas{roteamento} como conceitos distintos, neste trabalho ambos os termos são considerados sinônimos e devem ser interpretados como a capacidade que um nó \mudccps tem de receber dados em uma interface de rede de entrada e encaminhar estes dados através de uma ou mais interfaces de rede de saída, ao mesmo tempo, permitindo-se que uma mesma interface de rede seja utilizada como entrada e saída ao mesmo tempo. Ademais, nas seções subsequentes, as palavras \aspas{deve}, \aspas{não deve}, \aspas{requerido}, \aspas{pode}, \aspas{não pode}, \aspas{recomendado} e \aspas{opcional}, incluindo suas variações morfológicas, devem ser interpretadas como descrito na RFC 2119~\cite{RFC2119}.

% \begin{figure}[ht]
% \begin{center}
% \includegraphics[scale=.65]{imgs/cenario-global.pdf}
% \end{center}
% \vspace{-1cm}
% \caption{Cenário global de atuação do \mudccp.}
% \label{fig:cenario-global}
% \end{figure}

\subsubsection{Fluxo básico de comunicação}

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=.6]{imgs/cenario-global-detailed.pdf}
\end{center}
\vspace{-.5cm}
\caption[Rede de sobreposição construída pelo \mudccp]{Rede de sobreposição construída dinamicamente pelo \mudccps com a presença de repassadores e relatores.}
\label{fig:cenario-global-detailed}
\end{figure}

Com base na Figura~\ref{fig:protocolo-tipos-nos}, observa-se o cenário geral de atuação do protocolo \mudccp, onde ilustram-se os clientes interessados em obter o conteúdo de um determinado evento ao vivo. Neste caso, observa-se também um servidor, que está conectado a uma rede CDN e atua como fonte geradora de dados, ao passo que os clientes se conectam aos repassadores. Note que as transmissões entre os repassadores ocorrem em modo \textit{unicast}, o que evita o uso e limitações existentes em protocolos \textit{multicast} tradicionais, como o \textit{Internet Group Management Protocol} -- (IGMP)~\cite{RFC3376,RFC4605}.

% IGMP proxy limitations
% IGMP Proxy cannot be enabled on the same interface on which PIM SM or PIM DM is enabled.
% IGMP Proxy is only supported in a PIM Dense environment where there are IGMP clients connected to the Brocade device. The Brocade device does not send IGMP reports on an IGMP proxy interface for remote clients connected to a PIM neighbor,because it is not aware of groups that the remote clients are interested in. Static groups on the other PIM interfaces are included in proxy reports.
% PIM DM must be enabled in passive mode. This is a change from the previous implementation; to be backward compatible, PIM-DM passive mode is enabled in passive mode indirectly if PIM-DM is not enabled explicitly.

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=.515]{imgs/gmtp-fluxograma.pdf}
\end{center}
\vspace{-0.5cm}
\caption{Fluxograma geral do GMTP, desde a solicitação do cliente por uma mídia ao vivo até receber uma resposta, executando-se ações importantes como registro de participação, controle de congestionamento, eleição de relatores e verificação de autenticidade dos dados.}
\label{fig:gmtp-fluxograma}
\end{figure}

Como ilustra-se no fluxograma da Figura~\ref{fig:gmtp-fluxograma}, o fluxo de comunicação do GMTP ocorre quando um cliente deseja reproduzir um conteúdo multimídia. Inicia-se a comunicação com um cliente enviando uma requisição em direção ao servidor que está transmitindo o conteúdo multimídia de interesse, como atualmente acontece em qualquer conexão na Internet. Em seguida, um repassador intercepta a requisição durante seu trajeto até o servidor, que é capaz de determinar os melhores parceiros para atendê-la. Em geral, isto ocorre já no roteador de borda do cliente, que funciona como repassador de origem, em um procedimento chamado de registro de participação (Passo 1 do fluxograma da Figura~\ref{fig:gmtp-fluxograma}). Caso o repassador não encontre nenhum repassador parceiro capaz de transmitir a mídia de interesse, a mensagem de requisição alcança o servidor que transmite a mídia correspondente, já que o pedido de conexão é intencionalmente endereçado a este. Em seguida, o servidor decide se aceita o pedido de conexão ou se delega tal requisição a um repassador, com base no conhecimento de quais repassadores já estão encaminhando o conteúdo de interessado para alguma rede. No primeiro caso, o servidor simplesmente responde ao cliente e inicia a transmissão do fluxo de dados correspondente, o que resulta em conhecer a nova rota utilizada para transmitir o conteúdo, definida pelos roteadores existentes do servidor até ao cliente, nessa direção e ordem (Passo 2). No segundo caso, em vez de aceitar uma nova conexão, o servidor a recusa e determina que um repassador comece a servir o repassador (de origem) do cliente, determinando-se uma parceria entre um repassador já em uso para disseminar o conteúdo de interesse e o repassador que solicitou o registro de participação (Passo 3). Em ambos os casos, sempre o repassador de origem assumirá o controle de uma requisição do cliente, habilitando-se como candidato a parceiro para outros repassadores, quando motivados por requisições originadas pelos seus respectivos clientes. Nesse ínterim, outros passos são executados, como distribuição dos pacotes de dados nas redes locais e verificação da autenticidade do conteúdo no momento do repasse (Passo 4). Especificamente, a verificação da autenticidade se baseia na assinatura digital dos dados transportados nos pacotes e na capacidade que os repassadores têm de validar se o conteúdo foi intencionalmente alterado por usuários maliciosos no trajeto até o cliente, com base no certificado digital emitido pelo servidor -- esta ação é opcional e decidida pela aplicação no início da transmissão.

Por fim, nos Passos 5 e 6, executam-se os algoritmos de controle de congestionamento. No Passo 5, executa-se um algoritmo de controle de congestionamento em cada repassador, que calcula sua capacidade de transmissão atual com base apenas no tamanho da fila de repasse e no atraso fim-a-fim marcado em pacote de dados a ser roteado. Em seguida, o repassador compara sua capacidade de transmissão com a menor capacidade de transmissão de todos os repassadores anteriores, transportada em cada pacote de dados. Se sua capacidade de transmissão for menor que a capacidade de transmissão informada no pacote de dados, o repassador o altera informando sua capacidade de transmissão, caso contrário, transmite-o para o próximo repassador. Ao final desse processo, o servidor regulará sua taxa de transmissão com base no repassador com menor capacidade de transmissão, informação contida nos pacotes de dados transmitidos ao servidor. Essa estratégia foi baseada no protocolo RCP~\cite{Dukkipati:2008:RCP:1368746}, porém adaptada no GMTP para suportar o conceito de sub-fluxos, discutido  mais adiante neste capítulo. O importante é que além de regular sua taxa de transmissão, o servidor também sugere que os repassadores realizem parcerias entre si com base na capacidade de transmissão de cada repassador, propondo-se portanto um mecanismo explícito de seleção de nós com base na capacidade de transmissão das rotas utilizadas para distribuir o conteúdo. Já no Passo 6, executa-se um algoritmo de controle de congestionamento adaptado do \textit{TCP-Friendly Rate Control} (TFRC)~\cite{CONG:Floyd00:TFRC:art} para fluxo de dados \textit{multicast}, regulando-se a taxa de transmissão na rede local com base nos relatórios transmitidos pelos relatores.

O posicionamento dos repassadores e suas habilidades permitem a redução do número de fluxos de dados na rede correspondentes a um mesmo evento, ao tempo que maximiza a quantidade de clientes interessados em receber o mesmo fluxo (escalabilidade). Por este mesmo motivo, o protocolo GMTP é flexível para permitir que um repassador atue somente encaminhando conteúdos multimídia entre duas ou mais redes distintas, mesmo que este não tenha demandas explícitas dos seus clientes por tal conteúdo. Desta forma, maximiza-se o uso dos canais de transmissão ociosos, em particular das redes residenciais, principalmente quando seus usuários estão ausentes e portanto sem fazer uso dos recursos disponíveis de rede. Isto pode ocorrer sem a necessidade de manter um determinado computador ligado e conectado à rede, bastando apenas manter o roteador ligado, diferentemente de outras soluções existentes baseadas em arquitetura P2P ou P2P/CDN, que requer pelo menos um cliente em execução e registrado pela aplicação.

As requisições de conexão podem ser originadas não apenas por clientes para seu respectivo repassador, mas também estas podem ocorrer entre repassadores que, motivados pelos interesses dos seus clientes, formam parcerias entre si. Isto significa que um repassador pode agir como se fosse um servidor, respondendo às requisições originadas por seus clientes ou por outros repassadores, reduzindo o número de conexões nos servidores.

\subsection{Resumo das principais características}

Com base nos processos macros do fluxograma ilustrado na Figura~\ref{fig:gmtp-fluxograma}, especialmente os enumerados de 1 a 6, a seguir, apresentam-se as principais características do GMTP, as quais serão detalhadas nas seções subsequentes deste capítulo.

\begin{enumerate}

  \item Constituição de redes de favores entre roteadores, transparente para a aplicação. Nesse contexto, realiza-se o Registro de participação de um repassador em um servidor. Isto permite que um repassador sinalize interesse em participar de uma rede CDN. Assim, pode-se pré-selecionar nós parceiros filtrados por métricas que influenciam na qualidade de serviço oferecida aos sistemas finais. Estes assuntos serão retomados na Seção~\ref{sec:connformnet}.

  \item Envio e recebimento de fluxos de dados compartilhados entre nós da mesma rede através do uso do modo de transmissão \textit{multicast}, sendo o modo de transmissão \textit{unicast} restrito apenas para transportar os fluxos de dados entre redes distintas, evitando-se a relação de uma conexão por cliente ao servidor. O acesso a uma transmissão de um evento ao vivo ocorre através de um processo de conexão em três-vias (\textit{3WHS}), com a requisição de conexão transmitida ao servidor e podendo ser interceptada por um repassador em seu trajeto até o servidor. Estes assuntos serão retomados na Seção~\ref{sec:asptransrecep}.

  \item Controle de congestionamento para transmissões \textit{unicast} com base na menor largura de banda de um roteador em uma rota entre o cliente e o servidor (GMTP-UCC); e Controle de Congestionamento para transmissões \textit{multicast} com base em relatórios transmitidos pelos clientes (GMTP-MCC). Estes assuntos serão retomados na Seção~\ref{sec:ccgmtp}.

  \item Descoberta de nós parceiros entre redes distintas e negociação de parcerias, com suporte à formação de parcerias baseadas em métricas de rede, tal como a capacidade de transmissão fim-a-fim. Além disso, permite-se distribuir um fluxo de dados em múltiplas taxas de transmissão de acordo com a largura de banda dos repassadores. Para isto, o GMTP segmenta os canais de transmissão (rota entre um servidor e os repassadores) quando existem múltiplos repassadores em uma determinada rota e estes estão interessados em receber o mesmo fluxo de dados. Estes assuntos serão retomados nas Seções~\ref{sec:connformnet} e~\ref{sec:ccgmtp}.

  \item Verificação de autenticidade dos dados multimídia, por meio do uso de assinaturas digitais disponibilizadas pelos servidores, impedindo assim ataques de poluição de conteúdo. Este assunto será retomado na Seção~\ref{sec:seguranca}.

  \item Suporte a funções auxiliares, como eleição de relatores e tolerância à desconexões de nós. Estes assuntos serão retomados na Seção~\ref{sec:outros-aspectos}.

\end{enumerate}


\subsection{Cabeçalho geral e tipos de pacotes}
\label{subsec:tipodepacotesmudccp}

Toda comunicação entre dois ou mais nós GMTP ocorre através da troca de datagramas IP, os quais carregam sinalizações de controle e/ou dados da aplicação. É muito importante entender os conceitos básicos de cada campo do cabeçalho, a fim de compreender os algoritmos empregados no GMTP. Para adoção na Internet, será necessário registrar junto à \textit{Internet Assigned Numbers Authority} -- IANA\footnote{IANA: http://www.iana.org/} o uso de um código para o campo \textit{Protocolo} do cabeçalho IP referente ao GMTP. Atualmente, está sendo discutida a alocação do código 100 para o GMTP, como pode-se constatar no documento \textit{Protocol Numbers} da IANA, disponível em \murl{http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml}.

O cabeçalho do GMTP foi organizado estrategicamente em uma parte fixa e em uma parte variável. A parte fixa é definida em \ut{32}{Bytes}, como ilustra-se na Figura~\ref{fig:gmtp-fixed-header}.

\begin{figure}[b!ht]
\begin{center}
\includegraphics[scale=.45]{imgs/gmtp-fixed-header.pdf}
\end{center}
\vspace{-1cm}
\caption{Porção fixa do cabeçalho de pacotes GMTP.}
\label{fig:gmtp-fixed-header}
\end{figure}

A distribuição ocorre da seguinte forma: \ut{3}{bits} para a \textit{Versão do Protocolo}, \ut{5}{bits} para o \textit{Tipo de Pacote}, \ut{11}{bits} para o \textit{Tamanho do Cabeçalho}, \ut{8}{bits} para o \textit{RTT no Servidor}, \ut{1}{bit} para o campo P (\textit{Pull}), \ut{1}{bit} para o campo R (\textit{Relay}), \ut{3}{bits} reservados para uso futuro, \ut{16}{bits} para o \textit{Número da Porta de Origem}, \ut{16}{bits} para o \textit{Número da Porta de Destino}, \ut{32}{bits} para os \textit{Números de Sequência}, \ut{32}{bits} para a \textit{Taxa Proposta de Transmissão} e \ut{128}{bits} para o \textit{Nome do Fluxo de Dados}. É importante entender que os campos \textit{RTT no servidor} e \textit{taxa de transmissão} estão relacionados com o mecanismo de controle de congestionamento adotado no GMTP, ao passo que o campo \textit{Nome do Fluxo de Dados} é uma forma de identificar unicamente a transmissão de um evento ao vivo e, com base nessa informação, formam-se as redes de favores entre os repassadores.

Apesar de parecer uma ordenação simples e aleatória, sem qualquer pretensão além do aspecto organizacional, tanto a ordem quanto o tamanho de cada campo da porção fixa do cabeçalho GMTP foram definidos criteriosamente para i) permitir manutenção (adição, atualização e remoção) das funcionalidades existentes; ii) flexibilizar o uso do protocolo por diferentes tipos de aplicação multimídia e iii) otimizar a leitura e escrita dos campos de cada pacote, buscando-se reduzir o atraso nodal. Por exemplo, o campo \textit{versão} permite uma implantação gradativa do protocolo GMTP, bem como atualizações para novas versões sem, impactar diretamente no funcionamento das versões existentes. Por isso, é importante que o próximo campo seja o \textit{tipo do pacote}, pois dependendo do seu valor, um nó interpretará o restante do cabeçalho (parte variável) de forma diferente. Já o campo \textit{Tamanho do Cabeçalho} ainda favorece a flexibilidade da parte variável do cabeçalho e seu espaço de \ut{11}{bits} permite informar um cabeçalho com tamanho total de \ut{2047}{Bytes}.

A estratégia de usar cabeçalho de tamanho variável é flexibilizar as funções do protocolo e transportar dados de controle apenas quando estritamente necessário. Por exemplo, no GMTP permite-se que uma aplicação injete informações na porção variável do cabeçalho para que sejam lidas pelos repassadores localizados entre os sistemas finais. Um exemplo disso é que um servidor pode sinalizar a um repassador que realize parcerias com outros repassadores que já estejam distribuindo um determinado conteúdo. Um outro exemplo é no processo de conexão do GMTP, onde cada repassador no caminho entre o cliente e o servidor adiciona seu identificador no cabeçalho de um pacote GMTP, o que permite aos servidores conhecerem os caminhos sendo utilizados para distribuir a mídia até seus clientes. Conhecendo-se os caminhos pode-se sugerir parcerias de melhor qualidade.

O campo \emph{tipo do pacote} determina quais informações serão encapsuladas em cada tipo de pacote para, posteriormente, serem consumidas pelos nós da rede (clientes, servidores, repassadores e relatores), a fim de executarem as ações definidas no protocolo GMTP e disseminarem os pacotes de dados de um fluxo. Essas ações foram traduzidas em algoritmos, os quais serão detalhados ao longo deste capítulo. Sendo assim, para finalizar este assunto sobre cabeçalho GMTP, a seguir, apresentam-se brevemente os tipos de pacote utilizados no GMTP.

\begin{enumerate}
\setcounter{enumi}{-1}

  \item \textit{GMTP-Request:} o cliente envia requisição para obter um fluxo de dados multimídia, com base no nome do fluxo de interesse;

  \item \textit{GMTP-RequestNotify:} o repassador notifica um cliente que um fluxo de dados está prestes a ser transmitido ou já está sendo transmitido em um determinado canal de repasse \textit{multicast}. O campo de dados desse tipo de pacote contém a descrição da mídia a ser reproduzida;

  \item \pac{GMTP-Response:} o repassador confirma o estabelecimento de uma parceria com outro repassador, dado um determinado fluxo de dados;

  \item \pac{GMTP-Register:} o repassador registra participação no servidor para funcionar como distribuidor de um fluxo de dados;

  \item \pac{GMTP-Register-Reply:} o servidor responde sobre o pedido de registro de participação enviado por um repassador. Além disso, transporta o identificador de todos os repassadores entre o servidor e o cliente;

  \item \pac{GMTP-Route-Notify:} contém um caminho (rota) entre o repassador e um servidor. O repassador envia esse tipo de pacote ao servidor, após receber o pacote do tipo \pac{GMTP-Register-Reply};

  \item \pac{GMTP-RelayQuery:} o repassador pode solicitar ao servidor uma lista de possíveis repassadores parceiros;

  \item \pac{GMTP-RelayQuery-Reply:} o servidor envia uma resposta ao repassador com uma lista de candidatos a parceiros;

  \item \pac{GMTP-Data:} qualquer nó utiliza esse tipo de pacote para transmitir dados da aplicação;

  \item \pac{GMTP-Ack:} em geral, qualquer nó utiliza esse tipo de pacote para confirmar a recepção de um determinado pacote;

  \item \pac{GMTP-DataAck:} combinação dos pacotes GMTP-Data e GMTP-Ack (\textit{PiggyBack});

  \item \pac{GMTP-MediaDesc:} descrever informações sobre a mídia sendo transmitida em um determinado fluxo de dados (conexão). Este pacote é gerado pelo servidor e pode ser processo e/ou distribuído pelos repassadores;

  \item \pac{GMTP-DataPull-Request:} o repassador envia um pedido para obter o mapa de \textit{buffer} atual de um outro repassador parceiro;

  \item \pac{GMTP-DataPull-Response:} resposta ao pedido para obtenção de um mapa de \textit{buffer};

  \item \pac{GMTP-Elect-Request:} o repassador envia para um cliente uma solicitação para que este atue como relator;

  \item \pac{GMTP-Elect-Response:} o cliente envia ao repassador uma confirmação de que aceita atuar como relator;

  \item \pac{GMTP-Close:} os servidores, repassadores ou clientes solicitam o término de uma conexão;

  \item \pac{GMTP-Reset:} determina, incondicionalmente, a finalização de uma conexão;

  \item \pac{Reservado:} deste até o identificador 31, tratam-se de valores reservados para uso futuro e os pacotes com esses valores devem ser descartados pelos nós que o processam.

\end{enumerate}

% No Apêndice~\ref{app:gmtp-cabecalhos}, apresentam-se detalhes das porções variáveis de cada tipo de pacotes do GMTP, sendo seu teor bastante técnico e portanto dedicado aos leitores interessados em sua implementação.

% \begin{table}[ht]
%         \caption{Tipos de Pacotes do protocolo \mudccp.}
%         \label{tab:tipospacotemudccp}
%     \begin{center}
% 	\vspace{-0.8cm}
%         \begin{tabular}{|p{1.0cm}|p{1.5cm}|p{1.5cm}|}
%             \hline
%
% \multicolumn{1}{|>{\columncolor[rgb]{0.05,0.2,0.43}}c}{\textcolor{white}{\textbf
% {\#}}} &
% \multicolumn{1}{|>{\columncolor[rgb]{0.05,0.2,0.43}}c|}{\textcolor{white}{
% \textbf{Tipo}}} &
% \multicolumn{1}{>{\columncolor[rgb]{0.05,0.2,0.43}}c|}{\textcolor{white}{\textbf
% {Descrição}}}
% 	    \\
% 	    \hline
% 	    \hline
%             \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c}{\textbf{0}}
% & \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c|}{Request} &
% \multicolumn{1}{>{\columncolor[rgb]{0.66,0.7,0.759}}l|}{Requisição de um fluxo
% de dados multimídia a partir do seu nome}
% 	    \\
%
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c}{\textbf{1}} &
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c|}{RequestNotify} &
% \multicolumn{1}{>{\columncolor[rgb]{0.913,0.929,0.957}}l|}{Notificar um nó
% cliente que um fluxo de dados está pronto para ser transmitido.}
% 	    \\
%
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c}{\textbf{1}} &
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c|}{Response} &
% \multicolumn{1}{>{\columncolor[rgb]{0.913,0.929,0.957}}l|}{Resposta ao pedido de
% estabelecimento de conexão multicast}
% 	    \\
%             \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c}{\textbf{2}}
% & \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c|}{Data} &
% \multicolumn{1}{>{\columncolor[rgb]{0.66,0.7,0.759}}l|}{Contém dados da
% aplicação}
% 	    \\
%
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c}{\textbf{3}} &
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c|}{Ack} &
% \multicolumn{1}{>{\columncolor[rgb]{0.913,0.929,0.957}}l|}{Confirmação de
% recebimento de pacote}
% 	    \\
%
%             \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c}{\textbf{4}}
% & \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c|}{DataAck} &
% \multicolumn{1}{>{\columncolor[rgb]{0.66,0.7,0.759}}l|}{Dados da aplicação e
% confirmação de recepção}
% 	    \\
%
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c}{\textbf{5}} &
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c|}{Elect} &
% \multicolumn{1}{>{\columncolor[rgb]{0.913,0.929,0.957}}l|}{Inicia o processo de
% eleição de um nó em relay ou reporter}
% 	    \\
%
% \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c}{\textbf{6}}
% & \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c|}{ElectReply} &
% \multicolumn{1}{>{\columncolor[rgb]{0.66,0.7,0.759}}l|}{Sinaliza o interesse de
% um nó em se transformar em relay ou reporter}
% 	    \\
%
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c}{\textbf{7}} &
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c|}{ElectAck} &
% \multicolumn{1}{>{\columncolor[rgb]{0.913,0.929,0.957}}l|}{Confirmação do nó
% eleito para relay ou reporter}
% 	    \\
%
% \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c}{\textbf{8}}
% & \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c|}{RelayQuery} &
% \multicolumn{1}{>{\columncolor[rgb]{0.66,0.7,0.759}}l|}{Transmitido por um nó
% para consultar a lista de relays}
% 	    \\
%
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c}{\textbf{9}} &
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c|}{RelayReply} &
% \multicolumn{1}{>{\columncolor[rgb]{0.913,0.929,0.957}}l|}{Resposta ao pedido
% de consulta da lista de relays}
% 	    \\
%
% \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c}{\textbf{10}}
% & \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c|}{AdvConn} &
% \multicolumn{1}{>{\columncolor[rgb]{0.66,0.7,0.759}}l|}{Utilizado por um nó
% relay ou reporter para anunciar que está ativo na rede}
% 	    \\
%
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c}{\textbf{11}} &
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c|}{Reservado} &
% \multicolumn{1}{>{\columncolor[rgb]{0.913,0.929,0.957}}l|}{Uso futuro e ignorado
% pelo receptor}
% 	    \\
%
% \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c}{\textbf{12}} &
% \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c|}{Reservado} &
% \multicolumn{1}{>{\columncolor[rgb]{0.66,0.7,0.759}}l|}{Uso futuro e ignorado
% pelo receptor}
% 	    \\
%
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c}{\textbf{13}} &
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c|}{CloseReq} &
% \multicolumn{1}{>{\columncolor[rgb]{0.913,0.929,0.957}}l|}{Servidor ou
% Relay solicita término de conexão sem TIMEWAIT}
% 	    \\
%
%             \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c}{\textbf{14}}
% & \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c|}{Close} &
% \multicolumn{1}{>{\columncolor[rgb]{0.66,0.7,0.759}}l|}{Servidor/Cliente/Relay
% solicita término da conexão}
% 	    \\
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c}{\textbf{15}} &
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c|}{Reset} &
% \multicolumn{1}{>{\columncolor[rgb]{0.913,0.929,0.957}}l|}{Determina,
% incondicionalmente, o final da conexão}
% 	    \\
%             \hline
%         \end{tabular}
%     \end{center}
% % 	\scriptsize
% % 	$^1$ O tipo de pacote \textbf{\mudccp-Reset} é utilizado com este
% % propósito, porém utiliza-se também para outros motivos: para sinalizar número
% % de
% % porta incorreto; comportamento inapropriado de opções; desconexão prevista de
% % um
% % \mdrel\space etc.
% \end{table}

% \normalsize


% ver: http://peerstreamer.org

% Anotações após defesa:
%  - Ler o survey: http://www.aicit.org/jcit/ppl/%20JCIT_MAY_30.pdf
%  - Simuladores mais robustos: SimGrid [23], OPSS [26, 27], ChunkSim [29], 3LS
% [30], OPNET [30] (não sei se vai ser bom!)
%  -

\section{Definições, Relações e Restrições}
\label{sec:defsrests}

Para melhor organizar as discussões sobre o funcionamento do GMTP, nesta seção, descrevem-se suas definições, relações e restrições. Para isto, faz-se uso de fundamentos de álgebra booleana, lógica proposicional, teoria de conjuntos e teoria dos grafos~\cite{Jonathan2003,Seroul2000,Courant1996,Devlin1979}.

\begin{enumerate}

  \item Seja o conjunto finito dos repassadores, definido por \setrepasss $ = \{\repassconst_1, \repassconst_2, \repassconst_3, \ldots, $ \repass$\}$, tal que $\repassi \in \mathbb{N}$.

  \item Seja o conjunto finito dos roteadores de uma rede de computadores, definido por \setnetrs $ = \{\netrconst_1, \netrconst_2, \netrconst_3, \ldots, $ \netr$\}$, tal que $\netri \in \mathbb{N}$. Existe uma relação \setrepasss $\rightarrow$ \setnetrs que determina a sobreposição dos nós \repasss $\in$ \setrepasss sobre os roteadores em \setnetr.

  \item Seja o conjunto finito dos servidores, definido por \setservs $ = \{\servconst_1, \servconst_2, \servconst_3, \ldots, $ \serv$\}$, tal que $\servi \in \mathbb{N}$.

  \item Seja o conjunto finito dos clientes, definido por \setclis $ = \{\cliconst_1, \cliconst_2, \cliconst_3, \ldots, $ \cli$\}$, tal que $\clii \in \mathbb{N}$.

  \item Seja o conjunto \textit{totalmente ordenado (toset)} dos pacotes de dados gerados pelos nós \servs $\in$ \setservs durante a transmissão de um evento ao vivo \event, definido por $($\setpkall$,\prec) = \{\pkconst_1, \pkconst_2, \pkconst_3, \ldots, $\pku{\pkalli}$\}$, tal que $\pkalli \in
\mathbb{N}$. Note que se utiliza o símbolo $\prec$ para representar precedência entre dois elementos.

  \item Seja um grafo determinado pelo conjunto de vértices \setservrepass, que podem estar interligados entre si por um conjunto de diferentes arestas, sendo tal conjunto denominado caminho e representado por \setway, por onde se transmitem os pacotes de dados \pku{\pkalli} $\in$ \setpkall, definido por $\eta = G($\setservrepass$,$ \setway$)$, tal que:

    \begin{enumerate}

      \item \setservrepasss $=$ \setservs $\cup$ \setrepass;

      \item Sejam as relações e restrições estabelecidas entre os diferentes tipos de nós de uma transmissão de um evento \event, definida por \transmission $= \{$\setservrepass, \setpk, \subsetcli$\}$, tal que:

      \begin{enumerate}

	  \item Seja \setpks $\subset$ \setpkall, o conjunto \textit{parcialmente ordenado (\textit{poset})} dos pacotes de dados \pks $\in$ \setpk, também chamado de fluxo de pacotes de dados ou apenas fluxo de dados, definido por $($\setpk$,\prec) = \{\pkconst_{1},\pkconst_{2}, \pkconst_{3}, \ldots, $\pku{x}$\}$, tal que $x \in \mathbb{N}$. Trata-se de um \textit{poset} porque o GMTP não garante entrega de todos os pacotes de dados \pku{\pkalli};

	  \item Seja \subsetcli, uma função que denota os \clis que estão conectados (uma relação) a um nó \repass, de modo que nenhum nó \clis $\in$ \setclis pode estar relacionado com dois ou mais nós \repass, definida por \subsetclis $:$ \repasss $\rightarrow$ \powerset{\setclic}, $\forall$\repass,\repassu{q} $\in$ \setrepass, \subsetcli$($\repass$)$ $\cap$ \subsetcli$($\repassu{q}$)$ = $\{\emptyset\}$, tal que $q \neq d$ e $q \in \mathbb{N}$;
	  \label{item:funcao-subsetcli}

% , de modo que:
%   \begin{itemize}
%     % se disser que P \subset P_{total} já é suficiente pra ser um P*?
%     \item Um fluxo de dados \setpks é dito \textit{fluxo completo},
% representado por \setpkf, se e somente se \setpks $\leftrightarrow$
% $\exists$\subsetpkalls (relação bijetora), tal que \subsetpkalls $\in$
% \powerset{\setpkallc} e \subsetpkalls $\neq \{\emptyset\}$. Ou seja, um
% \textit{fluxo completo} \setpkfs é um conjunto \textit{toset} e portanto
% não apresenta lacunas;
%
%     \item \subpkfs $: ($\pk$, $\setpk$) \rightarrow ($\subsetpk$, \prec) =
% \{$\pk, \pku{\pki+1}, \pku{\pki+2}, \pku{\pki+3}, $\ldots\}$, tal que
% \subsetpks $\subset$ \setpk, uma função \subpkf$($\pk$, $\setpk$)$ que define
% um sub-fluxo de pacotes de dados \setpks a partir de um determinado pacote
% \pks
% $\in$ \setpk. Neste caso, como \subsetpks $\subset$ \setpk, se \subsetpkfs
% $\rightarrow$ \setpkf.
%   \end{itemize}

	  \item Seja \setrel, o conjunto finito dos relatores, definido por \setrels $= \{\relconst_1, \relconst_2, \ldots, $\rel$\}$. Como todo nó \clis pode atuar como \rel, tem-se que $\exists$\subsetrels $\in$ \powerset{\setclic_\subsetclii(\repassconst_\repassi)}, tal que \rels $\in$ \subsetrel. Pelo item~\ref{item:funcao-subsetcli}, tem-se portanto que \subsetrels $\subset$ \setrels e \subsetrels $\cup$ \subsetcli$($\repass$)$ $ = $ \subsetcli$($\repass$)$.

      \end{enumerate}

    \item \setway $=$ $\bigcup^{j}_{\setwayii=1}$ \setwayi, denota todos os caminhos conhecidos por \servs para distribuir \setpk, onde $j \in \mathbb{N}$ e corresponde à quantidade de todos os possíveis caminhos \textit{toset} $($\setwayi,$\prec)$. Nesse caso, \setwayi denota um dos possíveis caminhos por onde um fluxo de dados \setpks pode ser transmitido, obrigatoriamente a partir de um nó \servs até a um nó \repassu{1}, portanto, tem-se que:

      \begin{enumerate}

	  \item $($\setwayi$,\prec) = \{$\ways $\mid$ \serv$,\repassconst_{1},\repassconst_{2},\repassconst_3, \ldots,$ \repass$\}$, $\forall$\way$,$\waysu{\wayi+1}$\in$ \setwayis $:$ \way$ \prec$ \wayu{\wayi+1} e $\mid$\setwayi$\mid$ $\ge$ $2$;

	  \item Um caminho \setwayis é dito \textit{caminho semi-completo}, representado por \setwayisf, se e somente se \setwayis $\leftrightarrow$ $\exists$\setnetr$_{\theta}$ (bijetora), tal que \setnetr$_{\theta}$ $\in$ \powerset{\setnetrc} e \setnetr$_{\theta} \neq \{\emptyset\}$. Isto é, todos os nós \netrs $\in$ \setnetrs são sobrepostos por um nó \repasss $\in$ \setwayisf;

	  \item Um caminho \setwayis é dito \textit{caminho completo}, representado por \setwayif, se for \setwayisfs e se \setwayis $\subset$ \settrans, tal que \settranss $\subset$ \setservrepasss e é o conjunto dos nós \repasss que transmitem os pacotes de dados \pks $\in$ \setpks a seus nós \clis $\in$ \subsetcli(\repass), definido por \settranss $= \{$\transs$\mid$ \transmitqus{\trans} $ = 1\}$, tal que $\transi \in \mathbb{N}$ e que:

	      \begin{enumerate}

		  \item $\varphi$ é uma função booleana que determina se um nó \transs $\in$ \settranss transmite os pacotes \pks $\in$ \setpks para \clis $\in$ \subsetcli(\trans), definida por $\varphi:$ (\trans, \setpk) $\rightarrow \{0, 1\}, \forall ($\trans, \setpk$) \in \{$\settrans$ \times \{$\setpk$\}\}$, onde 0 e 1 denotam, respectivamente, \textit{falso} e \textit{verdadeiro}.

	      \end{enumerate}

      \end{enumerate}

    \item Seja $\sim$, reversa de um conjunto \textit{toset}, tal que $\sim$ $: ($\setwayi$,\prec)$ $\rightarrow ($\setwayi$,\succ)$. Isto é, para um conjunto $($\setwayi$, \prec) = \{$\ways $\mid$ \serv$,\repassconst_{1},\repassconst_{2},\ldots, $\repass$\}$, então \invert{\setwayi} produzirá $($\setwayi$, \succ) = \{$\ways $\mid$ \repass $,\repassconst_{\repassi-1},\repassconst_{\repassi-2},\ldots,\repassconst_{1}, $\serv$\}$;

    \item Seja $\delta$, uma função que define um sub-caminho de \setwayi,
representado por \setwayid, a partir de um nó \transs $\in$ \setwayis até um nó
\transu{1} $\in$ \setwayi, tal que $\delta: ($\trans$,$\setwayi$) \rightarrow
($\setwayid$, \prec)$. Ou seja, para um caminho qualquer $($\setwayi$, \prec) =
\{$\transu{\transi+2}$,$\transu{\transi+1}$,$\trans$,$\transu{\transi-1}$,
$\transu{\transi-2}$, \ldots,$\transu{2}$,$\transu{1}$\}$,
$\delta($\trans$,$\setwayi$) = $ \setwayids $ =
\{$\trans$,$\transu{\transi-1}$,$\transu{\transi-2}$,\ldots,$\transu{2}$,
$\transu{1}$\}$.
% Neste caso, como $\delta$ faz um corte no conjunto \setwayi,
% pode-se obter \textit{caminho semi-completo} ou \textit{completo},
% representados por \setwayidsfs\space e \setwayidfs\space, respectivamente;

    \item Seja $\zeta$ uma função que calcula o custo total para transmitir um pacote \pks $\in$ \setpks através de um caminho \setwayi, definida por $\zeta :\sum_{\setwayii=1}^{\mid\setwayc_\setwayii\mid} \gamma($\way$,$ \wayu{\wayi+1}$)$, tal que $\gamma$ é uma função que determina o custo para transmitir o pacote \pks entre dois nós distintos $\forall$\way$,$\wayu{\wayi+1} $\in$ \setwayi. No GMTP, a função $\gamma$ calcula o custo apenas entre dois nós \trans,\transu{\transi+1}, com base pela largura de banda disponível em um ou mais \trans. Porém, pode-se definir outras métricas, por exemplo, o número total de saltos no caminho \setwayis ou o RTT entre o nó \servs e um nó \repass;

    \item \textit{Conjectura 1}: $\forall$\repasss $\in$ \setrepasss e $\forall$\clis $\in$ \setcli, \repasss é mais estável que qualquer \clis com relação à sua disponibilidade e participação em uma rede de favores $\eta$. Em uma rede comutada por pacotes IP, um nó \netrs $\in$ \setnetr, ou seja, um nó \repasss fica mais disponível se comparado aos seus nós \subsetcli(\repass). Por exemplo, nas transmissões de dados na Internet, a participação de um roteador no processo de transmissão de um fluxo de dados \setpks é fundamental, mesmo que seja apenas para rotear os respectivos pacotes. Apesar de óbvia, tal observação é importante porque para qualquer nó \clis receber os pacotes de dados \pks $\in$ \setpk, primeiramente os pacotes de dados \pks passam, obrigatoriamente, pelo roteador de \cli, ou seja, o seu roteador padrão. Sendo assim, quando um nó \repasss se desconecta, todos seus nós \subsetcli(\repass) tornam-se incapazes de receber \setpk, mas a recíproca não é verdadeira -- se um nó \clis se tornar indisponível, não necessariamente \repasss também se torna indisponível. Com a aceitação dessa conjectura para a rede \net, permite-se que outros nós \clis possam continuar recebendo \setpk, mesmo ocorrendo a desconexão de um nó \clis que também esteja recebendo \setpk. No GMTP, adota-se tal estratégia quando um nó \repasss passa a manter estado sobre a transmissão de \setpks e não mais os nós \cli, antes prática comumente adotada em soluções tradicionais de distribuição de conteúdos multimídia baseado em uma arquitetura P2P ou em qualquer protocolo disponível no estado da arte;
    \label{item:conjecture1}

    \item \textit{Conjectura 2}: as tabelas de roteamento dos nós \ways $\in$ \setwayis não mudam frequentemente e são independentes umas das outras. Em redes comutadas por pacotes IP, as rotas entre quaisquer nós \cliu{\clii_1} e \cliu{\clii_2} $\in$ \setclis não se alteram com uma frequência que desestabilize a comunicação entre estes. Mesmo se estas mudanças ocorrerem em uma rota de um caminho \setwayi, o impacto causado é temporário e insignificante para a transmissão de um evento \event, quando se utiliza um conjunto de algoritmos que tratem essas mudanças. Com base na aceitação dessa conjectura, pode-se antecipar a formação de parcerias pré-selecionando nós \repasss em \setservrepasss antes da efetiva transmissão de um fluxo de dados \setpk. No GMTP, adota-se tal estratégia ao permitir que no processo de conexão, todos os nós \repasss $\in$ \setrepasss informem sua posição na mensagem de requisição transmitida ao nó \serv. Quando o nó \servs recebe tal mensagem, este passa a conhecer o caminho até o referido nó \repass. Posteriormente, o nó \servs utiliza o conjunto de caminhos conhecidos para sugerir parcerias entre os nós \repass.
    \label{item:conjecture2}

%   \item $\zeta:$ $\hat{r}_x$, $\hat{r}_y$, $\hat{t}_i$)} =
% \textit{min$\{$cost($\hat{r}_y$, $\hat{r}_z$, $\hat{t}_i$)}$\}$, uma função
% recursiva que determina o custo para um nó repassador $\hat{r}_x$ obter, a
% partir de um nó repassador parceiro $\hat{r}_y$, um evento $\gamma$,
% transmitido em $\hat{t}_i$. Sendo assim, \textit{cost($\hat{r}_x$,
% $\forall\hat{r}_y$, $\hat{t}_i$)} $ = 0$ para $\hat{r}_x = \hat{t}_i$;


%   \item f: \textit{link($\hat{r}_i$, $\hat{r}_j$)} $ =
% \hat{r}_i \leftrightarrow \hat{r}_j$ ou f: \textit{link($\hat{r}_i$,
% $\hat{s}$)} $ = \hat{r}_i \leftrightarrow \hat{s}$, uma função que relaciona um
% nó $\hat{r}_i$
% a um nó $\hat{r}_j$ $\mid$ $\hat{r}_i$ e $\hat{r}_j \in R_{\tau}$ ou a um nó
% $\hat{s}$ $\mid$ $\hat{s} \in S_{\tau}$, respectivamente. A propriedade de
% comutatividade de \textit{link()} é válida, ou seja, \textit{link($\hat{r}_i$,
% $\hat{r}_j$)} $=$ \textit{link($\hat{r}_j$, $\hat{r}_i$)};;
%   \label{i:linkrepass}

    \end{enumerate}

\end{enumerate}

Desta forma, \nets representa formalmente a rede de sobreposição constituída
pelo GMTP, definindo-se as relações, restrições estabelecidas em \transmissions
e as conjecturas consideradas para a execução de tal protocolo.

\section{Constituição da Rede de Favores \net}
\label{sec:connformnet}

A constituição da rede de favores \nets ocorre por meio do registro
de participação de um ou mais nós \repasss $\in$ \setrepasss a um ou mais
nós \servs $\in$ \setserv. Isto ocorrer de forma direta ou indiretamente
por meio de outros nós \repassu{q} $\in$ \setrepass. Todo esforço realizado
nesse processo objetiva transmitir um determinado fluxo de dados $P$ para um ou
mais nós \clis $\in$ \setcli, podendo ser distribuído pelos nós \repasss por
meio de diferentes caminhos \setwayis $\in$ \setway.

O GMTP tenta determinar um caminho sub-ótimo \setwayiu{\theta} através do qual
os pacotes de dados \pks $\in$ \setpks sejam entregues o mais rápido possível ao
nó \clis interessado em obter \setpk. Para isto, deve-se determinar
\setwayiu{\theta}, tal que \setwayiu{\theta} $= min(\zeta(\forall$\setwayi$))$
e, sempre que possível, que \setwayiu{\theta} seja um caminho completo
\setwayifu{\theta}. Sempre buscar um caminho completo é importante porque, como
todos os nós de tal caminho são roteadores sobrepostos por \repasss e utilizados
para transmitir \setpk, pode-se distribuir \setpks para mais nós \clis sem que
sejam necessárias múltiplas conexões em \serv. Além disso, quanto mais nós
\repasss estiverem disponíveis na rede, menor será o impacto causado pelas
desconexões nos sistemas finais que recebem o fluxo de dados \setpk.

\subsection{Registro de participação de \repasss em \net}
\label{subsec:registro-participacao}

Por analogia, o registro de participação faz com que o roteador de uma rede funcione como se fosse uma antena de recepção de uma transmissora de TV, podendo-se receber um ou mais sinais de canais de TV. Em seguida, repassam-se os sinais para os clientes conectados diretamente à antena, ou melhor, ao roteador.

O procedimento de registro de participação de um nó \repasss em uma rede $\eta$ é o primeiro passo e um dos mais importante. O registro de participação permite que um nó \repasss se registre a um nó \servs para sinalizar interesse em funcionar como um repassador de um fluxo de dados \setpk. O registro de participação pode ocorrer antes do nó \servs iniciar a transmissão de um fluxo de dados \setpks ou durante sua transmissão. Em ambos os casos, o algoritmo de registro de participação é similar, com uma diferença: se um nó \repasss solicitar previamente um registro de participação a um \servs sem interesse por um fluxo de dados \setpks qualquer, será possível mapear antecipadamente um subconjunto de possíveis nós parceiros \repassu{q} para executar a distribuição de um fluxo de dados \setpk. Neste caso, pode-se utilizar \repasss para repassar pacotes de dados \pks $\in$ \setpks mesmo quando \subsetcli$($\repass$) = \{\emptyset\}$, ou seja, mesmo se o repassador não tiver clientes para repassar o fluxo de dados \setpk. Assim, os nós \repasss passam a funcionar como se fossem servidores de uma rede CDN, que podem ser acionados dinamicamente, quando conveniente.

Para realizar um registro de participação, um nó \repasss envia uma mensagem para um nó \servs utilizando o pacote \pac{GMTP-Register} que, como resposta, envia um pacote do tipo \pac{GMTP-Register-Reply}. O uso do pacote do tipo \pac{GMTP-Register-Reply} permite a descoberta de um caminho \setwayi. Isto porque todos os nós \repasss existentes no caminho entre \servs e \repasss devem adicionar seu identificador no pacote \pac{GMTP-Register-Reply}, antes de roteá-lo para o próximo salto da rota em direção ao nó \serv. Quando o pacote \pac{GMTP-Register-Reply} alcançar o nó \repass, este envia o caminho \setwayis contido no pacote \pac{GMTP-Register-Reply} de volta ao nó \serv, utilizando o pacote do tipo \pac{GMTP-Route-Notify}. A partir desse ponto, o nó \servs conhece o caminho \setwayis que utilizará para enviar qualquer fluxo de dados até alcançar \repass, organizando-o em uma estrutura de dados do tipo grafo. Esse procedimento em três vias confirma o registro de participação de \repasss em \serv, ao passo que \servs poderá utilizar \setwayis para instruir os nós \repasss a realizarem parcerias, a fim de distribuir um fluxo de dados \setpk, como se discute adiante na Seção~\ref{sec:descparc}.

% Pelas conjecturas~\ref{item:conjecture1} e~\ref{item:conjecture2}, apresentadas
% na Seção~\ref{sec:defsrests}, o nó \servs pode utilizar os caminhos conhecidos
% \setwayis $\in$ \setways para coordenar o processo de formação de futuras
% parcerias entre os nós \repasss $\in$ \setrepass.

% Um registro de participação ocorre quando um nó deseja participar
% da rede de sobreposição, não necessariamente quando se deseja obter um fluxo de
% dados \setpk.

% Um registro de participação também pode ocorre no mesmo instante
% que um nó \repasss desejar receber um fluxo de dados \setpk.

Dessa forma, se um nó \repasss for um nó comum entre dois caminhos, será necessário apenas enviar um fluxo de dados \setpks até \repasss e este replicará o referido fluxo de dados para os nós \repassu{d+1}, \repassu{d+2}, \repassu{d+3} e assim por diante. De forma similar, se $\exists$\clis $\in$ \subsetcli$($\repass$)$ interessado em obter \setpk, com \transmitr\space $ = 1$, ou seja, quando um nó \repasss já estiver recebendo \setpk, o registro de participação já terá ocorrido e o fluxo já estará sendo recebido pelo nó \repass, vindo diretamente do nó \servs ou repassado por outros nós \repass. Como consequência, reduz-se o tempo de início de reprodução do referido fluxo de dados \setpks para os nós \clis $\in$ \subsetcli$($\repass$)$ que também solicitarem \setpk, após o primeiro nó \repasss solicitar, bastando apenas que os próximos nós \clis ``sintonizem'' suas interfaces de comunicação (\textit{socket} de rede) no canal apropriado e informado por \repass, que passa a transmitir \setpks em modo \textit{multicast}.

No Algoritmo~\ref{algo:registerRelay}, executado por um nó \repass, resumem-se os passos para o envio do pedido de registro de participação em um nó \serv. Note que não é requerido que o nó \repasss informe qual fluxo de dados \setpks está interessado em obter. Se \setpks for especificado, o nó \servs executará um procedimento para determinar se aceita ou não o pedido de registro de participação e logo começar a transmitir \setpks para o nó \repass. Em caso de aceite, inicia-se a transmissão de \setpks a partir de \servs em direção a \repasss e em modo \textit{unicast}. Caso contrário, o nó \serv instruirá um outro nó \repassu{q} a transmitir o referido fluxo de dados ao nó \repasss solicitante, com base nos caminhos \setwayis conhecidos. Já no Algoritmo~\ref{algo:onReceiveGMTPRegisterReply}, resumem-se os passos após um nó \repasss receber uma resposta do tipo \pac{GMTP-Register-Reply}, transmitida pelo nó \serv, referente ao pedido de registro de participação transmitido anteriormente por \repass. Note que \repasss transmite de volta a \servs o caminho \setwayi.

% , caso contrário, o nó \servs delegará a transmissão de tal fluxo de
% dados \setpks para algum outro repassador \repassu{q} que se tornará parceiro
% do nó requisitante \repass.

É importante salientar que toda transferência de pacotes de controle entre nós \repasss
ocorre com garantia de entrega, representando-se tais ações pelas funções com nomes contendo o sufixo \textit{Rdt} (\textit{Reliable data transfer}). Uma outra ação importante é que um nó \repasss deve periodicamente sinalizar sua participação na rede de favores \nets através de um método \textit{keep-alive}, comumente utilizado em outros protocolos de rede consolidados, como o TCP. Nesse aspecto, o GMTP segue a RFC 1122, \textit{Requirements for Internet Hosts - Communication Layers}~\cite{RFC1122}.

Um nó \repasss pode sinalizar explicitamente sua desistência de participação diretamente ao nó \serv, quando não desejar mais participar da rede de favores $\eta$ ou continuar recebendo um fluxo de dados \setpk. Para isto, deve-se enviar um pacote do tipo \pac{GMTP-Close}. Em qualquer um dos casos de desconexão, por expiração do tempo (devido ao procedimento de \textit{keep-alive}) ou explicitamente através do envio do pacote do tipo \pac{GMTP-Close}, o nó \servs deve desconsiderar \repasss em futuras formações de parcerias, finalizando o procedimento de desconexão com o envio do pacote do tipo \pac{GMTP-Reset}. Na Seção~\ref{sec:outros-aspectos}, discute-se em mais detalhes sobre o processo de desconexão de um nó \repass, pois a suspensão de transmissão dos pacotes de dados \setpks não ocorre instantaneamente, dependerá se o nó \repasss em fase de desconexão está ou não repassando \setpks para algum nó parceiro \repassu{q} -- isto inibe o impacto do \textit{churn} na qualidade de serviço oferecida à aplicação.

Por fim, salienta-se que o registro de participação do GMTP permite que quanto mais nós \repasss se registrarem em nós \serv, mais caminhos \setwayis sejam conhecidos. Quanto mais caminhos forem conhecidos, mais parcerias poderão ser formadas entre os nós \repass. Quanto mais parcerias forem formadas, maior será o número de nós \clis capazes de receber um fluxo de dados \setpks originado em \serv, disponibilizado indiretamente através dos seus respectivos nós \repass, sem nenhuma influência da camada de aplicação. No mundo real (por exemplo, na Internet), os nós \repasss podem passar a constituir dinamicamente a rede de distribuição de conteúdos de uma empresa. Por exemplo, um usuário de uma conexão residencial xDSL pode configurar seu roteador para se registrar em múltiplas redes de distribuição, como ilustrou-se na Figura~\ref{fig:tela-gmtp-inter}. Nesses casos, as redes de distribuição podem fazer uso do roteador desse usuário em momentos ociosos de recepção e transmissão de dados através da Internet. Como consequência, relações comerciais podem ser construídas entre o usuário e os provedores de rede, mas essa discussão está fora do escopo deste trabalho.

\subsubsection{Manutenção do registro de participação:}
\label{subsec:manutencao-conexao}

O procedimento de manutenção de um registro de participação deve ser feito usando o pacote do tipo \pac{GMTP-Ack}, em um tempo $t = max(300, t_{user})$, onde $t_{user}$ é definido em segundos e corresponde a um tempo definido pelo administrador do nó \repass, caso deseje um tempo menor que \ut{300}{s} para mantém o registro de participação ativo. Quando \servs receber um pacote do tipo \pac{GMTP-Ack} do nó \repass, este deve enviar um pacote do mesmo tipo. Caso \repasss não receba \pac{GMTP-Ack} no período de $4 \times RTT$, deve-se repetir tal procedimento por 3 vezes e somente após essas tentativas, o nó
\repasss deve considerar a conexão finalizada por tempo de expiração
(\textit{timeout}) e enviar um pacote do tipo \pac{GMTP-Reset}. Na RFC
5482~\cite{RFC5482}, discute-se sobre outros aspectos de expiração no tempo que
podem ser adaptados para o GMTP.

\newcommand{\attrib}{$\leftarrow$ }

\begin{algorithm}[H]
\label{algo:registerRelay}
\caption{registerRelay(\serv: PeerServer, \pks $=$ \pac{GMTP-Request})}
\SetAlgoLined

\SetKwFunction{Union}{Union}\SetKwFunction{makePkt}{makePkt}
\SetKwFunction{Union}{Union}\SetKwFunction{recvPktRdt}{recvPktRdt}
\SetKwFunction{Union}{Union}\SetKwFunction{sendPktRdt}{sendPktRdt}
\SetKwFunction{Union}{Union}\SetKwFunction{getCurrRegedServers}{getCurrRegedServers}
\SetKwFunction{Union}{Union}\SetKwFunction{parsePath}{parsePath}
\SetKwFunction{Union}{Union}\SetKwFunction{length}{length}
\SetKwFunction{Union}{Union}\SetKwFunction{getPacketFieldValue}{getPacketFieldValue}
\SetKwFunction{Union}{Union}\SetKwFunction{isFlowBeingReceived}{isFlowBeingReceived}
\SetKwFunction{Union}{Union}\SetKwFunction{respondToClients}{respondToClients}
\SetKwFunction{Union}{Union}\SetKwFunction{getChannelOfFlow}{getChannelOfFlow}
\SetKwFunction{Union}{Union}\SetKwFunction{GMTPRegister}{GMTPRegister}
\SetKwFunction{Union}{Union}\SetKwFunction{isWaitingRegisterReply}{isWaitingRegisterReply}
\SetKwFunction{Union}{Union}\SetKwFunction{waitRegisterReply}{waitRegisterReply}
\SetKwFunction{Union}{Union}\SetKwFunction{addClientWaitingFlow}{addClientWaitingFlow}
\SetKwFunction{Union}{Union}\SetKwFunction{GMTPRequestReply}{GMTPRequestReply}

\tcc{The node \repasss executes this algorithm to send a register of
participation to a given node \serv. If \pks is given, node \clis wants to
receive the flow \setpk, so notify \serv.}

\If(){\pks $\neq$ NULL} {
  \textit{\setpk} \attrib \getPacketFieldValue{\pk, `flow'}\tcc*[r]{Extracts \setpks in \pk}
  \label{algo-line:registerRelay-getP}
  \textit{\cli} \attrib \getPacketFieldValue{\pk, `client'}\tcc*[r]{Extracts \clis in \pk}
  \textit{channel} \attrib \isFlowBeingReceived{\setpk}\tcc*[r]{Ver Seção~\ref{subsec:tabela-recepcao}}
  \tcc{Add \clis in the list of receivers waiting \setpk.}
  \addClientWaitingFlow{\cli, \setpk}\;
  \label{algo-line:addClientWaitingFlow}
  \uIf(){\textit{channel} $\neq$ NULL} {
    \label{algo-line:isFlowBeingReceived}
    \tcc{Let \clis know that \setpks is already registered in this \repasss and is available from a \textit{multicast} channel.}
    \respondToClients{\GMTPRequestReply{\textit{channel}}}\;
    \label{algo-line:respondToClients1}
    \Return{0}\;
    \label{algo-line:registerRelay-returnChannel}
  } \Else(\tcc*[f]{Flow \setpks not registered yet.}) {
      \tcc{Send request to \servs and wait registration reply. When \pac{GMTP-Register-Reply} is received, executes onReceiveGMTPRegisterReply (Algorithm~\ref{algo:onReceiveGMTPRegisterReply}).}
%  If the \pac{GMTP-Register} was already sent, nothing should be done other than wait for \pac{GMTP-Register-Reply}.
      \If() {\textbf{not} \isWaitingRegisterReply{\setpk}} {
	\isWaitingRegisterReply{\setpk, true}\;
	\sendPktRdt{\GMTPRegister{\serv, \setpk}}\;
% 	\Return{0}\;
      }
      \tcc{Ask \subsetcli$($\repass$)$ to wait registration reply for \setpk.}
      \respondToClients{\GMTPRequestReply{\setpk}}\;
      \label{algo-line:respondToClients2}
      \Return{0}\;
  }
}
\If(){\textbf{not} \isWaitingRegisterReply{\serv}} {
  \Return{\sendPktRdt{\GMTPRegister{\serv}}}\;
}
\Return{0};

\end{algorithm}

\vspace{0.8cm}

\begin{algorithm}[H]
\label{algo:onReceiveGMTPRegisterReply}
\caption{onReceiveGMTPRegisterReply(\pks $=$ \pac{GMTP-Register-Reply})}
\SetAlgoLined

\SetKwFunction{Union}{Union}\SetKwFunction{setWaitingRegisterReply}{setWaitingRegisterReply}
\SetKwFunction{Union}{Union}\SetKwFunction{createMulticastChannel}{createMulticastChannel}
\SetKwFunction{Union}{Union}\SetKwFunction{getAndStoreServerPublicKey}{getAndStoreServerPublicKey}
\SetKwFunction{Union}{Union}\SetKwFunction{updateFlowReceptionTable}{updateFlowReceptionTable}
\SetKwFunction{Union}{Union}\SetKwFunction{startRelay}{startRelay}
\SetKwFunction{Union}{Union}\SetKwFunction{sendWayBackToServer}{sendWayBackToServer}

\tcc{The node \repasss executes this algorithm when receives a packet of type
\pac{GMTP-Register-Reply}, as response for a registration of participation sent to a \servs node.}

\setWaitingRegisterReply{\setpk, false}\;
\uIf(\tcc*[f]{\servs confirmed registration}){\pks = OK} {
  \textit{\setwayi} \attrib \getPacketFieldValue{\pk, `way'}\tcc*[r]{Gets \setwayis in \pk}
  \textit{\servs} \attrib \getPacketFieldValue{\pk, `server'}\tcc*[r]{Gets \servs in \pk}
  \textit{\setpk} \attrib \getPacketFieldValue{\pk, `flow'}\tcc*[r]{Gets \setpks in \pk}
  \If(\tcc*[f]{Reply to \subsetcli$($\repass$)$, waiting for \setpk}){\setpks $\neq$ NULL}{
    \If(\tcc*[f]{Section~\ref{subsec:obterchavepublica}}){\servs enabled security layer} {
      \getAndStoreServerPublicKey{\serv}\;
    }
    \textit{channel} \attrib \createMulticastChannel{\serv, \setpk}\;
    \updateFlowReceptionTable{\textit{channel}}\tcc*[r]{Section~\ref{subsec:tabela-recepcao}}
    \label{algo-line:updateFlowReceptionTable}
    \tcc{Let \clis $\in$ \subsetcli$($\repass$)$ know the \textit{multicast} channel to receive \setpks (Section~\ref{subsec:conexao-requisicao} for more details).}
    \respondToClients{\GMTPRequestReply{\textit{channel}}}\;
    \label{algo-line:respondToClients3}
    \tcc{Start to relay \setpks to clients (Section~\ref{subsec:trocdados}).}
    \startRelay{\textit{channel}}\;
    \label{algo-line:startRelay}
  }
  \tcc{It was just a reply of a registration of participation. Update flow reception table.}
  \updateFlowReceptionTable{\textit{\serv}}\tcc*[r]{Section~\ref{subsec:tabela-recepcao}}
  \sendWayBackToServer{\setwayi}\;
} \Else() {
  \tcc{\servs refused to accept the registration of participation. This \repasss must notify the clients waiting for receiving \setpk.}
  \textit{errorCode} \attrib \getPacketFieldValue{\pk, `error'}\;
  \respondToClients{\GMTPRequestReply{\textit{errorCode}, \setpk}}\;
  \label{algo-line:respondToClients4}
}

\end{algorithm}
\vspace{0.8cm}

\subsubsection{Geração do identificador de um nó \repass}

% Cabecalho GMTP: 32B
% Para o Request-Reply, não precisa do nome da mídia, então -128bits, 32B - 16B = 16B (o número de 
% O cabelho fixo do Request-Reply tem apenas 128bits, sobrando 11872bits (para mtu 1500B), -20B do IP = 11712bits - 48bits da camada de enlace ethernet (6 para MAC orig, 6 para MAC dest + 32 para CRC + 4 de complemento binário) = 11664bits para guardar ids do caminho
% Como o identificador de um roteador terá 160bits (chave md5 + ip), tem-se a possibilidade de transportar 72 identificadores (sobram 148bits) para IPv4

% ; e para IPv6 45 saltos, restando \ut{192}{bits} -> errado, tem que recalcular com o tamanho do cabecalho ipv6

É muito importante entender a motivação e como se define um identificador de um repassador. Como discutiu-se anteriormente, um servidor passa a conhecer um caminho até o cliente, porque cada repassador deve informar seu identificador nos pacotes dos tipos \pac{GMTP-Request-Reply} e \pac{GMTP-Route-Notify}. O identificador deve ser único em toda a rede, pois os servidores identificam intersecções entre os repassadores já sendo utilizados para transportar os pacotes de dados da mídia. Ao conhecer as intersecções, pode-se sugerir parcerias entre repassadores com interesses comuns. Sendo assim, a questão é qual poderia ser o identificador único de um repassador. A primeira opção e a mais simples é utilizar o endereço IP do roteador. Porém, um roteador possui múltiplas interfaces de rede e dependendo da interface de saída, um endereço IP específico será utilizado. Ou seja, o endereço IP identificará a interface de rede do repassador e não o próprio repassador, independente de interfaces. Sendo assim, não se pode utilizar o endereço IP como identificador único, caso contrário o servidor poderia interpretar um mesmo repassador como se fosse dois repassadores distintos.

Por este motivo, tomou-se a seguinte decisão: o identificador de um repassador é um código \textit{hash} MD5 da concatenação dos endereços MAC (\textit{Media Access Control}) de todas as interfaces de rede do roteador, seguido do endereço IP da Internet de saída. Sendo assim, o identificador de um repassador terá o tamanho de \ut{160}{bits} para IPv4 e \ut{256}{bits} para IPv6. Como resultado, considerando os cabeçalhos do GMTP, do IPv4 e da camada de enlace\footnote{Considerou-se cabeçalho Ethernet de \ut{48}{bits}.}, em um datagrama de \ut{1.500}{Bytes}, é possível descobrir caminhos IPv4 de até 73 saltos entre o cliente e o servidor no procedimento de registro de participação, restando \ut{8}{Bytes}. No caso do IPv6, é possível descobrir caminhos de até 45 saltos, restando \ut{28}{Bytes}. Os espaços restantes nos pacotes dos tipos \pac{GMTP-Request-Reply} e \pac{GMTP-Route-Notify} podem ser úteis para transportar outros tipos de dados de controle ou até mesmo dados de aplicação.

\subsection{Tabela de recepção para obter \setpk}
\label{subsec:tabela-recepcao}

Antes de seguir com a explicação sobre o processo de estabelecimento de conexão do GMTP, é importante entender que cada repassador mantém uma tabela chamada \textit{Tabela de Recepção de Fluxos de Dados}, como ilustra-se na Figura~\ref{fig:tabela-recepcao-1}. Um nó \repasss utiliza tal tabela para registrar todos os fluxos de dados que estão sendo repassados para seus nós \clis $\in$ \subsetcli$($\repass$)$ e os respectivos canais \textit{multicast} utilizados, mantendo-se as seguintes informações:

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=.55]{imgs/tabela-recepcao-fluxo-1.pdf}
\end{center}
\vspace{-1cm}
\caption{Exemplo de uma tabela de recepção de fluxo mantida por um repassador.}
\label{fig:tabela-recepcao-1}
\end{figure}

\begin{itemize}

  \item \textit{Nome do Fluxo de Dados \setpk:} é uma sequência de
\ut{128}{bits} que determina o nome de um fluxo de dados, como descreve-se na
Seção~\ref{subsec:content-index};

  \item \textit{Servidores \serv:} o endereço IP do nó \servs que gera o fluxo
de dados \setpk;

  \item \textit{Repassadores \repassu{q}:} o endereço IP do nó \repassu{q},
parceiro de \repass, que está transmitindo o fluxo de dados \setpks para
\repass. Se nulo, significa que o fluxo de dados \setpks está sendo recebido
diretamente do nó \serv;

  \item \textit{Porta de Recepção de \setpk:} o número da porta do nó remoto
que está transmitindo o fluxo de dados \setpks para \repass. Nesse caso, o nó
remoto pode ser o nó \serv, em caso de conexão direta com o servidor, ou um nó
\repassu{q}, parceiro de \repass;

  \item \textit{Endereço do Canal Multicast:} o endereço IP \textit{multicast} utilizado
pelo nó \repasss para repassar o fluxo de dados \setpks para os clientes
\clis $\in$ \subsetcli$($\repass$)$; e

  \item \textit{Porta do Canal Multicast:} o número da porta \textit{multicast} utilizada
pelo nó \repasss para repassar o fluxo de dados \setpks para os clientes
\clis $\in$ \subsetcli$($\repass$)$.

\end{itemize}

Conceitualmente, quando um nó \repasss adiciona um registro na tabela de recepção de fluxos de dados, define-se \transmitrs $=$ $1$, ou seja, \repasss $\in$ \settrans. Um nó \repasss consulta a tabela de recepção de fluxos de dados quando recebe um pedido de conexão (\pac{GMTP-Register}) para obter um fluxo de dados \setpk, tal como apresentou-se na Linha~\ref{algo-line:isFlowBeingReceived} do Algoritmo~\ref{algo:registerRelay}, Seção~\ref{subsec:registro-participacao}. Além disso, um nó \repasss atualiza a tabela de recepção de fluxos de dados após receber uma confirmação do registro de participação, tal como apresentou-se na Linha~\ref{algo-line:updateFlowReceptionTable} do Algoritmo~\ref{algo:onReceiveGMTPRegisterReply}, Seção~\ref{subsec:registro-participacao}. Mais adiante, na Seção~\ref{subsec:conexao-requisicao}, discutem-se em mais detalhes as ações de consulta e atualização da tabela de recepção de fluxos de dados.

\subsection{Formação de parcerias entre \repass}
\label{sec:descparc}

Dado que as parcerias ocorrem entre os nós \repasss $\in$ \setrepasss
e não entre os nós \clis $\in$ \setcli, a formação de parcerias consiste em determinar intersecções de caminhos \setwayi, considerando o nó \textit{pivot} \servs e diversos nós \repasss interessados em obter \setpk, a pedido de seus nós \clis $\in$ \subsetcli$($\repass$)$. Este processo pode ocorrer antes e durante a transmissão de um fluxo de dados \setpks gerado por um nó \serv, de forma transparente para a aplicação em execução em \cli, durante seu pedido de conexão transmitido em direção ao nó \serv. Como consequência, constitui-se um ou mais caminhos \setwayis $\in$ \setway, os quais interconectam um nó \servs e os nós \clis $\in$ \subsetcli(\way), tal que
$\exists$\setwayis $\mid$ \ways $\in$ \setwayi. Como regra geral para formação
de parcerias, definem-se três critérios:

\begin{enumerate}

  \item o melhor nó \servs para servir um nó \repasss é aquele que está especificado em seu pedido de registro de participação, pois deve-se respeitar as regras de balanceamento de carga definida pela CDN. Em geral, o servidor DNS define tais regras com base no endereço IP do nó solicitante;

  \item se \transmitqu{\way} $=$ $1$, então \ways pode agir como se fosse um nó \serv. Nesse contexto, deve-se respeitar uma restrição do controle de congestionamento unicast do GMTP, onde \ways somente servirá outro nó parceiro \repasss se a taxa de transmissão entre ambos for igual ou superior à taxa de transmissão entre \ways e \serv.

  \item se o nó \ways $\in$ \setwayis e se \ways se enquadra no Item 2, então o melhor nó \servs para servir \repasss será o mesmo que serve o nó \way.

\end{enumerate}


\begin{figure}[ht]
\begin{center}
\includegraphics[scale=.5]{imgs/esquema-abstrato-formacao-parceria-intra.pdf}
\end{center}
\vspace{-0.8cm}
\caption{Cenário e passos para seleção de nós (exemplo 1).}
\label{fig:esquema-abstrato-formacao-parceria-intra}
\end{figure}

% $\{$\setwayiu{1}, \setwayiu{2}, $\dots$ \setwayiu{\setwayii}$\}$

Para entender detalhes desse processo, considere a Figura~\ref{fig:esquema-abstrato-formacao-parceria-intra}. No Passo 1, ilustra-se um cenário de rede \nets $=$ $G($\setservrepass, \setway$)$, onde \setservrepasss $=$ $\{$\servu{1}, \repassu{1..19}$\}$, \setways $=$ $\{\emptyset\}$ e \transmission $=$ $\{\{\emptyset\}$, $\{\emptyset\}$, $\{\emptyset\}\}$, ou seja, sem qualquer fluxo de dados \setpks sendo transmitido, tampouco nenhuma parceria efetivada e suprimindo-se os nós \clis $\in$ \subsetcli$($\repassu{1..19}$)$. Já no Passo 2, ilustra-se a mesma rede \net, porém com \transmission $=$ $\{\{$\servu{1}, \repassu{5..9}$\}$, \setpk, \subsetcli$($\repassu{9}$)\}$, constituindo-se o caminho \setwayiu{1} $=$ $\{$\servu{1}, ..., \repassu{9}$\}$ (linha tracejada e vermelha), portanto, \setway $=$ $\{$\setwayiu{1}$\}$ e \transmitqu{\repassu{9}} $=$ $1$. Nesse exemplo do Passo 2, o nó \repassu{9} recebe o fluxo de dados \setpks em modo \textit{unicast} e repassa \setpks para todos os nós \clis $\in$ \subsetcli$($\repassu{9}$)$ em modo \textit{multicast}. Para constituir o caminho \setwayiu{1}, o nó \repassu{9} deve transmitir o pedido de registro de participação ao nó \servu{1} (como discutiu-se na Seção~\ref{subsec:registro-participacao}) e, a partir de sua confirmação,
processada pelo nó \servu{1} e enviada ao nó \repassu{9}, o nó \repassu{9} começa a receber os pacotes \pks $\in$ \setpk. Com este procedimento, o nó \servu{1} passa a conhecer o caminho \setwayiu{1}, que pode ser utilizado para determinar futuras parcerias. Desse ponto em diante, utilizar-se-á tal exemplo como base para explicar outros aspectos do processo de formação de parceria do GMTP.

Na Figura~\ref{fig:esquema-abstrato-formacao-parceria-interseccao}, considera-se a formação de parceria por intersecção do fluxo de dados \setpk, a partir do Passo 2 da Figura~\ref{fig:esquema-abstrato-formacao-parceria-intra}. Este procedimento ocorre quando um outro nó \repasss envia um pedido de registro de participação em direção ao nó \servu{1}, a fim de obter o fluxo de dados \setpk, motivado por algum nó \clis $\in$ \subsetcli$($\repass$)$. Nesse caso, se um nó \repasss transmitir um pedido de registro de participação através de um sub-caminho \setwayids tal que $\exists$\setwayis $\in$ \setway, o nó \servs determina a intersecção de ambos e instrui o nó comum \ways a repassar o fluxo de dados \setpks também para \repass, sendo desnecessidade de enviar um segundo fluxo de dados na mesma direção de \setwayid. Sendo assim, a resposta de \servu{1} não resulta em uma nova transmissão do fluxo de dados \setpk, mas sim em uma mensagem de controle para o nó \way, após identificá-lo como o nó comum a dois ou mais caminhos \setwayi. Isto implicará que o referido nó \ways replique o fluxo de dados \setpk, mesmo quando $|$\subsetcli$($\way$)|$ $=$ $0$, mas de modo conveniente para evitar múltiplas transmissões do fluxo de dados \setpk, originadas em \serv. A fim de compreender o funcionamento desse procedimento, acompanhe a explicação a seguir, com base na ilustração da Figura~\ref{fig:esquema-abstrato-formacao-parceria-interseccao} e no caminho \setwayiu{1}.

\begin{figure}
\begin{center}
\includegraphics[scale=.5]{imgs/esquema-abstrato-formacao-parceria-interseccao.pdf}
\end{center}
\vspace{-0.8cm}
\caption{Cenário para seleção de nós por interseção de caminhos \setwayi.}
\label{fig:esquema-abstrato-formacao-parceria-interseccao}
\end{figure}

Se qualquer um dos nós \repassu{7,8,10,11,12}, suponha \repassu{11}, enviar um
registro de participação em direção à \servu{1} para obter um fluxo de dados
\setpks (Passo 3 da
Figura~\ref{fig:esquema-abstrato-formacao-parceria-interseccao}), o nó
\servu{1} descobrirá o caminho \setwayiu{2} $=$ $\{$\repassu{5}, \repassu{6},
\repassu{7}, \repassu{10}, \repassu{11}$\}$ (Passo 4). Em seguida, pela
intersecção $($\setwayiu{1} $\cap$ \setwayiu{2}$)$, o nó \servu{1} determinará
que o nó \repassu{7} é o nó comum e portanto instruirá que \repassu{7} repasse o
fluxo de dados \setpks também para o nó solicitante \repassu{11}. A instrução de
\servu{1} para \repassu{7} deve determinar \transmitqu{\repassu{7}} $=$ $1$.
Em termos práticos, isto obriga o nó \repassu{7} a adicionar uma nova entrada na
tabela de recepção de fluxos de dados referente a \setpk, mesmo se
$|$\subsetcli$($\repassu{7}$)|$ $=$ $0$ para \setpk. É óbvio que, se
posteriormente $|$\subsetcli$($\repassu{7}$)|$ $>$ $0$ para \setpk, será
necessário apenas \repassu{7} criar um canal \textit{multicast} para a transmissão
local de \setpk, evitando-se um novo registro de participação em \servu{1}. Na
Seção~\ref{subsec:conexao-requisicao}, discute-se em mais detalhes este aspecto
do GMTP, explicando-se os procedimentos de pedido de conexão de um nó \cli.

Ao estender a discussão sobre o cenário ilustrado na
Figura~\ref{fig:esquema-abstrato-formacao-parceria-interseccao}, percebe-se que, se o nó \repassu{10} necessitar obter o mesmo fluxo de dados \setpk, seu pedido de registro de participação será interceptado pelo nó \repassu{7} e parte do procedimento supracitado se repete. Uma situação similar ocorre se o nó \repassu{12} ou qualquer nó \repasss $\in$ \setwayiu{4} também desejar obter o fluxo de dados \setpk, tal que \setwayiu{4} $=$ $\{$\repassu{1}, \repassu{2}, \repassu{3}, \repassu{4}$\}$ (Passo 5 e 6). Para o caso do nó \repassu{12}, o nó \repassu{11} interceptará o pedido de registro de participação de \repassu{12}, ao passo que se for qualquer nó \repasss $\in$ \setwayiu{4}, o nó \repassu{6} realizará tal interceptação, pois o nó \servu{1} determinará \transmitqu{\repassu{6}} $=$ $1$, depois do primeiro pedido de registro de participação originado por qualquer nó \repasss $\in$ \setwayiu{4}. A única diferença nesses últimos casos é que, como \transmitqu{\repassu{7}} $=$ $1$ e \transmitqu{\repassu{11}} $=$ $1$, o nó \repassu{7} tem autonomia para responder ao nó \repassu{10} e ao nó \repassu{11} como se fosse o nó \servu{1}, sem repassar tal pedido em direção ao nó \servu{1}.

Para generalizar essa discussão sobre o processo de formação de parcerias do GMTP, caso existam outros nós \repassu{q} interessados em obter um fluxo de dados \setpks e estão interligados direto ou indiretamente a \repass, tal que \transmitqu{\repass} $=$ $1$, o nó \repasss sempre interceptará o pedido de registro de participação dos nós \repassu{q} e atuará como se fosse o nó \servu{1}. No caso do exemplo que se discute, independente da ordem em que as requisições de registro de participação sejam enviadas por \ways $\in$ (\setwayiu{1} $\cup$ \setwayiu{2} $\cup$ \setwayiu{3} $\cup$ \setwayiu{4}), será necessário transmitir apenas um fluxo de dados \setpks para ``alimentar'' os quatro caminhos referidos. Isto significa que todos os nós \clis $\in$ \subsetcli$($\setwayiu{1} $\cup$ \setwayiu{2} $\cup$ \setwayiu{3} $\cup$ \setwayiu{4}$)$ receberão um único fluxo de dados, com repasse dos pacotes \pks $\in$ \setpks realizado em modo \textit{multicast} em cada sub-rede de cada nó \ways (Passo 7). Como a transmissão será em modo \textit{multicast}, torna-se indiferente a quantidade de nós \clis desses caminhos, mas faz-se necessário um mecanismo para controle de congestionamento em modo \textit{multicast}, a ser discutido na Seção~\ref{sec:ccgmtp}.

Note que, o nó \repasss que interceptar um pedido de conexão para um fluxo de dados \setpk, deve transmitir para o nó \servs uma notificação sobre a(s) parceria(s) formada(s) por intersecção. No caso do exemplo anterior, os nós \repassu{6}, \repassu{7} e \repassu{11} devem realizar tal notificação enviando um pacote do tipo \pac{GMTP-Register}, como explicado na Seção~\ref{subsec:registro-participacao}. Para isso, deve-se ativar o bit P (\textit{pass-along}) do cabeçalho GMTP (Figura~\ref{fig:gmtp-fixed-header}) para o pacote do tipo \pac{GMTP-Register}. Esta ação é importante devido aos aspectos gerenciais de uma transmissão, onde uma aplicação poderá contabilizar os nós \repasss que estão recebendo \setpk, mesmo que indiretamente, por meio da interceptação de registros de participação. A propósito, em ICN isso não é possível.

Na prática, não se faz necessário que o nó \repasss envie a notificação de intercepção instantaneamente. Em vez disso, um nós \repasss pode acumular diversos registros de participação durante um determinado intervalo de tempo e, em seguida, transmiti-los para o nó \serv. Como se trata de um aspecto em nível de implementação, tal decisão está fora do escopo dessa discussão. No caso da implementação do GMTP realizada em simulador e utilizada neste trabalho, definiu-se que para todo registro de participação interceptado, gera-se e transmite-se uma notificação ao nó \serv.

No Algoritmo~\ref{algo:findPartnerIntersectPath}, resumem-se os passos descritos anteriormente na perspectiva do nó \serv, a fim de determinar a formação de parcerias por intersecção. Executa-se tal algoritmo quando o nó \servs recebe um pedido de registro de participação enviado por um nó \repasss para obter um fluxo de dados \setpk. Através dessa estratégia de formação de parceria, permitem-se repasses de pacotes de dados pelo nome do fluxo de dados e não com base no servidor que o produz e transmite. Em todo caso, o destino da requisição é sempre o servidor, garantindo-se que, se nenhum repassador interceptar o pedido de registro de participação, com certeza tal pedido alcançará o servidor e o estabelecimento de conexão ocorrerá normalmente. Por isso, é importante a continuidade do uso de endereçamento IP, ausente em redes ICN. Além disso, esta decisão é fundamental para manter a compatibilidade com as aplicações de rede existentes na Internet, que transmitem um pedido de conexão e recebem uma resposta que pode ser ou não oficialmente gerada pelo servidor, mas o importante é receber o fluxo de dados \setpks -- o GMTP faz com que a rede cuide disso.

% O nó \servs compara os caminhos conhecidos
% \setwayis $\in$ \setways com o caminho \textit{\setwayiu{\repassconst_\repassi}}
% contido no pedido de conexão transmitido por \repass. Se \servs encontrar um nó
% \ways em comum entre algum \setwayis e
% \textit{\setwayiu{\repassconst_\repassi}}, \servs instrui o nó \ways a
% interceptar os próximos pedidos de registro de participação para obter \setpk;
% caso contrário, \servs aceita o novo pedido de conexão, permitindo-se futuras
% parcerias por intersecção. Note que, após este procedimento, o nó \servs passa a
% conhecer o caminho \textit{\setwayiu{\repassconst_\repassi}}.

\begin{algorithm}[H]
\label{algo:findPartnerIntersectPath}
\SetAlgoLined
\caption{handleRegisterParticipation(\repass: PeerRelay, \pks $=$
\pac{GMTP-Register})}
\tcc{\servs executes this algorithm to finds the first node \ways common to a
known path \setwayis and the path \setwayiu{\repassconst_\repassi}. \setwayis is
already used for transporting \setpks to node in $\delta($\way, \setwayi$)$, and
\setwayiu{\repassconst_\repassi} contains all nodes between \repasss (requester)
and \serv. The packet \pks carries \setwayiu{\repassconst_\repassi} and the
\setpks flow name.}
\textit{done} \attrib \textit{false}\tcc*[r]{It becomes true when \ways is found}

\SetKwFunction{Union}{Union}\SetKwFunction{makePkt}{makePkt}
\SetKwFunction{Union}{Union}\SetKwFunction{getPacketFieldValue}{getPacketFieldValue}
\SetKwFunction{Union}{Union}\SetKwFunction{recvPktRdt}{recvPktRdt}
\SetKwFunction{Union}{Union}\SetKwFunction{sendPktRdt}{sendPktRdt}
\SetKwFunction{Union}{Union}\SetKwFunction{length}{length}
\SetKwFunction{Union}{Union}\SetKwFunction{getKnownPathsOfFlow}{getKnownPathsOfFlow}
\SetKwFunction{Union}{Union}\SetKwFunction{GMTPRegisterReply}{GMTPRegisterReply}

\textit{\setpk} \attrib \getPacketFieldValue{\pk, `flow'}\tcc*[r]{Extracts \setpks in \pk}
\textit{\setwayiu{\repassconst_\repassi}} \attrib \invert{\getPacketFieldValue{\pk, `path'}}\;
\textit{\setwayiu{\setpkc}} \attrib \getKnownPathsOfFlow{\setpk}\tcc*[r]{\setwayiu{\setpkc} $\subset$ \setway}
% \tcc*[r]{For a given flow and all the known paths \setways in this \serv, get a sub set of paths used to transmit \setpk}

\ForEach{\setwayis $\in$ \setwayiu{\setpkc}}{
    \ForEach{\ways $\in$ \setwayi} {
      \If(){\ways $\in$ \textit{\setwayiu{\repassconst_\repassi}}} {
        \tcc{The node \ways is common in \setwayis and in \textit{\setwayiu{\repassconst_\repassi}}.}
        \textit{done} \attrib \textit{true}\;
        break\;
      }
    }
    \If(){\textit{done}} {
% \tcc{Create a \pac{GMTP-Response} and send it to \way. After receiving \textit{\pk}, \ways becomes a relay of the flow \setpk.}
% \pks \attrib \makePkt{\pac{GMTP-Response}(1), \ways}\;
      \tcc{\servs stores \textit{\setwayiu{\repassconst_\repassi}} as a known path and replies to \repass, asking \ways to act as a relay for \setpk. \servs actives flag 'relay' of the \pac{GMTP-RegisterReply}.}
      \setwayiu{\setpkc}[\length{\setwayiu{\setpkc}}] \attrib \textit{\setwayiu{\repassconst_\repassi}}\;
      \Return{\GMTPRegisterReply{\way, relay=1}}\;
% \sendPktRdt(\pk)\;
% \exit{}\;
    }
}
\tcc{\servs must register \textit{\setwayiu{\repassconst_\repassi}} as a known path and reply to \repasss by accepting its connection request, since no node \ways is intersecting \textit{\setwayiu{\repassconst_\repassi}}. In this case, \servs starts the transmission of \pks $\in$ \setpks to \repass.}
\setway[\length{\setway}] \attrib \textit{\setwayiu{\repassconst_\repassi}}\;
\Return{\GMTPRegisterReply{\repass, relay=0}}\;
% \pks \attrib \makePkt{\pac{GMTP-Response}(0), \repass}\;
% \sendPktRdt(\pk)\;

\end{algorithm}
\vspace{0.8cm}

Com relação à praticidade do processo de formação de parcerias empregado no GMTP, um aspecto técnico muito importante deve ser ressaltado: apenas o nó \repasss que repassar \pks $\in$ \setpks para seus nós \clis $\in$ \subsetcli$($\repass$)$ deve manter uma entrada sobre \setpks na tabela de recepção de fluxos de dados, exceto quando sinalizado pelo nó \serv, como é o caso dos nós \repassu{6} e \repassu{7} do exemplo anterior. Além disso, como a transmissão de um fluxo de dados \setpks entre um nó \repasss e seus nós \clis $\in$ \subsetcli$($\repass$)$ ocorrerá sempre em modo \textit{multicast}, sendo necessária
apenas uma entrada na tabela de recepção de fluxos de dados sobre \setpk. Com essa estratégia, espera-se permitir uma quantidade significativa de nós \clis capazes de reproduzir um fluxo de dados \setpk, sem sobrecarregar a rede com demasiadas transmissões do mesmo fluxo de dados \setpk, além de reduzir o tempo de inicialização para reproduzir o fluxo de dados \setpks e o índice de continuidade para um fluxo de dados \setpk. Ademais, apresentaram-se procedimentos que não são adotados em nenhum protocolo de rede pesquisado no estado da arte. Trata-se da primeira solução em que o servidor auxilia os roteadores no processo de formação de parcerias, delegando-se para estes a responsabilidade de distribuir um determinado fluxo de dados \setpk, tudo de forma transparente para as aplicações. Como resultado, pode-se afirmar que os roteadores passam a funcionar como se fossem servidores de uma CDN, só que participando dinamicamente sempre que conveniente.

Por fim, um outro aspecto no processo de formação de parcerias do GMTP é o uso de informações sobre a capacidade de transmissão de um caminho \setwayis para determinar as parcerias entre os nós \repass, bem como a qualidade do fluxo de dados a ser transmitido pelo servidor. Diferentemente se comparado às soluções baseadas em HTTP (por exemplo, DASH), em vez de um servidor GMTP gerar múltiplos fluxos de dados, codificados em diferentes taxas de bits, gera-se o fluxo de dados com a taxa de bits correspondente à capacidade máxima de transmissão do caminho \setwayis em um determinado instante. Isto ocorre porque o GMTP expõe, ao nó \serv, a informação de controle de congestionamento percebida pelos nós \ways $\in$ \setwayi. Sendo assim, o nó \servs  codifica a mídia em uma qualidade possível de ser transportada através de \setwayis utilizando um codificador do tipo VBR (\textit{Variable Bit Rate}), como o H.264~\cite{6422289}. Na Seção~\ref{subsec:mudccp-ucc}, discute-se essa função em mais detalhes.

% \subsubsection{\space\space\space\space\space\space2. Formação de parcerias por
% intersecção de \setwayi}
% \label{subsec:parcintersec}

% \subsubsection{\space\space\space\space\space\space3. Formação de parcerias por
% combinação de \setwayi}
% \label{subsec:parccombina}
%
% O procedimento de formação de parcerias por combinação considera um nó
% \textit{pivot} \servs e consiste em combinar caminhos distintos \setwayiu{1} e
% \setwayiu{2}, tal que \setwayiu{1} $\cap$ \setwayiu{2} $= \{$\serv$\}$, como
% ilustra-se na Figura~\ref{fig:esquema-abstrato-formacao-parceria-combinacao},
% Passo 1. Dessa forma, dado um conjunto de caminhos conhecidos \setway, o nó
% \servs executa as combinações e instrui, por exemplo, dois nós \wayu{1} $\in$
% \setwayiu{1} e \wayu{2} $\in$ \setwayiu{2} a se tornarem parceiros para
% compartilharem o mesmo fluxo de dados \setpk, transmitindo apenas um fluxo de
% dados \setpks para ser distribuídos aos nós \clis $\in$
% $($\subsetcli$($\wayu{1}$)$ $\cup$ \subsetcli$($\wayu{2}$))$. Este procedimento
% resultará na constituição de um caminho \setwayis contendo todos os nós \repasss
% entre os \wayu{1} e \wayu{2}. Como consequência, pode-se repassar o mesmo fluxo
% \setpks também para outros nós \clis $\in$ \subsetcli$($\repass$)$.
%
% \begin{figure}[ht]
% \begin{center}
% \includegraphics[scale=.5]{imgs/esquema-abstrato-formacao-parceria-combinacao.pdf}
% \end{center}
% \vspace{-0.8cm}
% \caption{Cenário e passos para seleção de nós por combinação de caminhos
% \setwayi.}
% \label{fig:esquema-abstrato-formacao-parceria-combinacao}
% \end{figure}
%
% % Tal procedimento pode ajudar os nós \repasss a expandirem
% % suas parcerias, incluindo a possibilidade de obter pacotes de dados \pks $\in$
% % \setpks de múltiplos nós parceiros \repassu{q}.
%
% Com o registro de participação de cada nó \repasss em \serv, o nó \servs
% conhece os caminhos \setwayis $\subset$ \setways através dos quais se
% transmite o fluxos de dados \setpk. Sendo assim, \servs pode determinar
% candidados a parceiros \repassu{q} de um determinado nó \repasss e esse
% procedimento acontece da seguinte forma. Um nó \repasss enviar uma mensagem ao
% nó \servs para solicitando a lista de parceiros
%
% Para isso, o nó
% \servs instrui
% os nós \wayu{1} e \wayu{2} a executarem um algoritmo para determinar se
% \wayu{1} servirá \wayu{2} ou se \wayu{2} servirá \wayu{1}. Note que é possível
% que a parceria entre \wayu{1} e \wayu{2} não ocorra. Por exemplo, \wayu{1} se
% tornará parceiros de \wayu{2} apenas se o custo entre \wayu{1} e \wayu{2} for
% menor do que o custo entre \wayu{1} e \serv.
%
%  a
% execução da formação de parceria por combinação, o nó \servs envia um pacote do
% tipo \pac{GMTP-Partnership} aos nós \repass, escolhidos dentre os que estão
% conectados e recebendo o fluxo de dados \setpks diretamente de \serv, para
% executarem o Algoritmo~\ref{algo:findPartnerCombinePath}. Em geral funciona com
% base em busca binária, tendo como critério o custo entre $\zeta($\setwayiu{1}$)$
% e $\zeta($\setwayiu{2}$)$  da seguinte forma. O nó \servu{2} processa os
% caminhos
% \setwayis conhecidos e determina quais são os melhores parceiros \repassu{q}
% para um determinado nó \repass, sendo tal informação enviada para \repass. No
% caso do cenário ilustrado na
% Figura~\ref{fig:esquema-abstrato-formacao-parceria-combinacao}, Passo 2, é
% possível combinar os caminhos \setwayiu{1} e \setwayiu{2} pelos nós \repassu{6}
% e o \repassu{15}. Ao combinar dois caminhos \setwayiu{1} e \setwayiu{2}, sempre
% haverá duas direções para a transmissão do fluxo de dados \setpk, uma ilustrada
% no Passos 3 e outra ilustrada no Passo 4 da
% Figura~\ref{fig:esquema-abstrato-formacao-parceria-combinacao}. Para decidir
% qual opção escolher, o nó \servu{2} compara os custos $\zeta($\setwayiu{1}$)$ e
% $\zeta($\setwayiu{2}$)$. Se $\zeta($\setwayiu{1}$) \geq \zeta($\setwayiu{2}$)$,
% então o nó \servu{2} solicita que \repassu{9} envie um pedido de conexão para
% \repassu{16} (Passo 4). Por fim, o nó \repassu{15} deve enviar uma notificação
% para o nó \servu{2} informando sobre a constituição do novo caminho \setwayi. Em
% caso de $\zeta($\setwayiu{1}$) \leq \zeta($\setwayiu{2}$)$, então o nó \servu{2}
% solicitará que \repassu{16} envie um pedido de conexão para \repassu{9} (Passo
% 3), ao passo que o restante do procedimento ocorrerá de forma similar ao que
% acabara de ser explicado.
%
% Esta é a grande motivação da formação de parceria por combinação, pois quando o
% pedido de conexão do nó \repassu{9} alcançar o nó \repassu{15}, este o
% interceptará e, nesse instante, constitui-se um novo caminho \setwayis $=
% \{$\repassu{15}$,$\repassu{14}$,$\repassu{6}$,$\repassu{7}$,$\repassu{8}$,
% $\repassu{9}$\}$.
%
% É importante salientar que o pedido de conexão enviado pelo nó \repassu{9}
% para o nó \repassu{15} deve conter uma sinalização (\textit{flag}) que
% instruirá o nó \repassu{6} a não interceptar tal pedido de conexão. Para
% tal sinalização, dá-se o nome de \textit{ignorar pedido de conexão},
% do inglês \textit{bypass connection request}.
%
% Nessa estratégia de formação de parceria, permite-se que um nó \repasss obtenha
% os pacotes \pks $\in$ \setpks de duas ou mais fontes distintas. No caso do
% exemplo supracitado, o nó \repassu{6} pode continuar recebendo o fluxo de dados
% através do caminho \setwayiu{1} e também através do novo caminho \setwayis que
% acabara de ser constituído.
%
% Nesse contexto, para realizar a formação de parceria por combinação, o nó \servs
% executa o Algoritmo~\ref{algo:findPartnerCombinePath}.\\
%
% \begin{algorithm}[H]
% \label{algo:findPartnerCombinePath}
% \SetAlgoLined
% \KwData{\textit{relayPartners} \attrib [ ]}
%
% \SetKwFunction{Union}{Union}\SetKwFunction{make_pkt}{make\_pkt}
% \SetKwFunction{Union}{Union}\SetKwFunction{recv_pkt_rdt}{recv\_pkt\_rdt}
% \SetKwFunction{Union}{Union}\SetKwFunction{send_pkt_rdt}{send\_pkt\_rdt}
% \SetKwFunction{Union}{Union}\SetKwFunction{getKnownPaths}{getKnownPaths}
% \SetKwFunction{Union}{Union}\SetKwFunction{matchSimilarPath}{matchSimilarPath}
% \SetKwFunction{Union}{Union}\SetKwFunction{parse_path}{parse\_path}
% \SetKwFunction{Union}{Union}\SetKwFunction{length}{length}
%
% mspf \attrib 0.4\tcc*[r]{paths are considered similar if similarity level is
% equal or above mspf value}
% pathSet \attrib \getKnownPaths{}\tcc*[r]{get \setways known in this \serv}
%
% \ForEach{\setwayiu{x} $\in$ \setway}{
%   \If(){\matchSimilarPath{\setwayiu{x}, \setwayis} >= mspf}{
%     \tcc{Get the closest partner in the path (intersection between \setwayiu{x}
% and \setwayi) and add to the list of prospective partners for \repass.}
%
%     prosRelay = NULL\;
%     \ForEach{\ways $\in$ \setwayiu{x}} {
%       \If(){\ways $\in$ \setwayi} {
% 	\textit{relayPartners}[\length{relayPartners}] \attrib prosRelay\;
%       }
%     }
%   }
% }
%
% pkt $ \leftarrow$ make\_pkt(GMTP\_ADV\_RELAY(\textit{relayPartners}), \repass)\;
%
% send\_pkt\_rdt(pkt)\;
%
% \caption[matchPartnersByPathCombination(\setwayi,
% \repass)]{matchPartnersByPathCombination(\setwayi, \repass)}
% \end{algorithm}
% \vspace{0.8cm}

\section{Transmissão de \pks $\in$ \setpks através de \net}
\label{sec:asptransrecep}

No GMTP, transmite-se os pacotes de dados \pks $\in$ \setpks utilizando uma estratégia híbrida \textit{push/pull}. Utiliza-se o método \textit{push} por padrão, onde os nós \servs iniciam a transmissão de \pks $\in$ \setpks para os demais nós \ways $\in$ \setwayi. Já o método \textit{pull} é utilizado somente quando um nó \clis $\in$ \setclis precisa obter parte de uma mídia que está na iminência de ser reproduzida e ainda não foi repassada por um nó \repasss via \textit{push}, de acordo com o seu mapa de \textit{buffer}.

% Os nós \repasss mantêm um mapas de
% \textit{buffer}, sendo que um no \repasss sempre terá um mapa de \textit{buffer}
% mais atualizado do que os mapas de \textit{buffer} dos nós \clis $\in$
% \subsetcli$($\repass$)$.

Nessa seção, apresentam-se detalhes sobre como se realiza a disseminação de pacotes de dados \pks $\in$ \setpks e como os nós \clis recebem tal conteúdo para reprodução, discutindo-se aspectos sobre indexação, requisição, recepção e compartilhamento de um fluxo de dados \setpk.

\subsection{Indexação de \setpk}
\label{subsec:content-index}

No GMTP, um fluxo de dados \setpks tem um nome único que o identifica em qualquer nó. Na prática, cada fluxo de dados \setpks corresponde a uma mídia gerada a partir de um evento ao vivo \event, por exemplo, a transmissão de um jogo de futebol, corrida de fórmula 1, etc.

Define-se um nome de um fluxo de dados \setpks por um código de \textit{hash} MD5 no formato UUID (\textit{Universally Unique IDentifier}) de \ut{128}{bits}~\cite{RFC4122}. Na sua forma canônica, representa-se \setpks por uma sequência de 32 dígitos hexadecimal, exibidos em cinco grupos separados por hífen, na forma de \{8\}-\{4\}-\{4\}-\{4\}-\{12\}. Por exemplo, \setpks $=$ \textit{641f931f-d3ac-50e3-b625-537574541f1f}.

Na prática, para gerar o nome para um fluxo de dados \setpk, utiliza-se uma função de \textit{hash} do tipo MD5. Sendo assim, para determinar o nome de um fluxo de dados \setpk, disponibilizado por um nó \serv, utiliza-se MD5(IP$_{\servconst_\servi}$ + : + PORTA$_{\servconst_\servi}$). Por exemplo, suponha que um servidor esteja disponibilizando um fluxo de dados \setpks através do endereço 200.17.113.98, na porta 21200. O nome do fluxo de dados \setpks será definido por \textit{MD5("200.17.113.98:21200") = f8ea01fd-4d71-5d95-89ec-35646e11d7fe}. 

Opcionalmente, o nó \servs pode divulgar o nome do fluxo de dados através do serviço DNS. Já com relação ao título do conteúdo e sua descrição, tais informações podem ser divulgadas por meio de um serviço web, ou por meio de uma busca de diretório via um \textit{Web Services}. Independente da forma que o nó \servs disponibilize os nomes dos fluxos de dados \setpk, de posse de um identificador de um fluxo de dados \setpk, um nó GMTP poderá solicitar os pacotes de dados \pks $\in$ \setpk. Além disso, os nós \repasss mantêm a tabela de recepção dos fluxo de dados que estão repassando para os nós \clis $\in$ \subsetcli$($\repass$)$ e, sendo assim, podem compartilhá-la para outros repassadores. Atualmente, não se explora o compartilhamento da tabela de repasse, mas pode ser feito para formar parcerias entre dois nós \repasss sem precisar consultar o nó \serv, por exemplo. Com esse esquema de nomes baseado no endereço IP e porta, o GMTP não requer alterações na camada de aplicação para informar o fluxo de dados de interesse -- a aplicação continua informando endereço IP e número da porta no momento do estabelecimento de uma conexão, mantendo-se a compatibilidade com as aplicações existentes e, portanto, futuras adoção do GMTP na Internet.

No caso do uso do DNS, o nó \servs divulga os identificadores de todos os eventos sendo transmitido por meio de um mecanismo de atualização dinâmica de registro de DNS, como especificado na RFC 2136~\cite{RFC2136}. Para o GMTP, criou-se um novo tipo de registro de DNS chamado de SID (\textit{Streaming IDentifier}).

No Quadro~\ref{algo:requestDNS}, ilustra-se um exemplo de uma requisição DNS, utilizando a ferramenta \textit{dig}, um comando de terminal para Linux. Nesse exemplo, apresenta-se a lista dos nomes dos fluxos de dados transmitidos pelo domínio administrativo \textit{globo.com}. Por ser uma consulta simples de DNS, qualquer sistema final conectado à Internet pode realizar tal procedimento, enaltecendo-se a facilitar de adaptar aplicações multimídia existentes para utilizar o GMTP. Ao indexar o conteúdo através de um serviço de DNS, permite-se desacoplar a forma de indexar um determinado conteúdo e a forma de obtê-lo, que passa a ser de responsabilidade da infraestrutura de rede e não de uma ou mais aplicações isoladamente, como nas soluções apresentadas no Capítulo~\ref{cap:trabalhosrelacionados}. Isto pode permitir o aumento das aplicações multimídia sem se preocupar como localizar um determinado conteúdo, extrapolando-se as barreiras administrativas de cada sistema de geração de conteúdos multimídia, bastando para isso apenas todas as aplicações utilizarem o protocolo GMTP. Consequentemente, um fluxo de dados \setpk, gerado por uma aplicação qualquer APL1, em execução em um nó \serv, poderá ser reproduzido por uma aplicação APL2, em execução em um nó \cli, independentemente de seus fornecedores (por exemplo, similar ao serviço Web, onde as aplicações servidoras, como o Apache, é independente das aplicações cliente, como Chrome, Firefox, etc). Para que essa visão seja empregada, definiu-se uma função para descrever a mídia transmitida em um fluxo de dados \setpk.

\vspace{0.5cm}

\newcommand{\bigspace}{~~~~~}

\begin{algorithm}[H]
\label{algo:requestDNS}
\SetAlgoLined
\SetAlgorithmName{Quadro}{quadro}{.}

\caption{Exemplo de requisição e resposta da lista de nomes dos fluxos de dados
\setpks de um distribuidor de conteúdos multimídia.}

\textbf{dig} -t SID globo.com\tcc*[r]{comando de requisição}
\textbf{QUESTION SECTION:}\\
\bigspace globo.com.\bigspace IN\bigspace SID\\

\textbf{ANSWER SECTION:}\\
\bigspace globo.com.\bigspace IN\bigspace SID\bigspace
"111f931f-d3ac-10e3-b62f-f17f74541f1f"\\
\bigspace globo.com.\bigspace IN\bigspace SID\bigspace
"72c44591-7d82-427c-825f-722f015787c1"\\
\bigspace globo.com.\bigspace IN\bigspace SID\bigspace
"0bb0b9f5-f57d-4da5-8a6c-13acf1965188"\\

\textbf{SUMMARY:}\\
\bigspace Query time: 4 msec\\
\bigspace SERVER: 192.168.1.252:53(192.168.1.252)\\
\bigspace WHEN: Tue Jul 16 15:44:25 2013\\

\end{algorithm}
\vspace{0.8cm}

\subsection{Descrição de um fluxo de dados \setpk:}
\label{subsubsec:desc-conteudo}

O GMTP permite nativamente a descrição da mídia a ser transmitida e com isso promover a compatibilidade entre diferentes aplicações. Para isto, incorporou-se ao GMTP o protocolo o SDP (\textit{Session Description Protocol}), definido na RFC 2327~\cite{RFC2327}. Com o SDP, permite-se que as aplicações obtenham mais detalhes sobre a mídia, flexibilizando-se o acesso a um determinado conteúdo. Como consequência, as aplicações se preocupam apenas com a decodificação e a reprodução do conteúdo ao usuário, independente de qual sistema remoto que o gerou.

Com esta decisão, torna-se mais fácil implementar novas aplicações multimídia, ao passo que fica mais fácil adaptar aplicações existentes para fazer uso do GMTP, uma vez que, em sua grande maioria, já se utiliza o SDP. Do ponto de vista de engenharia de software, isto evitará a repetição de esforço com implementações já consolidadas e que, com o passar dos anos, provou-se funcionar a contento, como foi o caso do SDP. Consequentemente, caso seja necessário a atualização do referido padrão, tal atualização será realizada internamente no GMTP e todas as aplicações automaticamente já poderão usufruir dos novos recursos disponibilizados. Na prática, isto significa uma atualização em nível de sistema operacional. A título comparativo, considerando os protocolos baseado em HTTP e os sistemas de distribuição multimídia, descritos no Capítulo~\ref{cap:trabalhosrelacionados}, cada um possui uma proposta diferente de descrição da mídia, predominando o uso de XML, porém não se mantendo o mesmo formato. A consequência disso é que a aplicação cliente, para suportar diversos sistemas, terá que implementar cada uma dessas propostas e usar XML gasta-se mais espaço se comparado ao SDP.

Para uma aplicação em execução em \serv, faz-se necessário apenas determinar as informações da mídia e as fornece ao GMTP através de passagem de parâmetro via \textit{socket}. Em seguida, o GMTP fica pronto para enviar a descrição da mídia como resposta ao pedido de conexão, dentro do campo de dados do pacote do tipo \pac{GMTP-Register-Reply} ou \pac{GMTP-MediaDesc}. Como um nó \repasss pode interceptar um pedido de conexão, o nó \repasss também pode transmitir a descrição da mídia aos seus nós parceiros \repassu{q}. Além disso, um nó \repass, ao interceptar uma solicitação por uma mídia para atender a um pedido de um nó \repassu{q}, decide qual fluxo de dados deve ser transmitido, com base na taxa de transmissão observada entre \repasss e \repassu{q} e na disponibilidade de codificação da mídia gerada pelo nó \serv. No Quadro~\ref{algo:sdp-mediadesc}, apresenta-se um exemplo de uma mensagem SDP e, a seguir, descreve-se cada um dos possíveis atributos de uma mensagem SDP.

\begin{itemize}

  \item \textit{v}, a versão do SDP;

  \item \textit{o}, a lista de nós \servs que a distribui;

  \item \textit{s}, o nome da mídia, como discutido na
Seção~\ref{subsec:content-index};

  \item \textit{i}, o título da mídia;

  \item \textit{u}, a URI que descreve detalhes sobre a mídia;

  \item \textit{c}, as informações de conexão, como a versão do protocolo de
rede e o endereço do nó \repass;

  \item \textit{f}, o certificado digital emitido pelo nó \servs para
verificação
de autenticidade dos pacotes \pks $\in$ \setpks (opcional). Este assunto
será retomado na Seção~\ref{sec:seguranca};

  \item \textit{m}, o tipo da mídia, a porta de conexão e protocolo de
transporte; e

  \item \textit{a}, atributos adicionais sobre a mídia como, por exemplo,
qualidade, idioma, taxa de bits mínima e máxima necessária para transmitir a
mídia, em bytes.

\end{itemize}

\vspace{0.5cm}

\begin{algorithm}[H]
\label{algo:sdp-mediadesc}
\SetAlgoLined
\SetAlgorithmName{Quadro}{quadro}{.}

\bigspace v=0\\
\bigspace o=- IN IP4 177.135.177.241, IP4 186.192.82.163, IP6 2001:0db8:85a3::7344\\
\bigspace m=video 51372 GMTP/RTP/MPEG-4.2 256 pt-br\\
\label{line:sdp-mediadesc:m1}
\bigspace m=video 51373 GMTP/RTP/MPEG-4.2 512 pt-br\\
\bigspace m=video 51374 GMTP/RTP/MPEG-4.2 1024 pt-br\\
\bigspace m=video 51375 GMTP/RTP/MPEG-4.2 2048 pt-br\\
\bigspace m=video 51376 GMTP/RTP/MPEG-4.2 4096 pt-br\\
\label{line:sdp-mediadesc:m5}
\bigspace s=72c44591-7d82-427c-825f-722f015787c1\tcc*[r]{ver
Seção~\ref{subsec:content-index}}
\label{line:sdp-mediadesc:index}
\bigspace i=An Introduction about Global Media Transmission Protocol (GMTP).\\
\label{line:sdp-mediadesc:title}
\bigspace u=http://www.ic.ufal.br/projects/gmtp/introduction.ps\\
\label{line:sdp-mediadesc:desc}
% \bigspace c=IN IP4 200.17.113.100\\
\bigspace f=x509:http://177.135.177.241/certs/cert.crt\tcc*[f]{ver Seção~\ref{sec:seguranca}}\\
\label{line:sdp-mediadesc:f}

\caption{Exemplo de uma mensagem SDP no pacote \pac{GMTP-MediaDesc}.}
\end{algorithm}
\vspace{0.8cm}

No exemplo apresentado no Quadro~\ref{algo:sdp-mediadesc}, Linha 1, define-se o uso da versão 1.0 do protocolo SDP. Na Linha 2, descreve-se que a mídia correspondente a \setpks está disponível através de três nós \servs que constituem a rede CDN, os quais dois são acessíveis através de endereços IPv4 e um através de um endereço IPv6. Entre as Linhas~\ref{line:sdp-mediadesc:m1} e~\ref{line:sdp-mediadesc:m5}, descreve-se que o primeiro nó \serv, especificado na Linha 2, transmite \setpks codificado em cinco taxas de bits (\ut{256}{Kbps}, \ut{512}{Kbps}, \ut{1024}{Kbps}, \ut{2048}{Kbps} e \ut{4096}{Kbps}) e com a porção do áudio no idioma \textit{portugues/brasil}. Cada fluxo de dados correspondente à uma determinada codificação de bits é acessível através de uma porta diferente em \servs e, dessa forma, pode-se permitir múltiplas codificações da mídia e com diferentes formatos e idiomas (caso a organização do evento ofereça o serviço de tradução simultânea). Por exemplo, o primeiro fluxo de dados (Linha~\ref{line:sdp-mediadesc:m1}) está codificado no formato MPEG-4 (Parte 2), com uma taxa de bits de \ut{256}{Kbps} e acessível através da porta $51372$. Em seguida, na Linha~\ref{line:sdp-mediadesc:index}, especifica-se o nome da mídia e nas Linhas~\ref{line:sdp-mediadesc:title} e~\ref{line:sdp-mediadesc:desc}, especificam-se o título do evento e uma URL para maiores informações. Por fim, na Linha~\ref{line:sdp-mediadesc:f}, observa-se uma URL do certificado digital, a ser utilizado pelos nós \repasss para verificar a autenticidade do conteúdo de pacote de dados \pks $\in$ \setpk. Na Seção~\ref{sec:seguranca}, discute-se este último assunto em mais detalhes.

É importante salientar que os nós \repasss utilizam as informações da taxa de bits para determinar o tamanho do \textit{buffer} de recepção necessário para comportar os pacotes de dados \pks $\in$ \setpks, sendo adicionada uma entrada na tabela de recepção de fluxos de dados para cada fluxo codificado em uma taxa de bit.

% Além
% disso, o tamanho do \textit{buffer} é definido em consonância com os parâmetros
% determinados pelo algoritmo de controle de congestionamento executado no módulo
% GMTP-Inter, a ser discutido em detalhes na
% Seção~\ref{sec:ccgmtp}, a seguir.

\subsection{Estabelecimento de conexão entre \clis e \servs para obter \setpk}
\label{subsec:conexao-requisicao}

Divide-se o processo de estabelecimento de conexão em três fases. A Fase 1 acontece quando, por exemplo, um nó qualquer \cliu{1} $\in$ \subsetcli$($\repass$)$ deseja obter \setpks transmitido por um nó \servu{1} e não existe nenhum outro nó \clis $\in$ \subsetcli$($\repass$)$ em sua rede local recebendo \setpk. Já a Fase 2 acontece quando um outro nó \cliu{2} $\in$ \subsetcli$($\repass$)$ precisa obter o mesmo fluxo de dados \setpk, solicitado previamente pelo nó \cliu{1}. E, por fim, a Fase 3 acontece quando o nó \repasss começa a buscar novos nós parceiros \repassu{q} a fim de obter \setpk. Na Figura~\ref{fig:processo-conexao}, ilustram-se doze nós \repass, que constituem uma rede de diferentes domínios administrativos, sendo o nó \repassu{1} o repassador de um desses domínios, composto por 6 nós \clis $\in$ \subsetcli$($\repassu{1}$)$ (Rede Local), e um nó \serv, que gera o fluxo de dados \setpk.

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=.7]{imgs/processo-conexao.pdf}
\end{center}
\vspace{-1cm}
\caption{Exemplo de rede para o estabelecimento de conexão do \mudccp.}
\label{fig:processo-conexao}
\end{figure}

A regra geral é que um nó \repasss deve consultar a tabela de recepção de fluxo de dados (Seção~\ref{subsec:tabela-recepcao}) todas as vezes que processar um pacote do tipo \pac{GMTP-Request} ou do tipo \pac{GMTP-Register}. Com base no estado da referida tabela, que define a fase de conexão para um determinado fluxo de dados \setpks solicitado, o nó \repasss realiza uma determinada ação de registro de participação e repasse.

\subsection{Fase 1: primeira requisição a um fluxo de dados \setpk}
\label{subsec:conn-fase1}

A Fase 1 ocorre quando nenhum nó \clis $\in$ \subsetcli$($\repass$)$ está recebendo um fluxo de dados \setpk. Com base na Figura~\ref{fig:processo-conexao-1}, onde ilustra-se um exemplo de conexão na Fase 1, considere:

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=.7]{imgs/processo-conexao-1.pdf}
\end{center}
\vspace{-1cm}
\caption{Passos do processo de estabelecimento de conexão do \mudccps (Fase 1).}
\label{fig:processo-conexao-1}
\end{figure}

\begin{itemize}

  \item \setpk, um fluxo de dados;

  \item \servu{1}, o servidor que gera os pacotes de dados \pks $\in$ \setpk;

  \item \repassu{1}, o repassador dos nós \clis $\in$ \subsetcli$($\repassu{1}$)$; e

  \item \cliu{1}, um cliente que deseja obter um fluxo de dados \setpk, tal que \cliu{1} $\in$ \subsetcli$($\repassu{1}$)$.

\end{itemize}

Como ilustra-se na Figura~\ref{fig:processo-conexao-1}, para obter o fluxo de dados \setpk, o nó \cliu{1} inicia o canal de controle GMTP (detalhado na Seção~\ref{subsec:canaiscommudccp}) e transmite um pacote do
tipo \pac{GMTP-Request} (Passo 1 da Figura~\ref{fig:processo-conexao-1}). Para construir o pacote do tipo \pac{GMTP-Request}, qualquer nó \clis deve especificar o valor para o endereço IP de destino como sendo o endereço do nó \servs que transmite \setpk, com o valor para o campo do cabeçalho de rede \textit{TTL=1}. Além dos valores para o IP de destino e para o \textit{TTL}, o nó \clis também deve informar o nome do fluxo de dados \setpks que o usuário deseja reproduzir, presente no cabeçalho de transporte do pacote do tipo \pac{GMTP-Request}. O valor de \textit{TTL=1} é intencional, pois faz com que o nó \repasss intercepte o referido pacote de requisição, evitando-se extrapolar o domínio administrativo de sua rede local. Este nível de detalhe é essencial para garantir que o roteador gerará uma interrupção através do processo que controla a fila de roteamento quando o \textit{TTL=0}, obrigando o roteador analisar o pacote e nesse momento perceberá que é um pacote do tipo \pac{GMTP-Request}. Isso evita que o roteador tenha que verificar se todos os pacotes correspondem ao tipo \pac{GMTP-Request}, reduzindo-se a carga de processamento e portanto o atraso nodal.

Quando o pacote \pac{GMTP-Request} alcançar o nó \repassu{1} (Passo 2), este consulta a tabela de recepção de fluxos de dados e constata que não há qualquer registro para o fluxo de dados \setpk. Nesse instante, o nó \repasss inicia um processo de registro de participação para obter o fluxo de dados \setpk. Isto significa que a execução do procedimento \textit{registerRelay(\serv, \pk)}, onde \pks é o pacote do tipo \pac{GMTP-Request}, fará o nó \repassu{1} transmitir um pacote do tipo \pac{GMTP-Register} em direção ao nó \servu{1}, conforme discutiu-se na Seção~\ref{subsec:registro-participacao}. À medida que os nós \repasss repassam o pacote \pac{GMTP-Register} até alcançar o nó \servu{1}, constitui-se o caminho \setwayiu{1} $=$ $\{$\repassu{1},\repassu{2},\repassu{3},\repassu{4},\repassu{5},\servu{1}$\}$ (Passo 3, destacado na cor vermelha), conforme discutiu-se na Seção~\ref{sec:descparc}.

Em seguida, ao receber o pacote do tipo \pac{GMTP-Register-Reply}, como resposta ao registro de participação, o nó \repassu{1} cria um canal \textit{multicast} e envia um pacote do tipo \pac{GMTP-RequestNotify} para um ou mais nós \clis $\in$ \subsetcli$($\repassu{1}$)$ (Passo 4). Esta notificação permitirá aos nós \cli, aguardando para obter \setpk, ``sintonizarem'' seus respectivos \textit{sockets} no canal \textit{multicast} correspondente. No caso do exemplo supracitado, o nó \cliu{1}, após sintonizar o \textit{socket} no canal \textit{multicast} informado pelo nó \repassu{1}, começa a receber os pacotes de dados \pks do tipo \pac{GMTP-Data} ou \pac{GTMP-DataAck} (Passo 5).

No Algoritmo~\ref{algo:respondToClients}, resumem-se os passos descritos anteriormente para iniciar a transmissão dos pacotes de dados \pks $\in$ \setpks aos nós \clis $\in$ \subsetcli$($\repass$)$, após \repasss receber o pacote do tipo \pac{GMTP-RequestReply}. Nota-se que, o nó \repasss invoca tal procedimento nas Linhas~\ref{algo-line:respondToClients1} e~\ref{algo-line:respondToClients2} do Algoritmo~\ref{algo:registerRelay} e nas Linhas~\ref{algo-line:respondToClients3} e~\ref{algo-line:respondToClients4} do Algoritmo~\ref{algo:onReceiveGMTPRegisterReply} (Seção~\ref{subsec:registro-participacao}). Como resultado da Fase 1, gera-se uma nova entrada na tabela de recepção de fluxos de dados do nó \repass, tal como ilustra-se na Figura~\ref{fig:tabela-recepcao-fluxo-11}. Com base no exemplo citado, a tabela de recepção antes vazia, agora contém uma entrada que informa a ocorrência de recepção do fluxo de dados \setpks $=$ \textit{72c44591-7d82-427c-825f-722f015787c1}, originado em \serv, cujo endereço é \textit{177.135.177.241}, com porta de recepção \textit{49170}. Além disso, define-se o canal \textit{multicast} no endereço \textit{239.192.68.79} e porta \textit{1900}, através do qual os nós \clis $\in$ \subsetcli$($\repass$)$ podem receber os pacotes de dados \pks $\in$ \setpk.

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=.55]{imgs/tabela-recepcao-fluxo-11.pdf}
\end{center}
\vspace{-1cm}
\caption{Tabela de recepção de fluxos de dados após a Fase 1.}
\label{fig:tabela-recepcao-fluxo-11}
\end{figure}

\vspace{0.8cm}

\begin{algorithm}[H]
\label{algo:respondToClients}
\caption{respondToClients(\pk: \pac{GMTP-RequestNotify})}
\SetAlgoLined
\tcc{A \repasss node executes this Algorithm to respond to clients waiting for
receiving a flow \setpk. This algorithm is invoked in Lines~\ref{algo-line:respondToClients1}
and~\ref{algo-line:respondToClients2} of
Algorithm~\ref{algo:registerRelay} and in
Lines~\ref{algo-line:respondToClients3} and~\ref{algo-line:respondToClients4}
of the Algorithm~\ref{algo:onReceiveGMTPRegisterReply}.}

\SetKwFunction{Union}{Union}\SetKwFunction{getClientsWaitingForFlow}{getClientsWaitingForFlow}
\SetKwFunction{Union}{Union}\SetKwFunction{getCtrlChannel}{getCtrlChannel}
\SetKwFunction{Union}{Union}\SetKwFunction{getMediaDescription}{getMediaDescription}
\SetKwFunction{Union}{Union}\SetKwFunction{setPacketFieldValue}{setPacketFieldValue}
\SetKwFunction{Union}{Union}\SetKwFunction{getPacketFieldValue}{getPacketFieldValue}
\SetKwFunction{Union}{Union}\SetKwFunction{sendPktRdt}{sendPktRdt}
\SetKwFunction{Union}{Union}\SetKwFunction{sendPkt}{sendPkt}
\SetKwFunction{Union}{Union}\SetKwFunction{waitAck}{waitAck}
\SetKwFunction{Union}{Union}\SetKwFunction{startRelay}{startRelay}
\SetKwFunction{Union}{Union}\SetKwFunction{removeClientsWaitingForFlow}{removeClientsWaitingForFlow}

% \clis \attrib \getPacketFieldValue{\pk, `client'}\;
\textit{destAddress} \attrib \getCtrlChannel{}\tcc*[r]{238.255.255.250:1900}
\setPacketFieldValue{\pk, `destinationAddress', destAddress}\;
\textit{\setpk} \attrib \getPacketFieldValue{\pk, `flow'}\tcc*[r]{Extracts \setpks in \pk}

\textit{errorCode} \attrib \getPacketFieldValue{\pk, `errorCode'}\;
\If(){errorCode $\neq$ NULL} {
  \removeClientsWaitingForFlow{\setpk}\tcc*[r]{See Algorithm~\ref{algo:registerRelay}}
  \sendPkt{\pk}\;
  \Return{0}\;
}

\textit{channel} \attrib \getPacketFieldValue{\pk, `channel'}\;
\label{algo-line:respondToClients-getChannel}
\uIf () {\textit{channel} $\neq$ NULL} {
  \tcc{Node \repasss is already receiving \setpks and clients \subsetcli$($\repass$)$ must know the media description.}
  \textit{mediaDescription} \attrib \getMediaDescription{\setpk}\;
  \setPacketFieldValue{\pk, `data', mediaDescription}\;
  \tcc{In Algorithm~\ref{algo:registerRelay}, Line~\ref{algo-line:addClientWaitingFlow}, \clis nodes are added in a list of clients waiting for flow \setpk. Now, \repasss notifies them, wait confirmation (ACKs) from them and start relaying \pks $\in$ \setpks to them through given channel.}
  \sendPkt{\pk}\;
  \subsetcli$($\repass$)$ \attrib \getClientsWaitingForFlow{\setpk}\;
  \waitAck{\subsetcli$($\repass$)$, \setpk}\;
  \label{algo-line:respondToClients-waitAck}
} \Else (\tcc*[f]{Let \subsetcli$($\repass$)$ know \repasss is waiting for registration.}) {
  \setPacketFieldValue{\pk, `waitingRegistration', true}\;
  \sendPkt{\pk}\;
}
\Return{0}\;

\end{algorithm}
\vspace{0.8cm}

\subsection{Fase 2: próximas requisições para obter \setpk}

A Fase $2$ de conexão ocorre quando futuras requisições para obter o fluxo de dados \setpks são originadas por qualquer nó \clis $\in$ \subsetcli$($\repassu{1}$)$. Considerando o exemplo anterior, citado na Fase 1,
se um nó \cliu{2} $\in$ \subsetcli$($\repassu{1}$)$ também solicitar \setpk, o nó \repassu{1} simplesmente informará o canal \textit{multicast} correspondente ao fluxo de dados \setpk, como ilustra-se na Figura~\ref{fig:processo-conexao-2} (Passo 1). Para isto, o nó \repassu{1} intercepta a requisição do nó \cliu{2}, consulta a tabela de recepção de fluxos de dados e dessa vez constata a recepção do fluxo de dados \setpk, criando o pacote do tipo \pac{GMTP-Request-Reply} (Passo 2). Este procedimento ocorre no registro de participação, especificamente no trecho de código definidos entre as
Linhas~\ref{algo-line:registerRelay-getP}-\ref{algo-line:registerRelay-returnChannel} do Algoritmo~\ref{algo:registerRelay}. Em seguida, transmite-se o pacote do tipo \pac{GMTP-Request-Reply} ao nó \cliu{2}, como descreve-se no trecho de código entre as
Linhas~\ref{algo-line:respondToClients-getChannel}-\ref{algo-line:respondToClients-waitAck} do Algoritmo~\ref{algo:respondToClients}, que então ``sintoniza'' seu \textit{socket} para o canal \textit{multicast} informado por \repassu{1} (Passo 3). Tal procedimento se repete para cada novo nó \clis $\in$ \subsetcli$($\repassu{1}$)$ interessado em obter \setpk.

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=.6]{imgs/processo-conexao-2.pdf}
\end{center}
\vspace{-1cm}
\caption{Passos do processo de estabelecimento de conexão do \mudccps (Fase 2).}
\label{fig:processo-conexao-2}
\end{figure}

\subsection{Fase 3: busca por mais parceiros \repassu{q} para obter \setpk}
\label{subsec:phase3}


% /////////////////////////////////
%
%
% \subsection{Sobre o melhor caminho \setwayi}
% \label{subsec:melhorcaminho}
%
% LER ISSO DAKI E O QUE ESTÁ SENDO DESCRITO NESSA FASE 3. PENSAR NA IDÉIA DE QUANDO
% O NO REPASS PROCURAR POR MAIS PARCEIROS, USAR
% O CRITÉRIO COM CAMINHOS MAIS FOLGADOS (MAIORES TAXAS DE TRANSMISSÃO)
% %
% % \begin{algorithm}[H]
% % \label{algo:findPartnerIntersectPath}
% % \SetAlgoLined
% % \caption{handleRegisterParticipation(\repass: PeerRelay, \pks $=$
% % \pac{GMTP-Register})}
% % \tcc{\servs executes this algorithm to handle the request for register of
% % participation. It finds the first node \ways common to a known path \setwayis
% % and the path \setwayiu{\repassconst_\repassi}. \setwayis is already used for
% % transporting \setpks to node in $\delta($\way, \setwayi$)$, and
% % \setwayiu{\repassconst_\repassi} is the path composed by all nodes in between
% % \repasss and \serv. The packet \pks carries \setwayiu{\repassconst_\repassi} and
% % the \setpks name.}
% %
% % \SetKwFunction{Union}{Union}\SetKwFunction{makePkt}{makePkt}
% % \SetKwFunction{Union}{Union}\SetKwFunction{getPacketFieldValue}{getPacketFieldValue}
% % \SetKwFunction{Union}{Union}\SetKwFunction{recvPktRdt}{recvPktRdt}
% % \SetKwFunction{Union}{Union}\SetKwFunction{sendPktRdt}{sendPktRdt}
% % \SetKwFunction{Union}{Union}\SetKwFunction{length}{length}
% % \SetKwFunction{Union}{Union}\SetKwFunction{pathsContainingRelayByFlow}{pathsContainingRelayByFlow}
% % \SetKwFunction{Union}{Union}\SetKwFunction{GMTPRegisterReply}{GMTPRegisterReply}
% % \SetKwFunction{Union}{Union}\SetKwFunction{pathPriority}{pathPriority}
% %
% % \textit{\setpk} \attrib \getPacketFieldValue{\pk, `flow'}\tcc*[r]{Extracts \setpks in \pk}
% % \textit{\setwayiu{\repassconst_\repassi}} \attrib \invert{\getPacketFieldValue{\pk, `path'}}\;
% % \textit{\setwayiu{\setpkc}} \attrib \pathsContainingRelayByFlow{\repass, \setpk}\tcc*[r]{\setwayiu{\setpkc} $\subset$ \setway}
% % % \tcc*[r]{For a given flow and all the known paths \setways in this \serv, get a sub set of paths used to transmit \setpk}
% %
% % \setwayiu{selected} \attrib \setwayiu{\repassconst_\repassi}\;
% %
% % \ForEach{\setwayis $\in$ \setwayiu{\setpkc}}{
% %     \If() {\pathPriority{\setwayis > \setwayiu{selected}}} {
% %       \setwayiu{selected} \attrib \setwayi\;
% %     }
% % }
% %
% % \ForEach{\ways $\in$ \setwayiu{selected}} {
% %   \If(){\ways $\in$ \textit{\setwayiu{\repassconst_\repassi}}} {
% %     \tcc{The node \ways is common in \setwayis and in \textit{\setwayiu{\repassconst_\repassi}}.}
% %     \textit{done} \attrib \textit{true}\;
% %     break\;
% %   }
% % }
% %
% %     \If(){\textit{done}} {
% % %       \tcc{Create a \pac{GMTP-Response} and send it to \way. After receiving \textit{\pk}, \ways becomes a relay of the flow \setpk.}
% % %       \pks \attrib \makePkt{\pac{GMTP-Response}(1), \ways}\;
% %       \tcc{\servs stores \textit{\setwayiu{\repassconst_\repassi}} as a known path and replies to \repass, asking \ways to act as a relay for \setpk. \servs actives flag 'relay' of the \pac{GMTP-RegisterReply}.}
% %       \setwayiu{\setpkc}[\length{\setwayiu{\setpkc}}] \attrib \textit{\setwayiu{\repassconst_\repassi}}\;
% %       \Return{\GMTPRegisterReply{\way, relay=1}}\;
% % %       \sendPktRdt(\pk)\;
% % %       \exit{}\;
% %     }
% %
% % \tcc{\servs must register \textit{\setwayiu{\repassconst_\repassi}} as a known path and reply to \repasss by accepting its connection request, since no node \ways is intersecting \textit{\setwayiu{\repassconst_\repassi}}. In this case, \servs starts the transmission of \pks $\in$ \setpks to \repass.}
% % \setway[\length{\setway}] \attrib \textit{\setwayiu{\repassconst_\repassi}}\;
% % \Return{\GMTPRegisterReply{\repass, relay=0}}\;
% % % \pks \attrib \makePkt{\pac{GMTP-Response}(0), \repass}\;
% % % \sendPktRdt(\pk)\;
% %
% % \end{algorithm}
% % \vspace{0.8cm}
%
% De acordo com os procedimentos empregados de seleção de nós, é possível obter
% diferentes caminhos \setwayi, partindo-se de um nó \repasss para um nó \serv.
% Por este motivo, é importante definir, a partir de um conjunto de caminhos
% possíveis, qual é o melhor caminho a utilizar e ordená-los de acordo com a
% prioridade de uso. Com isto, é possível obter \setpks a partir de múltiplos
% \repasss e usar caminhos alternativos em caso de falha de algum caminho, por
% exemplo, por desconexão. No GMTP, utiliza-se os seguintes critérios para
% decidir entre um conjunto de caminhos \setway qual será o escolhido:
%
% \begin{enumerate}
%   \item Quanto mais o caminho \setwayis estiver próximo de ser um caminho
% \setwayif; \label{i:c-waycomp}
%   \item Menor número de nós \ways $\in$ \setwayi; \label{i:c-nnos}
%   \item Escolha aleatória de \setwayis entre os \setways conhecidos.
% \label{i:c-aleat}
% \end{enumerate}
%
% O critério~\ref{i:c-waycomp} é determinado através da verificação da condição
% $\mid$\setwayi$\mid$ $=$ $ttl($\repass$,$\setwayi$)$, onde \textit{ttl} é uma
% função que determina o número de saltos entre o nó \repasss até o nó \serv. Na
% prática, pode-se determinar tal condição comparando-se quantos nós existem no
% caminho \setwayis e o valor do campo TTL (\textit{Time-to-Live}), disponível no
% cabeçalho de qualquer pacote IP. Este critério é o primário porque quanto mais
% nós GMTP estiverem no caminho, maior será a possibilidade de interceptação
% para obter um fluxo de dados \setpk. O critério~\ref{i:c-nnos} é determinado
% pela contagem do número de \ways $\in$ \setwayi. O critério~\ref{i:c-aleat} é
% utilizado em caso de não determinação do melhor \setwayis até o critério
% anterior.
%
% Note que no GMTP é possível que um nó \repasss tenha simultaneamente mais de um
% nó parceiro \repassu{q}, porém não mais do que uma certa qualidade configurável
% devido ao fato de que os pacotes \pks dos fluxos \setpks serem transientes,
% portanto não faz sentido realizar muitas parcerias. No caso do GMTP, a
% quantidade máxima padrão de parcerias que um nós \repasss realiza é $5$, valor
% praticado em outros soluções similares para transmissão de fluxos de dados ao
% vivo baseados em arquitetura P2P.
%
%
%
% /////////////////////////////////


Na Fase $3$, o nó \repasss inicia um processo de aumentar suas parcerias a fim
de obter mais rapidamente os pacotes \pks $\in$ \setpk, através de caminhos
\setwayis alternativos.
% , em caso de falha e/ou desconexões de algum nó parceiro
% \repassu{q}.
% Ao
% considerar os aspectos discutido na Seção~\ref{sec:descparc}, nota-se que na
% Fase $1$ e $2$ utiliza-se os modos de formação de parcerias intra \setways e por
% intersecção, porém ainda resta fazer uso do modo de formação de parceria por
% combinação de \setway
% (Figura~\ref{fig:esquema-abstrato-formacao-parceria-combinacao}). Na fase $3$ de
% conexão, o GMTP explora tal recurso.
Para isto, o nó \servs constrói uma lista de nós parceiros e envia ao nó \repass, funcionando como um indexador de nós parceiros \repassu{q}, pré-selecionando parceiros para \repass. Por exemplo, seja um nó \repassu{3} que esteja recebendo \setpks originado em um nó \serv, como ilustra-se na Figura~\ref{fig:conn-phase3-1}. Para conseguir mais nós parceiros \repassu{q}, o nó \repassu{3} envia uma requisição do tipo \pac{GMTP-RelayQuery} para \servs e obtém um subconjunto de nós \repassu{q} candidatos a parceiro de \repassu{3}. No caso do exemplo supracitado, essa pré-seleção ajuda o nó \repassu{3} a escolher os melhores parceiros disponíveis, de acordo com os seguintes critérios de prioridade:

\begin{figure}[b!ht]
\begin{center}
\includegraphics[scale=0.9]{imgs/gmtp-conn-phase3-1.pdf}
\end{center}
\vspace{-1cm}
\caption{Fase 3 de conexão do GMTP (Passo 1).}
\label{fig:conn-phase3-1}
\end{figure}

\begin{enumerate}

  \item Maior capacidade de transmissão do caminho \setwayi. Define-se este critério com base na menor taxa de transmissão disponível entre todos os nós \ways $\in$ \setwayis em um determinado instante \textit{t}. Na Seção~\ref{sec:ccgmtp}, discutem-se os algoritmos de controle de congestionamento do GMTP e o procedimento para determinar a taxa de transmissão de um caminho \setwayi;
  \label{i:c-maiortranstx}

  \item Se for um caminho for \setwayif, determinado através da verificação da
condição $\mid$\setwayi$\mid$ $=$ $ttl($\repass$,$\setwayi$)$, onde \textit{ttl}
é uma função que determina o número de saltos entre o nó \repasss até o nó
\serv. Este critério é importante porque quanto mais nós GMTP estiverem no
caminho, maior será a possibilidade de interceptação para obter um fluxo de
dados \setpk;
  \label{i:c-waycomp}
%
%   \item Menor número de nós \ways $\in$ \setwayi;
%   \label{i:c-nnos}

  \item Escolha aleatória de \setwayis entre os caminhos \setways conhecidos. Nota-se que, por exemplo, no CoolStreaming, a escolha aleatória é feita em nível de cliente, ao passo que no GMTP a escolha é com base na capacidade de transmissão dos caminhos \setwayis $\in$ \setway.
  \label{i:c-aleat}

\end{enumerate}

Sendo assim, define-se a Fase $3$ do processo de estabelecimento de conexão do
GMTP em três passos:

\begin{enumerate}

  \item Um nó \repasss envia periodicamente requisições do tipo \pac{GMTP-RelayQuery} para o nó \servs a fim de descobrir melhores parceiros e aumentar o número de parcerias. Por se tratar de fluxos de dados ao vivo, não necessariamente quanto mais parceiros um nó \repasss tem, melhor será a qualidade do fluxo de dados \setpk. Por isso, um nó \repasss sempre mantém uma lista de candidatos a parceiros \repassu{q} fornecida pelo nó \serv, porém não necessariamente estabelece parcerias com todos. Em vez disso, executam-se, repetidamente, as seguintes ações:

\begin{itemize}

  \item Um nó \repasss inicia uma nova parceria se a quantidade atual de
parcerias reduzir por desconexão de um nó parceiro \repassu{q} ou se o \textit{buffer} de
recepção estiver com menos de $\frac{1}{3}$ de sua capacidade. O objetivo é
evitar o esvazeamento do \textit{buffer} para o fluxo de dados \setpk, mantendo
continuamente o repasse de pacotes de dados \pks $\in$ \setpks aos nós \clis
$\in$ \subsetcli$($\repass$)$.

  \item A quantidade de parcerias em um determinado instante \textit{t} é
inversamente proporcional a quantidade de pacotes de dados \pks $\in$ \setpks
que chegam repetidos ao nó \repass. Nesse caso, se um mesmo pacote \pks chegar
repetidamente na mesma quantidade de parcerias estabelecidas, o nó \repasss
desconecta-se daquele nó parceiro \repassu{q} cujo pacote \pks chegou por último.

\end{itemize}

  \item Após obter a lista de candidatos a parceiros (Passo 1), o nó \repassu{3} forma uma parceria com um dos candidatos da lista de possíveis parceiros. Para isto, o nó \repassu{3} envia requisições do tipo \pac{GMTP-Request} em direção a outros nós \repassu{q} sugeridos por \servs e que já estejam recebendo um fluxo de dados \setpk. Como ilustra-se na Figura~\ref{fig:conn-phase3-2}, este procedimento ocorre da seguinte forma: o nó \repassu{3} envia uma requisição do tipo \pac{GMTP-Request} para o nó \repassu{2}, contendo uma chave de autorização conhecida por ambos e informada pelo nó \serv. Caso a chave de autorização esteja correta, o nó \repassu{2} deve enviar um resposta do tipo \pac{GMTP-Response} ao nó \repassu{3} e então começar a repassar os pacotes \pks $\in$ \setpk. O uso da chave de autorização é importante para evitar que um nó \repasss se conecte a outro nó \repassu{q} sem que o nó \servs seja notificado sobre isto. As chaves de autorização são geradas pelo nó \servs e transmitidas como resposta no pacote do tipo \pac{GMTP-Register-Reply}. Cada entrada disponível no pacote do tipo \pac{GMTP-RelayQuery-Reply} contém o identificador do repassador candidado a parceiro e sua respectiva chave de autorização.

\end{enumerate}

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=0.9]{imgs/gmtp-conn-phase3-2.pdf}
\end{center}
\vspace{-1cm}
\caption{Fase 3 de conexão do GMTP (Passo 2).}
\label{fig:conn-phase3-2}
\end{figure}


% Como se considera uma arquitetura híbrida P2P/CDN, o nó \servs pode realizar uma
% função de balanceamento de carga, incluindo como resposta de uma requisição do
% tipo \pac{GMTP-RelayQuery} os outros nós \serv, levando-se em consideração,
% inclusive, todos os critérios estabelecidos na
% Seção~\ref{subsec:melhorcaminho}.

A periodicidade de requisições do tipo \pac{GMTP-RelayQuery} e a quantidade máxima de parcerias efetivas são parâmetros controláveis pelo administrador do nó \repass. Na implementação do GMTP utilizada neste trabalho, definiu-se o tempo de 5 minutos para a periodicidade de requisições do tipo \pac{GMTP-RelayQuery} e 5 para a quantidade de parcerias efetivas.

Com a execução da Fase 3 do processo de conexão do GMTP, pode-se expandir a quantidade de parcerias, registradas na tabela de recepção de fluxos de dados, tal como ilustra-se na Figura~\ref{fig:tabela-recepcao-fluxo}. Nesse exemplo, observa-se que um nó \repasss está recebendo e repassando aos seus nós \clis $\in$ \subsetcli$($\repass$)$ quatro fluxos de dados diferentes, originados em quatro nós \serv, porém recebendo fluxos de dados de diferentes nós parceiros \repassu{q}. Por exemplo, dentre os fluxos de dados que o nó \repasss está recebendo, um deles é o \setpks $=$ \textit{72c44591-7d82-427c-825f-722f015787c1}, cujos pacotes de dados \pks $\in$ \setpks são transmitidos por três nós \repassu{q} identificados pelos
endereços IP e porta \textit{182.111.88.21:49170}, \textit{90.39.135.46:62242} e \textit{83.67.132.41:53434}. Para esse fluxo de dados \setpk, o nó \repasss repassa os pacotes de dados \pks para os nós \clis $\in$ \subsetcli$($\repass$)$ através do canal \textit{multicast} \textit{239.192.68.79:1900}.

\begin{figure}[htb!]
\begin{center}
\includegraphics[scale=.55]{imgs/tabela-recepcao-fluxo.pdf}
\end{center}
\vspace{-1cm}
\caption{Tabela de recepção de fluxos de dados após a Fase 3.}
\label{fig:tabela-recepcao-fluxo}
\end{figure}

% \subsection{Compartilhamento de \setpks entre \servs}
% \label{subsec:compartilhamento-de-p}
%
% Além do procedimento transparente à aplicação para se obter um fluxo de dados
% \setpk, como os nós \servs constituem uma rede CDN, estes podem negociar entre
% si o envio e a recepção de um fluxo de dados \setpks de acordo com as
% requisições submetidas aos nós \repass. Desta forma, se um nó \repasss enviar
% uma requisição para obter \setpks de um evento \events a um nó \servs e este não
% esteja recebendo tal fluxo, \servs poderá solicitá-lo a outros nós \servs da
% CDN que participa. A partir desse ponto, o nó \servs passará a servir o nó
% \repasss normalmente. Como no GMTP se faz uso indireto dessa função das redes
% CDNs, a qual já está consolidada, resolveu-se suprimir maiores detalhes a
% respeito deste assunto. Para maiores informações sobre a função de distribuição
% de conteúdos ao vivo entre os servidores de uma rede CDN, o leitor pode
% consultar as
% referências~\cite{Nygren:2010:ANP:1842733.1842736,1250586,Pathan2008}.
%
\vspace{0.5cm}

Desta forma, o processo de conexão do GMTP é fundamental para a efetiva distribuição de mídias ao vivo, pois permite que as aplicações compartilhem fluxos de dados entre si, mesmo que estas não tenham sido desenvolvidas pelo mesmo fornecedor. Esta unificação ajuda no processo de distribuição do fluxo de dados \setpk, pois até mesmo uma aplicação \textit{standalone} e um objeto de vídeo imbutido em uma página Web podem obter o mesmo fluxo de dados sem que estas conheçam uma a outra. Consequentemente, reduz-se para 1 o número de transmissões para um mesmo fluxo de dados \setpks originado em \servs e destinados a uma mesma rede ou para um subconjuntos de redes adjacentes. Além dessa diferença, a forma de conexão do GMTP supre uma antiga deficiência das soluções tradicionais de transmissão \textit{multicast}, pois as aplicações tinham que se adaptar às configurações estáticas dos canais \textit{multicast}, definidos pelo administrador de rede, e os próprios administradores de rede tinham que fazer tal configuração de forma manual, obrigatoriamente em todos os nós roteadores de um determinado caminho. Isto é impraticável devido à independência dos diferentes domínios administrativos.

Desta forma, não se tem conhecimento de uma solução que permita configuração dinâmica de canais \textit{multicast} aliada à formação de uma rede de favores constituída entre roteadores. Constitui-se a rede de favores através da formação de parcerias pela intersecção de rotas que se tornam conhecidas à medida que novos clientes se interessam por uma mesma mídia, sendo este processo regido por um servidor \textit{pivot} transmissor da mídia, que sugere as parcerias com base na capacidade de transmissão dos canais em uso. Nesse contexto, compartilham-se os fluxos de dados entre aplicações de diferentes fornecedores, resultando no uso mais eficiente dos recursos computacionais e de rede. Os resultados obtidos com o uso dessa estratégia serão discutidos mais adiante no Capítulo~\ref{cap:analisedesemp}.

\subsection{Envio e recebimento de \pks $\in$ \setpks em \net}
\label{subsec:trocdados}

Após o estabelecimento de conexão, os nós \repasss trocam dados entre si em modo
\textit{unicast} a fim de distribuir os pacotes de dados \pks $\in$ \setpks do tipo
\pac{GMTP-Data} e \pac{GMTP-DataAck}. De forma similar, os nós \repasss
utilizam os mesmos tipos de pacotes para enviar \pks $\in$ \setpks para os nós
\cli, porém em modo \textit{multicast}. Quando o \mudccps estiver em funcionamento em
um nó \servs ou em um \repass, o estado é o de \textit{transmitindo dados}, ao
passo que quando executado em um cliente o estado é o de \textit{recepção de
dados}. Para o transporte dos pacotes de dados \pk, um nó \servs deve transmitir
pacotes do tipo \pac{GMTP-Data} ou o \pac{GMTP-DataAck} em direção aos nós
\repasss de acordo com os registros de partipação. Nesta seção, detalha-se como
se executa os procedimentos de transmissão e recepção desses pacotes de
dados.

% Embora o
% protocolo \mudccps transmite dados sem garantia de entrega, a aplicação pode
% determinar que certos dados sejam transmitidos com garantia de entrega. Nestes
% casos, durante a transmissão de dados, um nó \mudccps utiliza-se do pacote do
% tipo \pac{GMTP-Data} para enviar dados, ao passo que utiliza-se pacote
% \pac{GMTP-Ack} para confirmar a recepção de pacotes, ou ainda, utiliza-se
% \pac{GMTP-DataAck} para enviar pacotes de dados e ao mesmo tempo confirmar a
% recepção de pacotes de dados vindos da direção oposta (\textit{piggyback}).

\subsubsection{\textit{Buffer} de envio e recepção:}

A transmissão de um evento \events consiste no processo de disseminação
dos pacotes \pks $\in$ \setpks através dos nós interessados em obtê-lo. Para
isto, cada nó GMTP controla um \textit{buffer} de envio e recepção definido por uma
estrutura de dados do tipo \textit{array} circular (\textit{ring buffer}), onde cada
posição é utilizada para armazenar um pacote \pk, como ilustra-se na
Figura~\ref{fig:buffer-envio-recepcao-ring}. Ao receber \pk, um nó GMTP
armazena-o no \textit{buffer} e posteriormente o entrega para a aplicação, que o
reproduz para o usuário final. Para o envio ou repasse de um pacote, o nó GMTP
consome os pacotes \pks do \textit{buffer} e transmite para o(s) nó(s) interessado(s),
seja em modo \textit{unicast} e/ou em modo \textit{multicast}. Isto porque é possível que um nó
\repassu{1} repasse \pks para um outro nó \repassu{2} (\textit{unicast}) ao mesmo tempo
que \repassu{1} pode repassar \setpks para seus nós \clis (\textit{multicast}).

O \textit{buffer} de envio e recepção do GMTP tem seu tamanho definido no processo de
estabelecimento de conexão, de acordo com o tipo da mídia sendo transmitido, mas o nó \repasss pode determinar um limite a fim de evitar ataques de negação de serviço. Isto pode ocorrer porque o GMTP permite uma aplicação definir o tamanho do \textit{buffer} que cada nó \ways deverá alocar para repassar os pacote de dados \pks de um fluxo de dados \setpk. Então, uma aplicação maliciosa poderia alocar um espaço de \textit{buffer} maior do que a que o roteador suporta, ou no mínimo monopolizar tal \textit{buffer}. Após definir o tamanho inicial do \textit{buffer} circular para um fluxo de dados \setpk, este pode variar de acordo com a capacidade de transmissão do canal em um determinado instante. Essa decisão é importante porque permite um nó \servs alocar previamente o recurso necessário para o transporte de um determinado fluxo de dados \setpk. O tamanho do \textit{buffer} é especificado pelo nó
\servs e propagado para os demais nós em um caminho \setway, no cabeçalho do
pacote do tipo \pac{GMTP-Register-Reply} ou \pac{GMTP-MediaDesc}.

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=1]{imgs/buffer-envio-recepcao-ring.pdf}
\end{center}
\vspace{-1cm}
\caption{Exemplo da estrutura do \textit{buffer} de envio e recepção de um nó GMTP com
dois ponteiros, um para escrever e outro para ler pacotes \pk.}
\label{fig:buffer-envio-recepcao-ring}
\end{figure}

\subsubsection{Mapa de \textit{buffer}:}

O mapa de \textit{buffer} do GMTP descreve o estado atual do \textit{buffer} de envio e recepção
de um nó GMTP. Como ilustrado na Figura~\ref{fig:mapa-buffer-envio-recepcao},
trata-se de uma estrutura de dados que determina se um pacote \pks está
ou não presente no \textit{buffer} de um respectivo nó GMTP. O conteúdo de cada posição
é o número de sequência do pacote, que determina a ordem que um pacote foi
gerado e transmitido pelo nó \serv, mas o nó \repasss não os ordena, pois tal responsabilidade é delegada aos nós \clis no momento de sua reprodução ao usuário final.

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=0.76]{imgs/mapa-buffer-envio-recepcao.pdf}
\end{center}
\vspace{-1cm}
\caption{Exemplo do mapa de \textit{buffer} de um nó GMTP com tamanho de 17 \pk.}
\label{fig:mapa-buffer-envio-recepcao}
\end{figure}

Um nó GMTP utiliza o mapa de \textit{buffer} para sinalizar seu atual estado com relação a um determinado fluxo de dados \setpk. Um nó GMTP pode enviar o mapa de \textit{buffer} completo, como ilustrado na Figura~\ref{fig:mapa-buffer-envio-recepcao}, ou o mapa de \textit{buffer} apenas dos \pks presentes ou ausentes. Na prática, quando deseja indicar a sua atual disponibilidade, um nó \repasss envia para um nó parceiro \repassu{q} o mapa de \textit{buffer} dos \pks presentes e, quando desejar obtê-los, envia o mapa de \textit{buffer} dos \pks ausentes. Para diferençar o tipo de requisição, utiliza-se uma sinalização binária (\textit{flag}) chamada \textit{request-type}, onde $0$ significa que o mapa de \textit{buffer} contém pacotes
disponíveis e $1$, pacotes ausentes. Note que, quando um nó \repasss transmite
um mapa de \textit{buffer} para um outro nó qualquer \repassu{q}, caracteriza-se automaticamente o uso do método \textit{pull}, em vez do método \textit{push}, que é o modo padrão do GMTP. Salienta-se ainda que deve-se evitar o método pull devido à transitoriedade dos pacotes de dados \pks (transmissão de dados ao vivo) e um nó \repasss deve apenas realiza tal procedimento após completar a Fase 3 do processo de estabelecimento de conexão. Isto porque um nó \repasss pode nunca receber a resposta para uma requisição do tipo \textit{pull}. Essa sinalização ocorre através do uso do pacote do tipo \pac{GMTP-DataPull-Request}, que é preenchido com o mapa de \textit{buffer} dos pacotes ausentes e transmitido aos respectivos nós parceiros. Ao receber esse tipo de requisição, um nó parceiro avalia seu conteúdo e responde com o pacote do tipo \pac{GMTP-DataPull-Response}, o qual contém o mapa de \textit{buffer} dos pacotes disponíveis, seguido dos pacotes \pks do tipo \pac{GMTP-Data}. Note que os pacotes do tipo \pac{GMTP-DataPullRequest} e \pac{GMTP-DataPull-Response} são transmitidos com garantia de entrega.

% , ou seja, caso sejam perdidos, o GMTP
% garante sua retransmissão. Para isto, o GMTP utiliza o mecanismo básico de
% envio e confirmação utilizando o pacote do tipo \pac{GMTP-DataAck} ou
% \pac{GMTP-DataAck}. No caso de falha na execução de uma requisição utilizando o
% método \textit{pull}, o nó GMTP pode reavaliar a necessidade de retransmitir o
% pedido, pois é possível que os \pks ausentes já tenham expirados e requisitá-los
% novamente não fará mais sentido.

Na prática, o mapa de \textit{buffer} utilizado para sinalizar a presença ou ausência de
\pks é representado por faixas de acordo com o índice do \textit{buffer}. Por exemplo,
para representar o mapa de \textit{buffer} dos pacotes ausentes ilustrados na
Figura~\ref{fig:mapa-buffer-envio-recepcao}, o nó GMTP preenche o pacote do
tipo \pac{GMTP-DataPull-Request} com a sequencia \textit{2;6-10;12}. Ao receber
esta sequência, o nó parceiro \repassu{q} responde com o pacote do tipo
\pac{GMTP-DataPull-Response}, que contém o mapa de \textit{buffer} de quais
pacotes serão enviados e começa a transmití-los.

% * RELATAR TAXA DE RECEPCAO	- NO RELATA QUAL A TAXA DE RECEPÇÃO
% (PREENCHIMENTO+ATUALIZAÇÃO DO BUFFER)
% * USA ESSA INFO PARA SELECIONAR OS MELHORES PARCEIROS (FILTRO APRIMORADO)

\subsubsection{Descarte de pacotes:}

O descarte de pacotes \pks ocorre sempre no repassador e em duas situações:

\begin{enumerate}

 \item \textbf{Por transbordo do buffer:} o transbordo do \textit{buffer} pode ocorrer devido ao mecanismo de controle de congestionamento empregado no GMTP, que pode reduzir a taxa de transmissão enquanto novos pacotes precisam ser alocados no \textit{buffer}. Sendo assim, deve-se descartar os primeiros pacotes \pks recebidos se o \textit{buffer} alcançou seu limite, mesmo que ainda não tenham sido repassados. Uma otimização não explorada neste trabalho, mas que é possível de ser realizada, é o descarte seletivo de pacotes, primeiro os que tenham menos impacto na qualidade da mídia, por exemplo, pacotes de dados contendo quadros B (codificação MPEG4, tipo 2). O descarte seletivo de pacotes não impede que o vídeo seja reproduzido, porém com perda de qualidade, mas ao menos se permite a transmissão dos pacotes de dados \pks de acordo com a largura de banda disponível;

 \item \textbf{Por duplicação:} ocorre quando o pacote \pks já foi recebido anteriormente. Tal verificação é feita de acordo com o número de sequência presente em cada pacote \pk. Essa contagem é importante e pode determinar que um nó \repasss desconecte de um nó parceiro \repassu{q}, tal como explicou-se na Seção~\ref{subsec:phase3}.

\end{enumerate}

\section{Controle de Congestionamento em \net}
\label{sec:ccgmtp}

No GMTP, executa-se um algoritmo para controle de congestionamento híbrido, cujo comportamento dependerá do modo de transmissão sendo utilizado para transportar os pacotes de dados \pks $\in$ \setpks (\textit{unicast} ou em \textit{multicast}). Como ilustra-se na Figura~\ref{fig:ucc-mcc-esquema}, tratam-se de dois algoritmos para controle de congestionamento, um que atua em transmissões \textit{unicast}, chamado de \textit{\mudccps Unicast Congestion Control} (GMTP-UCC) e outro que atual em transmissões \textit{multicast}, chamado de \textit{\mudccps Multicast Congestion Control} (GMTP-MCC). No GMTP-UCC, utilizado na comunicação entre os nós \repass, define-se a taxa de transmissão de um nó \mudccps com base em uma versão modificada do protocolo RCP~\cite{Dukkipati:2008:RCP:1368746}. Já em modo de transmissão \textit{multicast}, executa-se uma versão modificado do TFRC~\cite{CONG:Floyd00:TFRC:art}, com base em relatórios transmitidos por nós \rels $\in$ \subsetcli(\repass), eleitos em cada rede e controlados por um nó \repass.

\begin{figure}[htb!]
\begin{center}
\includegraphics[scale=.7]{imgs/ucc-mcc-esquema.pdf}
\end{center}
\vspace{-1cm}
\caption{Organização do algoritmo de controle de congestionamento no \mudccp.}
\label{fig:ucc-mcc-esquema}
\end{figure}

\subsection{Controle de congestionamento \textit{unicast}}
\label{subsec:mudccp-ucc}

O \mudccp-UCC funciona de forma similar ao protocolo RCP, porém com alguns diferenciais a serem discutidos a seguir. O RCP é um protocolo para controle de congestionamento assistido pela rede que tenta emular um Comutador Compartilhado (\textit{Processor Sharing} -- PS), por exemplo, um roteador~\cite{Dukkipati:2005:PSF:2103175.2103204}. Nesse contexto, entende-se que, se um roteador pudesse obter a informação exata sobre o número de fluxos de entrada em um instante $\hat{t}$, a taxa de transmissão ideal para cada fluxo de dados seria $R_{ps}(\hat{t}) = \frac{C}{N(\hat{t})}$, onde $C$ corresponde à capacidade do \textit{enlace} e $N(\hat{t})$ o número de fluxos no instante $\hat{t}$.

Com base nesse princípio, Nandita \textit{et al}~\cite{Dukkipati:2008:RCP:1368746} argumentaram
% em sua tese de doutorado
% \footnote{O vídeo do dia da defesa de Nandita Dukkipati, autora do RCP, está disponível através da referência~\cite{Nandita-video-defesa}.}
que para um roteador funcionar de forma equânime e reduzir o tempo de duração de um fluxo (seja de curta ou de longa duração, proporcional à capacidade e independente da topologia da rede), deve-se oferecer a mesma taxa de transmissão para todos os fluxos transmitidos através deste roteador. Com isso, objetiva-se manter o número de pacotes na fila de roteamento perto de zero e evitar que apenas os fluxos mais antigos, ou seja, com a taxa de transmissão mais próxima da equânime, utilizem mais largura de banda se comparado aos fluxos mais recentes (discussões sobre este aspecto mais adiante, ainda nessa seção).

Com base nisso, determinou-se a Equação~\ref{eq:cc-rcp-teoria}, onde $R(\hat{t})$ é a taxa de transmissão que deve ser oferecida para cada fluxo de dados que passa pelo roteador. Pela Equação~\ref{eq:cc-rcp-teoria}, estima-se a largura de banda disponível em um determinado canal, representada pela porção $\alpha(C - y(\hat{t})) - \beta \frac{q(\hat{t})}{h_0}$ (mudança agregada) e a divide por $N(\hat{t})$. Porém, como é impossível determinar o valor exato de $N(\hat{t})$, estima-se\footnote{Mais detalhes sobre a estimativa do valor de $\hat{N}(\hat{t})$ está disponível na Seção 3.2.1 da referência~\cite{Dukkipati:2008:RCP:1368746}.} $\hat{N}(\hat{t}) = \frac{C}{R(\hat{t}-h_0)}$. Além disso, para atualizar $R(\hat{t})$ com mais frequência do que no intervalo de um RTT ($h_0$), definiu-se $H = min(H_{user}$, $h_0)$ e, para manter a estabilidade do restante da equação, escala-se a mudança agregada por $\frac{H}{h_0}$, resultando na Equação~\ref{eq:cc-rcp}, onde:

  \begin{equation}
  R(\hat{t}) = R(\hat{t} - h_0) + \frac{\alpha(C - y(\hat{t})) - \beta
\frac{q(\hat{t})}{h_0}}{\hat{N}(\hat{t})}
  \label{eq:cc-rcp-teoria}
  \end{equation}

  \begin{equation}
  R(\hat{t}) = R(\hat{t} - H) \left[1+\frac{\frac{H}{h_0}\left(\alpha(\gamma C - y(\hat{t})) - \beta \frac{q(\hat{t})}{h_0}\right)}{\gamma C}\right]
  \label{eq:cc-rcp}
  \end{equation}

  \begin{itemize}

    \item $h_0$, é a média móvel dos valores de $RTT_{s}$, calculada através da Equação~\ref{eq:calcrtt-rcp}, onde $\theta$ é o ganho e corresponde a $0.02$. Note que quanto maior o valor de $\theta$, mais rápida será a convergência de $h_0$ ao valor de $RTT_{s}$. $RTT_{s}$ é o tempo de ida e volta calculado entre o nó transmissor e o receptor.

      \begin{equation}
      h_0 = \theta \times RTT_{s} + (1 - \theta) \times h_0
      \label{eq:calcrtt-rcp}
      \end{equation}

    \item $H = min(H_{user}$, $h_0)$, sendo $H_{user}$ um tempo definido pelo usuário (por exemplo, o administrador do roteador), caso seja necessário atualizar $R(\hat{t})$ em um intervalo de tempo menor que $h_0$. Por exemplo, se a fila estiver enchendo, é desnecessário esperar um tempo de $h_0$ para processar a fila. O valor para $H$ é definido em \ut{}{milissegundos};

    \item $R(\hat{t} - H)$, é a última taxa de transmissão medida, em \ut{}{bytes/milissegundos};

    \item $C$, é a capacidade total do canal;

    \item $y(\hat{t})$, é a taxa de tráfego de entrada medida no intervalo entre a última atualização de $R(\hat{t})$ e o instante $H$;

    \item $q(\hat{t})$, é o tamanho instantâneo da fila de repasse, em bytes. No GMTP, esse valor é obtido pela soma de todos os pacotes \pks presentes nos buffers, para todos os fluxos de dados \setpks registrados na tabela de repasse. Nesse caso, um nó \repasss mantém um \textit{buffer} geral e um \textit{buffer} para cada fluxo de dados \setpk, que esteja repassando aos seus nós \clis $\in$ \subsetcli$($\repass$)$. Utiliza-se o \textit{buffer} geral para pacotes de dados que não precisam de tratamentos especiais, por exemplo, pacotes TCP;

%     \item $\hat{N}(t)$, é uma estimativa do número de fluxos em um tempo $t$,
% por exemplo, o número de fluxos enviando pacotes de dados \pk;

    \item $\alpha$ e $\beta$, tal que $0 < \alpha, \beta \leq 1$, determinam a estabilidade e o desempenho do algoritmo, respectivamente. Com base em discussões apresentadas em~\cite{Dukkipati:2008:RCP:1368746}, os valores de $\alpha$ e $\beta$ dependem do tamanho médio dos fluxos comparado com o produto largura de banda -- atraso. Quando o tamanho médio dos fluxos estão próximo do produto largura de banda -- atraso (fluxos longos), sugere-se um alto valor para $\alpha$ e um baixo valor para $\beta$ (por exemplo: $\alpha = 0.9$ e $\beta = 0.1$), uma vez que para fluxos longos, prefere-se maximizar a taxa de transmissão de cada fluxo a minimizar o atraso na fila. Por outro lado, para fluxos de curta duração, recomenda-se um valor baixo de $\alpha$ e um valor alto de $\beta$ (por exemplo: $\alpha = 0.1$ e $\beta = 1$), pois esta combinação ajuda manter um baixo atraso de fila. Para um equilíbrio entre a estabilidade e o desempenho, recomendam-se valores de $\alpha \in (0.4, 0.6)$ e $\beta = (0.2, 0.6)$. Para efeito de experimentação do GMTP, utilizou-se $\alpha = 0.3$ e $\beta = 0.6$;

    \item $\gamma$, tal que $0 < \gamma \leq 1$, controla o pico de utilização do canal. Por exemplo, se desejar utilizar no máximo \ut{95}{\%} do canal em um certo instante $\hat{t}$, basta definir $\gamma = 0.95$. Nesse caso, pode-se tratar cenários de reserva de banda para um ou mais fluxos de dados específicos. Para efeito de experimentação do GMTP, utilizou-se $\gamma = 1$.

  \end{itemize}

\begin{figure}[htb!]
\begin{center}
\includegraphics[scale=0.8]{imgs/ccgmtp-interacao-1.pdf}
\end{center}
\vspace{-1cm}
\caption{Cada \repasss mantém uma única taxa de transmissão $R(\hat{t})$ que é atribuída no cabeçalho de todos os pacotes transmitidos do nó \servs aos nós \way $\in$ \setwayi. À medida que o pacote passa em cada \way, se a taxa atual $R(\hat{t})$ no roteador for menor do que $R_{p}$, informada no pacote sendo processado, $R_{p}$ $\leftarrow$ $R(\hat{t})$. Quando o pacote alcançar o último nó \way, este envia para \servs o valor de $R_{p}$, que é a máxima taxa de transmissão suportada no caminho \setwayi. Ao receber o valor de $R_{p}$, \servs atualiza $R(\hat{t})$ e o valor de $h_0$, utilizando $R(\hat{t})$ para transmitir os próximos pacotes de dados. Este procedimento se repete a cada intervalo de tempo $H$.}
\label{fig:ccgmtp-interacao-1}
\end{figure}

A ideia básica é a seguinte: para quaisquer dois nós \transu{1},\transu{2} $\in$ \setwayi, a taxa de transmissão a ser utilizada por \transu{1} e \transu{2} será definida pela menor taxa de transmissão oferecida pelos nós \ways $\in$ \setwayi, posicionados entre \transu{1} e \transu{2}. Desta forma, segmenta-se um caminho \setwayis em vários sub-caminhos \setwayid. Com isto, se existir largura de banda disponível entre \transu{1} e \transu{2}, ou seja, $C - y(\hat{t}) > 0$, então o GMTP-UCC compartilhará igualmente o canal entre todos os fluxos, inclusive para o fluxo partindo de \transu{1} em direção a \transu{2}. Caso contrário, ou seja, se $C - y(\hat{t}) < 0$, considera-se o canal saturado e o GMTP-UCC reduzirá a taxa de transmissão igualmente para todos os fluxos, inclusive para o fluxo partindo de \transu{1} para \transu{2}. Por este motivo, o tempo $H$ é definido entre dois nós \transs e \transu{\transi+1} contidos em um caminho \setwayi. A consequência dessa estratégia de segmentar um caminho é muito importante e por esse motivo o GMTP-UCC é relativamente diferente se comparado ao RCP, como se discute a seguir.

O algoritmo adotado no GMTP-UCC, adaptado do RCP, funciona da seguinte forma (acompanhe os passos de acordo com a Figura~\ref{fig:ccgmtp-interacao-1}):

\begin{enumerate}[{\tab}1$^{\circ}$]

  \item Seja um caminho \setwayi, todo nó \ways $\in$ \setwayis mantém uma única taxa de transmissão local $R(\hat{t})$, que é atribuída em qualquer pacote \pks $\in$ \setpks gerado em \serv, transmitido em direção a qualquer nó \way.
  \label{step:rcp-gmtp-0}

  \item Todos os pacotes gerados pelo nó \servs carregam duas informações de controle no campo de cabeçalho:
%   \item Todos os pacotes GMTP carregam duas informações de controle no campo de cabeçalho:
  \label{step:rcp-gmtp-1}
  \begin{itemize}

    \item \textit{taxa de transmissão proposta} ($R_{p}$): corresponde à taxa de transmissão inicialmente desejada pelo nó \servs para transmitir os pacotes de dados \pks $\in$ \setpk. Como o GMTP segmenta o caminho em vários sub-caminhos, o valor de $R_{p}$ pode conter a taxa de transmissão de um nó \ways $\in$ \setwayis que está posicionado entre dois nós \trans,\transu{\transi+1} $\in$ \setwayi, com a menor capacidade de transmissão em um instante $\hat{t}$;

    \item \textit{RTT na fonte} ($RTT_{s}$): corresponde ao RTT estimado entre quaisquer nós \transu{\transi},\transu{\transi+1} $\in$ \setwayi, ou seja, o RTT entre dois nós consecutivos que processam pacotes de dados \pac{GMTP-Data} de um fluxo de dados \setpk, a fim de repassar aos seus nós \clis $\in$ $($\subsetcli(\trans) $\cup$ \subsetcli(\transu{\transi+1})$)$.

%     \item \textit{Diferença de RTT} (RTT$_{d}$): corresponde à diferença entre
% RTT$_{s}$ e o RTT medido entre dois nós \way. Por exemplo, seja um
% caminho \setwayis por onde o fluxo de dados \setpks é transmitido, com
% \waysu{1}=\space \servu{1}, \waysu{2}=\space \repassu{1}, \waysu{3}=\space
% \repassu{2} e \waysu{4}=\space \repassu{3}, tal que
% \wayu{1},\wayu{2},\wayu{3},\wayu{4} $\in$ \setwayi. Considere que o RTT entre
% \wayu{1} e \wayu{2} corresponda a um valor qualquer \textit{x}, o RTT entre
% \wayu{2} e \wayu{3} corresponda a um valor qualquer \textit{y} e o RTT entre
% \wayu{3} e \wayu{4} corresponda a um valor qualquer \textit{z}. Para esse caso,
% \wayu{1} deve especificar RTT$_{s}$ = \textit{x} e RTT$_{d}$ = 0, \wayu{2} deve
% especificar RTT$_{s}$ = \textit{x} e RTT$_{d}$ = \textit{y}; e \wayu{3} deve
% especificar RTT$_{s}$ =
% \textit{x+y} e RTT$_{d}$ = \textit{z}. Com isto, é possível que o nó
% \wayu{4} saiba qual é o RTT acumulado entre \wayu{1} até seu nó parceiro
% \wayu{3} (RTT$_{s}$) e também o RTT apenas entre \wayu{3} e \wayu{4}
% (RTT$_{d}$). Com essas informações expostas para cada nó \ways em um caminho
% \setway, qualquer nó \repasss poderá fazer uso de tais informações para decidir
% com quais nós devem fazer parcerias ou quais são seus melhores parceiros.

  \end{itemize}

  \textit{Observação:} no RCP, utiliza-se apenas os sistemas finais (transmissor e receptor) para determinar os valores de $R_{p}$ e $RTT_{s}$.

  \item No início da transmissão de um fluxo de dados \setpks por parte de \serv, o nó \way, motivado por um ou mais nós \clis $\in$ \subsetcli$($\way$)$, transmite um pedido de registro de participação ao nó \servs (Seção~\ref{subsec:registro-participacao}). Ao receber o pacote \pac{GMTP-Register}, o nó \servs envia um pacote \pac{GMTP-Register-Reply} com o campo $R_{p}$ contendo a taxa de transmissão necessária para transmitir o fluxo de dados \setpk, com o campo $RTT_{s}$ igual a \ut{1}{s}~\cite{RFC6298}. O valor inicial de $RTT_{s} = \ut{1}{s}$ é bastante conservador, mas se decidiu utilizá-lo por ser o valor inicial adotado no protocolo TCP. Além disso, inicia-se um temporizador para medir o próximo RTT instantâneo, que de fato será o primeiro valor correto e alimentará a média móvel $h_0$.
  \label{step:rcp-gmtp-2}

  \item Todo nó \ways $\in$ \setwayi, ao receber qualquer pacote gerado em \serv, verifica se sua capacidade atual de transmissão $R(\hat{t})$ é menor do que $R_{p}$ presente no referido pacote. Em caso afirmativo, atualiza-se $R_{p} \leftarrow R(\hat{t})$, caso contrário, não se realiza nenhuma modificação e repassa o pacote a diante. Nesse ínterim, se \transmitqu{\way} $=$ $1$, ou seja, \way = \transs $\in$ \settrans, \transs também executa as seguintes ações:
  \label{step:rcp-gmtp-3}

  \begin{enumerate}

    \item se o pacote for do tipo \pac{GMTP-Data}, repassa-se o pacote para seus nós \clis $\in$ \subsetcli(\trans) através do canal \textit{multicast}, a uma taxa de transmissão definida pelo algoritmo GMTP-MCC, como se discute na próxima seção; e também repassa-o em direção ao próximo nó \transu{\transi+1} $\in$ \setwayi, se houver. A transmissão dos pacotes \pac{GMTP-Data} partindo de \transs em direção ao nó \transu{\transi+1} (ou seja, \textit{down-streaming}), ocorre a uma taxa de $R(\hat{t})$ atualmente definida em \trans;

    \item cria-se um pacote \pac{GMTP-Ack} informando o valor de $R_{p}$ e o envia de volta em direção a \transu{\transi-1}, se \transs $\neq$ \serv. Ao receber esse pacote de \pac{GMTP-Ack}, \transu{\transi-1} utilizará $R_{p}$ como a nova taxa para transmitir os próximos pacotes de dados \pks $\in$ \setpk, pois se trata da menor taxa de transmissão oferecida ao longo do sub-caminho \setwayias $\subset$ \setwayi, tal que \setwayias $=$ $\{$\transu{\transi-1}, ..., \way, \wayu{\wayi+1}, \wayu{\wayi+2}, ..., \trans$\}$. 

    \textit{Observação}: Pela definição de \setwayi, \transs pode ser o nó \serv, então esse mecanismo segmenta o caminho \setwayis a cada nó \ways $\in$ (\setwayis $\cup$ \settrans), incluindo o servidor. O objetivo disso é criar sub-fluxos de transmissão dentro de um caminho \setwayis de acordo com a capacidade de transmissão e recepção a cada dois nós \transu{\transi} e \transu{\transi+1}. Trata-se de uma peculiaridade GMTP-UCC, pois se evita que um nó \transs com uma maior capacidade de recepção seja penalizado caso a capacidade de recepção $R_{p}$ do próximo nó \transu{\transi+1} seja menor do que a sua própria capacidade de transmissão. Este assunto será detalhado na próxima seção.
    \label{item:gmtp-ucc-bottleneck-ack}

  \end{enumerate}

  \item A cada instante $H$, o nó \ways atualiza $h_0$ de acordo a Equação~\ref{eq:calcrtt-rcp}, utilizando como parâmetro o valor do campo $RTT_{s}$ do último pacote recebido. Em seguida, recalcula-se a taxa de transmissão local $R(\hat{t})$ usando a Equação~\ref{eq:cc-rcp}.

\end{enumerate}

% Especificamente, a largura de banda necessária para repassar todos
% os pacotes \pks $\in$ \setpks que estão na fila de roteamento no intervalo de um
% RTT corresponde à
% $\frac{q(t)}{h_0}$~\cite{Dukkipati:2005:PSF:2103175.2103204}.

% \subsubsection{Diferença entre o RCP e o GMTP-UCC}
%
% Como discutido, o RCP é um protocolo para controle de congestionamento
% fim-a-fim, % onde os sistemas finais de origem e destino se comunicam e trocam
% pac tes de ACK % para determinar a nova taxa de transmissão $R(\hat{t})$ que o nó
% transmissor deve  utilizar para transmitir um fluxo de dados \setpk. Porém, no
% caso do GMTP um nó % \repassu{1} tem como principal função repassar os pacotes
% de dados \pks $\in$ % \setpks do tipo \pac{GMTP-Data/DataAck} para seus nós
% parceiros \repass, em c so % de $\mid$\subsetcli$($\repassu{1})$\mid$ $>$ $0$
% para o fluxo de % dados setpk. Nesse interím, tais nós realizam ações para dar
% suporte ao % ecanismo de controle de congestionamento da rede, como por exemplo
% atualizar o % valor de $R_p$ e $RTT_s$. No RCP, o valor de $RTT_s$ é calculado
% pelo sistema  final de origem, mas no GMTP, quando um nó \repassu{1} forma uma
% parceria co % outros nós \repass, é como se \repassu{1} funcionasse como o nó de
% origem \se vs % e portanto também deveria atualizar o valor para $RTT_s$. Para
% isto, um nó % \repasss precisaria manter estado para cada fluxo de dados \setpk,
% o que % significa manter um temporizador para cada fluxo de dados \setpks %
% compart lhado. Do ponto de vista computacional, delegar tal responsabil dade %
% para um roteador seria uma atividade onerosa porque múltiplos fluxo de dados, %
% originados por diversas fontes \serv, podem passar por um roteador e facilment %
% este se tornaria um ponto de gargalo por ter que processar cada pacote, ca cular
% e atualizar o valor para $RTT_s$ para cada um deles.
%
% Diante desta questão, no GMTP-UCC, em vez de um nó \repasss manter o
% temporizador para cada fluxo de dados \setpk, os nós relatores \rels, tal
% que \rels $\in$ \subsetcli$($\repass) são responsáveis por tal atividade. Isto
% significa que um cliente \cli=\rel, localizado na rede de \repass,
% realizará a computação para obter o valor de $RTT_s$, bastando o nó \repasss
% notificar qual nó \rels será responsável por manter tal estado. Isto só é
% possível porque quando um nó \repasssu{1} se torna parceiro de outro nó
% \repassu{2}, a condição $\mid$\subsetcli$($\repassu{1})$\mid$ $>$ $0$ é
% satisfeita para um fluxo de dados \setpk.

\subsubsection{Segmentação de um caminho \setwayi:}

O RCP considera todo o caminho entre o nó transmissor e o nó receptor para determinar o novo valor da taxa de transmissão do nó transmissor, especificado por $R(\hat{t})$ e atualizado a cada instante $H$ utilizando o novo valor medido de $R_{p}$ e $h_0$. Porém, essa estratégia pode limitar alguns nós \clis a receberem os pacotes de dados \pks $\in$ \setpks em uma taxa maior, quando disponível. Por exemplo, na Figura~\ref{fig:ccgmtp-interacao-2}, ilustra-se um cenário de transmissão abstraindo-se os nós \clis $\in$ \subsetcli$($\way$)$, ou seja, com apenas nós \repass. Nesse cenário, observa-se um caminho \setwayis $=$ $\{$\transu{1}, \wayu{2}, \transu{3}, \wayu{4}$\}$. Isto significa que existem nós \clis $\in$ $($\subsetcli(\transu{1}) $\cup$ \subsetcli(\transu{3})$)$ interessados em receber os pacotes de dados \pk. Ao utilizar apenas o RCP, o nó \servs transmitiria os pacotes de dados \pks a uma taxa de transmissão de \ut{1}{Mbps} tanto para os nós \clis $\in$ \subsetcli(\transu{1}) quanto para os nós \clis $\in$ \subsetcli(\transu{3}). Porém, isso faz sentido apenas para os nós \clis $\in$ \subsetcli(\transu{1}) e não para os nós \clis $\in$ \subsetcli(\transu{3}), visto que em \transu{3} o valor de $R(\hat{t})$ é igual a \ut{4}{Mbps} e o nó \wayu{4} não limita o uso dessa taxa de transmissão para os nós \clis $\in$ \subsetcli(\transu{3}), uma vez que em \wayu{4} o valor de $R(\hat{t})$ corresponde a \ut{8}{Mbps}.

\begin{figure}[htb!]
\begin{center}
\includegraphics[scale=0.625]{imgs/ccgmtp-interacao-2.pdf}
\end{center}
\vspace{-1cm}
\caption{O RCP utiliza uma abordagem fim-a-fim para determinar a taxa de transmissão de um nó, porém isto pode limitar alguns clientes a receberem os pacotes de dados em uma taxa maior. Nesse caso, o nó \transu{3} tinha capacidade para receber o conteúdo a uma taxa de transmissão de \ut{4}{Mbps}, porém a taxa de máxima relatada por \transu{1} é de \ut{1}{Mbps}, fazendo com que todos os nós no caminho \setwayis recebam o fluxo de dados \setpks a \ut{1}{Mbps}.}
\label{fig:ccgmtp-interacao-2}
\end{figure}

\begin{figure}[htb!]
\begin{center}
\includegraphics[scale=0.625]{imgs/ccgmtp-interacao-3.pdf}
\end{center}
\vspace{-1cm}
\caption{O GMTP-UCC segmenta o caminho e dessa forma não limita a taxa de transmissão de um nó capaz de receber um fluxo de dados em uma taxa de transmissão maior.}
\label{fig:ccgmtp-interacao-3}
\end{figure}

No caso do GMTP-UCC, decidiu-se determinar que se \transmitqu{\way} $=$ $1$, ou seja, \ways $=$ \transs $\in$ \settrans, então a taxa de transmissão informada em $R_{p}$ será utilizada por \way, porém não será considerada para determinar a taxa de transmissão do próximo nó \transu{\transi+1}. Sendo assim, considerando o mesmo exemplo ilustrado na Figura~\ref{fig:ccgmtp-interacao-2}, mas adotando essa estratégia de segmentar o caminho \setwayi, tal cenário corresponde ao ilustrado na Figura~\ref{fig:ccgmtp-interacao-3}. Note que, no sub-caminho \setwayidus{1} $=$ $\{$\transu{3}, \wayu{2}, \transu{1}$\}$, a taxa de transmissão de \transu{3} em direção a \transu{1} será de \ut{1}{Mbps}, ao passo que no sub-caminho \setwayidus{2} $=$ $\{$\servu{1}, \wayu{4}, \transu{3}$\}$ será de \ut{4}{Mbps}. Sendo assim, os nós \clis $\in$ \subsetcli(\transu{1}) receberão o fluxo de dados \setpks em uma taxa de \ut{1}{Mbps}, ao passo que os nós \clis $\in$ \subsetcli(\transu{3}) receberão
os pacotes de dados \pks a uma taxa de \ut{4}{Mbps}. Como resultado dessa estratégia e ainda considerando o exemplo em discussão, o nó \transu{3} deverá solicitar ao nó \servu{1}, o fluxo de dados \setpks com codificação compatível com a taxa de bits de \ut{1}{Mbps} ou inferior e então servir ao nó \transu{1}. A partir deste ponto, em teoria, o nó \transu{3} deve receber a mídia codificada em duas taxas de bits: \ut{1024}{Kbps} e \ut{3072}{Kbps}. Dessa forma, \transu{3} torna-se capaz de servir a outros nós \repasss tanto a uma taxa de \ut{1}{Mbps} quanto a uma taxa de \ut{4}{Mbps}.

Como discutiu-se na Seção~\ref{subsubsec:desc-conteudo}, o GMTP permite descrever a mídia em múltiplas codificações, ao mesmo tempo que os nós repassadores podem acessar tal informação para implementar a solução discutida anteriormente. Como resultado dessa estratégia, permite-se que a rede seja capaz de selecionar fluxos codificados pelo servidor de forma segmentada, de acordo com a capacidade de transmissão de sub-caminhos entre observados entre os nós repassadores e o servidor. Salienta-se que a decisão e as funções de adaptação da mídia é uma responsabilidade da aplicação servidora e está fora do escopo deste trabalho. Apesar disso, pode-se considerar o uso de estratégias avançadas para este propósito, como a apresentada em~\cite{Fernandes20111683}.

\subsubsection{Ordenação dos melhores caminhos com base em $R(\hat{t})$:}

Na Seção~\ref{subsec:phase3}, discutiu-se que na Fase 3 de conexão do GMTP, um nó \servs pode sugerir possíveis nós \repassu{q} como candidatos a parceiros de um nó solicitante \repass. O primeiro critério para sugerir nós parceiros \repassu{q} é priorizar os que fazem parte de um caminho \setwayis com maiores capacidade de transmissão. No GMTP, isto é possível porque os nós \servs conhecem a capacidade de transmissão de todo o caminho, inclusive os pontos onde se termina um sub-caminho e se inicia o subsequente, obtidos pelo Passo~\ref{item:gmtp-ucc-bottleneck-ack} do algoritmo GMTP-UCC.

Após o nó \servs selecionar um sub-conjunto de nós candidatos \repassu{q} e sugerir ao nó \repass, \repasss envia um pedido de interesse de recepção para obter um fluxo de dados \setpks aos nós \repassu{q}. O nó \repasss escolhe o(s) nó(s) \repassu{q} com base na capacidade de transmissão percebida entre este e cada \repassu{q} (na direção inversa). Nesse caso, cada nó \repassu{q} sugere ao nó \repasss o valor de $R_{p}$ atualmente entre \servs e \repassu{q}. Porém, até o pacote alcançar \repass, os nós \repasss intermediários podem atualizar o valor de $R_{p}$ devido ao Passo~\ref{step:rcp-gmtp-3} do algoritmo GMTP-UCC.

% ANTES: revisar a seção que fala sobre selecionar nós parceiros. Qd o servidor sugerir 
% roteadores parceiros para outro, pode-se medir a capacidade de transmissão com a estratégia apresentada baseada em RCP. FAZER UM APPEND NA SUBSUBSEC DA SEÇÃO DO UCC QUE FALA SOBRE SUGESTÃO DE PARCERIAS (Quando um roteador recebe a lista de parceiros, de tempos em tempos manda ack pra eles a fim de marcar as medições dos melhores caminhos)
% 
% ========

\subsubsection{Escolha do algoritmo RCP em detrimento ao TCP e ao XCP:}

A motivação para o RCP é identificar um algoritmo para controle de
congestionamento simples e prático para emular a capacidade de transmissão de um PS ($R_{ps}(\hat{t})$), independente da característica do tráfego e das condições da rede. A abordagem adotada no RCP é diferente se comparada ao TCP e ao XCP. No RCP, em vez de monitorar a mudança de uma janela deslizante a cada tempo de RTT, busca-se determinar se existe uma taxa de transmissão a qual o roteador pode oferecer para todos os fluxos de modo a emular um PS, sem manter estado e nem filas por fluxo de dados, tampouco computação por cada pacote no roteador. Tanto o RCP quanto o XCP são os protocolos mais conhecidos do estado da arte que tentam emular um PS
e, por este motivo, suas equações de controle de congestionamento são similares.
Porém, o modo que o RCP e o XCP tentam convergir suas respectivas taxas de
transmissão $R_{rcp}(\hat{t})$ e $R_{xcp}(\hat{t})$ é bastante diferente, alocando-se suas taxas para cada fluxo de dados a fim de emular $R_{ps}(\hat{t})$. Dessa forma, foi fundamental decidir qual dos dois protocolos seria mais adequado ao GMTP-UCC e, para tomar tal decisão, estudou-se as diferenças entre tais protocolos, com base no que se apresenta a seguir e detalhado em~\cite{Dukkipati:2008:RCP:1368746,Dukkipati:2005:PSF:2103175.2103204}.

Especificamente, a principal diferença entre o RCP e o XCP está no tipo de
informação enviada para um nó transmissor de um fluxo de dados para atualizar o
valor de $R_{rcp}(t)$ ou de $R_{xcp}(t)$. O XCP continuamente tenta convergir a
taxa de transmissão para um ponto de equilíbrio onde todos os transmissores
transmitirão pacotes de dados a uma taxa de transmissão $R_{xcp}(t)$, ao passo
que o RCP calcula uma única taxa de transmissão que deve ser utilizada por todos
os nós transmissores em um certo instante \textit{t}. Apesar dessa diferença
sucinta, deve-se entender o que isto significa.

No caso do XCP, o protocolo aumenta ou diminui a janela de congestionamento de
um fluxo de dados de acordo com o tamanho atual da sua janela de congestionamento. Isto significa que o XCP reduz gradativamente os tamanhos da
janela de congestionamento dos fluxos com $R_{xcp}(t)$ maior do que o
$R_{ps}(t)$ estimado, aumentando-se gradativamente o tamanho das janelas de
congestionamento dos fluxos com $R_{xcp}(t)$ menor do que $R_{ps}(t)$ estimado. Porém, como se sabe, o tamanho da janela de congestionamento é sempre menor para os fluxos iniciados mais recente. Assim, em qualquer momento, os fluxos XCP podem ter diferentes tamanhos de janela de congestionamento e de RTTs, portanto diferentes taxas de transmissão $R_{xcp}(t)$, resultando em valores para $R_{xcp}(t)$ não
equânimes para todos os fluxos de dados.

Para se ter uma visão mais adequada, nos gráficos da Figura~\ref{fig:xcp-vs-tcp-vs-ps}, compara-se o TCP e o XCP com um PS ideal com base em uma rede simulada, com taxa de entrada de pacotes de dados definida em \textit{Poisson} e tamanhos dos fluxos em distribuição \textit{Pareto}, com média de 30 pacotes (\ut{1000}{bytes/pacote}), \textit{shape} igual a $1.4$, capacidade do link igual a \ut{2.4}{Gbps} e RTT igual a \ut{100}{ms}, com carga ofertada igual a $0.9$. No gráfico da esquerda, ilustra-se o tempo médio de duração de um fluxo (quanto tempo o respectivo protocolo gasta para completar o fluxo) em função do tamanho do fluxo. No gráfico da direita, ilustra-se o número de fluxos ativos em função do tempo. Os valores de PS foram calculados a partir de expressões analíticas~\cite{Wolff1989} e mostram que os fluxos poderiam ser finalizados uma ordem de magnitude mais rápida do que o TCP.

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=0.29]{imgs/xcp-vs-tcp-vs-ps.png}
\end{center}
\vspace{-1cm}
\caption{No gráfico da esquerda, ilustra-se o tempo médio de duração (quanto tempo leva para finalizar o fluxo) de um fluxo versus o tamanho do fluxo utilizando o TCP e o XCP. No gráfico da direita, ilustra-se o número de fluxos ativos versus o tempo. Ambos os gráficos são resultados de simulações com chegada de fluxo em \textit{Poisson} e tamanhos do fluxo em distribuição \textit{Pareto} com média de 30 pacotes (\ut{1000}{bytes/pacote}), \textit{shape} igual a $1.4$, capacidade do \textit{enlace} igual a \ut{2.4}{Gbps} e RTT igual a \ut{100}{ms}, com carga ofertada igual a $0.9$. Os valores de PS foram calculados a partir de expressões analíticas. Extraído de~\cite{Dukkipati:2008:RCP:1368746}.}
\label{fig:xcp-vs-tcp-vs-ps}
\end{figure}

Com base nos gráficos da Figura~\ref{fig:xcp-vs-tcp-vs-ps}, observa-se que o TCP demora para finalizar os fluxos de dados porque se consomem múltiplos RTTs na fase de partida lenta para encontrar uma taxa de transmissão equânime. Além do mais, muitas vezes, o fluxo acaba antes que tal taxa seja encontrada. Em seguida, quando o fluxo TCP entra no modo de prevenção de congestionamento, o TCP adapta-se lentamente devido ao método de aumento aditivo, o que aumenta o tempo de finalização do fluxo. Além disso, o TCP deliberadamente preenche o \textit{buffer} dos roteadores saturados de modo a ajustar a taxa de transmissão com base nos descartes de pacotes, mas \textit{buffers} adicionais resulta em aumento no tempo (atraso) para entregar um pacote de dados, impactando no tempo total de duração de um fluxo. Já o XCP funciona melhor em redes com altos produtos largura de banda--atraso. Os roteadores disponibilizam para as fontes transmissoras relatórios sobre as mudanças da janela de congestionamento, enviados em múltiplos RTTs, que funcionam a contento apenas quando todos os fluxos são de longa duração. Por isso, em um ambiente dinâmico, o XCP pode aumentar a duração de cada fluxo em relação ao PS ideal, resultando em mais fluxos de dados em trânsito na rede em qualquer instante, principalmente os fluxos de curta duração.

Um outro exemplo comparativo e importante entre o RCP, XCP e TCP se observa na Figure~\ref{fig:rcp-vs-xcp-vs-tcp-sn}. Nesses gráficos, ilustram-se dois fluxos de tamanhos distintos, um considerado de curta duração (260 pacotes) e outro de longa duração (3600 pacotes). Nota-se que no primeiro gráfico o fluxo do TCP finalizou primeiro (enquanto ainda estava na fase de partida lenta) do que mesmo transmitido usando o XCP. Já no segundo gráfico, observa-se o impacto causado no TCP quando houve uma perda de pacote na fase de partida lenta, forçando-o a entrar na fase de AIMD, retardando a finalização do fluxo. Em ambos os casos, o RCP obteve um melhor desempenho se comparado ao TCP e ao XCP, porque o roteador oferece uma taxa de transmissão inicial muito próxima ao PS, sendo eficiente em rapidamente perceber largura de banda ociosa e que pode ser oferecida aos fluxos.

O XCP é lento em ofertar largura de banda para os fluxos, oferecendo uma baixa taxa de transmissão para os fluxos mais recentes. O XCP gradativamente reduz o tamanho da janela dos fluxos mais antigos e aumenta o tamanho da janela dos fluxos mais recentes, a fim de garantir que não ocorrerá super-utilização da largura de banda disponível. Por isso, gastam-se múltiplos RTTs para fazer com que a maioria dos fluxos alcancem uma taxa de transmissão equânime (que muda à medida que se iniciam novos fluxos na rede), mantendo-se uma baixa ocupação dos \textit{buffers} dos roteadores.

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=0.35]{imgs/rcp-vs-xcp-vs-tcp-sn.png}
\end{center}
\vspace{-1cm}
\caption{Evolução dos números de sequência de fluxos de dados, quando utilizando TCP (Reno), XCP e RCP. O tamanho do fluxo no primeiro gráfico foi de 230 pacotes, e no segundo gráfico foi de 3600 pacotes. Extraído de~\cite{Dukkipati:2008:RCP:1368746}.}
\label{fig:rcp-vs-xcp-vs-tcp-sn}
\end{figure}

Já no RCP, todos os fluxos (novos e antigos) recebem a mesma taxa de transmissão $R_{rcp}(t)$ baseada no estado atual do nó \repasss com menor largura de banda disponível em um certo instante $t$. Isto permite que um fluxo de dados de curta duração termine o mais rápido possível, ao passo que os fluxos de dados mais longos não influenciam diretamente no compartilhamento equânime do PS, sem permitir que parte da largura de banda disponível fique ociosa por muito tempo. Este procedimento ocorre em um intervalo de tempo definido por $H$ (vide Equação~\ref{eq:cc-rcp}). Isso ocorre ao preço de ocorrer uma super-utilização temporária do canal (quando ocorrer um aumento substancial no número de fluxos no intervalo menor do que $H$ -- \textit{flash crowd}), mas para fluxos de mídias ao vivo pode-se tolerar perdas circunstanciais.

Já ao observar o gráfico da Figura~\ref{fig:rcp-vs-xcp-vs-tcp}, percebe-se que a estratégia do RCP de compartilhar uma única taxa de transmissão para qualquer fluxo com base no estado atual do roteador saturado, produz um resultado satisfatório no que diz respeito à melhor utilização o canal de transmissão (seja quando em altos níveis de utilização quanto de ociosidade). Com base no gráfico, observa-se que, em comparação ao XCP e às soluções tradicionais, como o TCP, o RCP emula melhor um PS e por isso acompanha o tempo médio de finalização de um fluxo de dados à medida que se aumenta o tamanho do fluxo. Nesse contexto, observa-se que o XCP obteve um desempenho pior se comparado, inclusive, ao TCP.

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=0.33]{imgs/rcp-vs-xcp-vs-tcp.png}
\end{center}
\vspace{-1cm}
\caption{Tempo médio, em segundos, de finalização de um fluxo de dados, ao
utilizar os protocolos XCP, TCP e RCP como resultados de simulações com taxa de entrada de dados em \textit{Poisson} e tamanhos do fluxo em distribuição Pareto com média de 25 pacotes (\ut{1000}{bytes/pacote}), \textit{shape} igual a $1.2$, capacidade do link igual a \ut{2.4}{Gbps} e RTT igual a \ut{100}{ms}, com carga ofertada igual a $0.9$. Os valores de PS foram calculados a partir de expressões analíticas. Extraído de~\cite{Dukkipati:2008:RCP:1368746}.}
%  Os fluxos foram
% injetados na rede com base na distribuição pareto, com E[L] = \ut{25}{pacotes} e
% shape = 1.2.
\label{fig:rcp-vs-xcp-vs-tcp}
\end{figure}

O XCP é computacionalmente mais complexo do que o RCP, uma vez que o XCP define diferentes valores de \textit{feedback} para cada fluxo, envolvendo operações matemáticas (multiplicação e soma) para cada pacote, o que torna o XCP mais lento que o RCP. Pela estratégia de mudança no tamanho da janela de congestionamento, o XCP pode levar múltiplos RTTs para a maioria dos fluxos alcançarem a taxa de transmissão equânime entre eles, mas que mudam com o passar do tempo à medida que novos fluxos são injetados na rede e outros são finalizados, devido à natureza dinâmica das redes. No caso do RCP, essa complexidade é menor e há uma redução significativa na convergência entre a taxa de transmissão praticada $R_{rcp}(t)$ e a taxa estimada do PS
($R_{ps}(t)$). Isto porque se mantém uma única taxa de transmissão para todos os fluxos, não envolvendo qualquer computação adicional por pacote \pks que passa por \repass. Além disso, para determinar $R_{rcp}(t)$, utilizam-se apenas o tamanho da fila e a taxa agregada de entrada, sem necessitar manter estado por fluxo de dados e operações matemáticas por pacote de dados.

Desta forma, os aspectos que determinam o funcionamento do RCP são fundamentais quando se trata de transmissão de conteúdos multimídia ao vivo, aliado às outras estratégias adotadas no GMTP. O RCP define uma taxa de transmissão equânime para todos os fluxos, sua reação é rápida às mudanças circunstanciais na rede, tanto para uma super-utilização de um canal quanto para a sua sub-utilização. Como o RCP escala naturalmente com relação à capacidade de transmissão do canal e ao RTT, o seu desempenho é invariante com relação ao tamanho de um fluxo, portanto não importa qual tipo de fluxo as aplicações geram (se de curta ou de longa duração; independente de qualquer protocolo de transporte). Com isto, pode-se permitir que fluxos de dados GMTP/RCP e TCP/RCP coexistam na Internet de forma equânime, evitando-se também sobrecarregar os nós \serv através da função do GMTP de registro de participação. 

Apesar das observações anteriores, não é foco desse trabalho aprofundar as discussões acerca do desempenho do XCP comparado ao RCP, mas para não deixar a impressão de que o XCP sempre é ruim comparado ao TCP, ressalta-se que também há cenários onde o XCP tem um desempenho superior ao TCP, incluindo as variantes de \textit{High Speed} TCP. É possível observar um melhor desempenho do XCP quando se aumenta o tamanho médio de duração de um fluxo para se aproximar ao produto largura da banda -- atraso. Nesses casos, aproxima-se de um regime onde existem fluxos consumindo praticamente toda a largura de banda disponível de um canal, com o valor equânime da taxa de transmissão alocada individualmente para cada fluxo. Nesse tipo de cenário, o TCP-SACK apresenta vários problemas de desempenho, que foram aprimorados pelo HS-TCP~\cite{Dukkipati:2008:RCP:1368746}. Em todo caso, sabe-se que em cenários reais, o tamanho dos fluxos variam, existindo fluxos de curta e longa duração multiplexados a todo instante em um roteador. %(51:40m -> 3100s)

% ~\cite{4460574}. O artigo está na area de trabalho
% http://ieeexplore.ieee.org/xpl/login.jsp?tp=&arnumber=4460574&url=http%3A%2F%2Fi
% eeexplore.ieee.org%2Fiel5%2F90%2F4359146%2F04460574.pdf%3Farnumber%3D4460574

% Achieving efficient and fair bandwidth allocation while minimizing packet loss
% and bottleneck queue in high bandwidth-delay product networks has long been a
% daunting challenge. Existing end-to-end congestion control (e.g., TCP) and
% traditional congestion notification schemes (e.g., TCP+AQM/ECN) have significant
% limitations in achieving this goal. While the XCP protocol addresses this
% challenge, it requires multiple bits to encode the congestion-related
% information exchanged between routers and end-hosts. Unfortunately, there is no
% space in the IP header for these bits, and solving this problem involves a
% non-trivial and time-consuming standardization process. In this paper, we design
% and implement a simple, low-complexity protocol, called variable-structure
% congestion control protocol (VCP), that leverages only the existing two ECN bits
% for network congestion feedback, and yet achieves comparable performance to XCP,
% i.e., high utilization, negligible packet loss rate, low persistent queue
% length, and reasonable fairness. On the downside, VCP converges significantly
% slower to a fair allocation than XCP. We evaluate the performance of VCP using
% extensive ns2 simulations over a wide range of network scenarios and find that
% it significantly outperforms many recently-proposed TCP variants, such as HSTCP,
% FAST, CUBIC, etc. To gain insight into the behavior of VCP, we analyze a
% simplified fluid model and prove its global stability for the case of a single
% bottleneck shared by synchronous flows with identical round-trip times.



%
% =====>> PAREI AQUI. LER O ARQUIVO http://yuba.stanford.edu/rcp/RCP-IWQoS.pdf,
% SEÇÃO 2.2
%
% Rate Control Protocol (RCP) is a congestion control algorithm designed for fast
% download times (i.e. aka user response times, or flow-completion times). Whereas
% other modifications to TCP (e.g. STCP, Fast TCP, XCP) are designed to work for
% specialized applications that use long-lived flows (scientific applications and
% supercomputer centers), RCP is designed for the typical flows of typical users
% in the Internet today. For example, a mid-size flow in the Internet today
% contains 1000 packets and TCP typically makes them last 10x longer than need-be
% (XCP is even worse). RCP makes flows finish close to the minimum possible,
% leading to a perceptible improvement for web users, distributed computing, and
% distributed file-systems. We believe RCP is the only congestion control
% algorithm to do this.
% The main properties of RCP are:
%
% Typical Internet flows will see 10 times faster download times than TCP and 30
% times faster than XCP. Winners are the greater than 90% of sessions that never
% leave slow-start today.
% Efficiently uses high bandwidth-delay product networks such as the long haul
% optical links
% Provably stable network independent of link-capacities, round-trip times and
% number of flows
% Flows are easy to police, to ensure they adhere to congestion control (not
% generally possible with other schemes)
% Network operators can give preference (or weighted preference) to some
% flows/aggregates.
% RCP has two components: (1) End-host congestion control layer that sits between
% IP and TCP/UDP. During introduction, the end-host could adapt by testing for RCP
% at each end and along the path, falling back to TCP if need-be. (2) Each router
% maintains a single fair-share rate per link. Each packet carries the rate of the
% bottleneck link. For each packet, the router compares the two values. If the
% router's fair-share rate is smaller, it overwrites the value in the packet. This
% way, the source learns the fair-share rate of bottleneck link. It is simple,
% requires a very minor change to switches/routers and requires no per-flow
% state.

% \subsubsection{Considerações do GMTP-UCC em caminhos \setwayisfs e \setwayif}

% \subsubsection{Integração do GMTP-UCC com o ConEx}
%
% COMPARAR O GMTP AO TCP NO QUE DIZ RESPEITO COMO AS INFORMAÇÕES SÃO EXPOSTAS VIA
% CONEX.
%
% ========== REVER ===========
%
% No GMTP, os nós \repasss transmitem os vetores de ACKs para o seus nós \repasss
% parceiros e não para o nó \servs que origina o fluxo de dados \setpk. Esta é
% uma diferença considerável se o GMTP-UCC for comparado a qualquer variante do
% protocolo TCP, onde um sistema final transmite os pacotes de ACK para o sistema
% oposto e vice-versa. O ponto é o seguinte: sejam todos os caminhos \setwayis tal
% que um nó \repasss= \ways $\in$ \setwayi. No GMTP, um nó \ways enviará o vetor
% de ACKs apenas para seus nós parceiros \waysu{\wayi-1}. Essa estratégia é
% fundamental para uma transmissão de um fluxo de dados ao vivo que leva em
% consideração uma arquitetura P2P e o uso de um mecanismo para controle de
% congestionamento. Quando um nó \ways expõe o seu vetor de ACK apenas para seus
% nós parceiros \waysu{wayi-1}, permite-se uma regulação da taxa de transmissão
% específica apenas entre eles. Isto significa que o GMTP-UCC realiza controle
% de congestionamento regulando a taxa de transmissão entre dois nós \repass
% visinhos a fim de controlar apenas aquelas que estão envolvidos em um
% congestionamento. Com isto, evita-se o aumento ou a redução da taxa de
% transmissão de um fluxo \setpks para todo um caminho \setway, que ocorreria com
% o uso de algoritmos de congestionamento fim-a-fim, como os adotados no TCP.
% Consequentemente, o GMTP-UCC não sobrecarrega a rede com uma taxa de
% transmissão acima do esperado e também não sub-utiliza a rede com uma taxa de
% transmissão inferior a que a rede pode suportar.
%
% ============================
%
% Uma das funcionalidades do
% TCP é computar os pacotes que alcançam o sistema de destino, uma vez que se
% trata de um protocolo com suporte a garantia de entrega cujo mecanismo funciona
% com base na retransmissão de cada pacote perdido. No caso de protocolos como
% o \mudccp, a computação dos pacotes recebidos e perdidos pelo nó receptor é
% realizada pelo algoritmo de controle de congestionamento. No \mudccp-UCC,
% utiliza-se um mecanismo de vetores de ACKs, computado pelo nó receptor e
% transmitido para o nó transmissor, que então são repassados para o algoritmo
% Cubic a fim de definir a próxima taxa de transmissão. Os vetores de ACKs contém
% informações sobre pacotes perdidos ou pacotes marcados com ECN. Para maiores
% detalhes de como funciona o mecanismo de vetores de ACKs, o leitor pode
% consultar a RFC4341~\cite{RFC4341}.
%
%
% O ConEx é um protocolo que permite um nó remetente informar à rede sobre o
% congestionamento experimentado por pacotes anteriormente transmitindo em uma
% determinada transmissão de dados. No GMTP, especificamente no módulo
% GMTP-Inter, discutido na Seção~\ref{subsec:gmtp-intra-inter}, incorporou-se o
% ConEx para permitir que um nó \repasss possa obter as informações de
% congestionamento experimentada pelos seus nós \repasss parceiros. Com tais
% informações expostas aos nós \repass, é possível utilizá-las para realizar
% gerenciamento de tráfego, por exemplo.

% \subsubsection{Justificativa de uso do TCP-Cubic no GMTP}
%
% Por se tratar de um algoritmo já consolidado, decidiu-se omitir explicações
% detalhadas do funcionamento do algoritmo Cubic no \mudccp. Embora não será
% apresentada uma explicação detalhada do algoritmo TCP Cubic, considera-se de
% suma importância justificar os motivos que levaram a escolha do TCP Cubic para
% transmissões \textit{unicast} no \mudccp.
%
% O primeiro motivo está relacionado com os diversos resultados de pesquisas
% anteriores, incluindo uma série de resultados obtidos no contexto deste
% trabalho. Nos últimos anos diversas pesquisas científicas constataram a eficácia
% do TCP Cubic em termos da sua equidade para com outros fluxos TCP e, ao
% mesmo tempo, para com fluxos de dados TCP transmitidos utilizando outras
% variantes do TCP, como o TCP Vegas~\cite{Low:2002:UTV:506147.506152}, TCP
% HSTCP~\cite{RFC3649} e o recém lançado TCP Compound~\cite{4146841,5472999},
% utilizado na versão do sistema operacional Windows Vista em diante. O TCP Cubic
% não degrada os fluxos de dados transmitidos utilizando estas variantes do TCP e
% também não é degradado quando em disputa com fluxos de dados não-controlados,
% como os transmitidos utilizando o protocolo UDP.
%
% O segundo motivo é que o TCP Cubic tem sido utilizado pela maioria dos sistemas
% em execução na Internet da atualidade, uma vez que este é o algoritmo para
% controle de congestionamento utilizado por padrão para o sistema operacional
% Linux. Diante disto, desenvolver um protocolo cujo mecanismo para controle de
% congestionamento seja compatível com a maioria dos fluxos de dados é uma decisão
% primordial para o correto funcionamento e aproveitamento dos recursos de rede,
% em especial na Internet.

\subsection{Controle de congestionamento \textit{multicast}}
\label{subsec:mudccp-mcc}

Da mesma forma que no \mudccp-UCC, o objetivo principal do \mudccp-MCC é
determinar uma taxa de transmissão equânime entre os fluxos de dados
transmitidos pelo GMTP e por outros protocolos, como o TCP, porém
em modo de transmissão \textit{multicast}. No caso GMTP-MCC, trata-se de um algoritmo
responsável pelo controle de congestionamento em uma rede local constituída por
\net$_{local}$ = \repasss $\cup$ \subsetcli(\repass). Na prática, os nós da rede
\net$_{local}$ formam um grupo \textit{multicast} para a transmissão e recepção de um ou
mais fluxos de dados \setpk, onde o nó \repasss sempre será o transmissor e os
nós \clis $\in$ \subsetcli(\repass) os receptores. A estratégia é que o
valor a ser utilizado pelo GMTP-MCC para a taxa de transmissão de fluxo de dados
\setpks seja tão próximo ao valor da taxa de transmissão que o TCP usaria
se este fosse utilizado para transmitir \setpk, tornando-se o GMTP-MCC um
algoritmo \textit{TCP-Friendly}. Um fluxo de dados é considerado
\textit{TCP-Friendly} quando este não degrada a taxa de transmissão de um fluxo
de dados TCP mais do que outro fluxo TCP degradaria se começasse a ser
transmitido na rede.

O \mudccp-MCC foi inspirado em um protocolo publicado pela IETF chamado \textit{TCP-Friendly Rate Control protocol (TFRC)} (RFC 3448~\cite{RFC3448}). O TFRC é um mecanismo para controle de congestionamento de fluxos \textit{unicast} que tenta prever a taxa de transmissão de um fluxo TCP e utilizá-la em protocolos diferentes do TCP~\cite{CONG:Floyd00:TFRC:art}. Trata-se de uma abordagem diferente da utilizada em algoritmos baseados em janela deslizante e que utilizam pacotes de confirmação para determinar a taxa de transmissão de uma conexão, como acontece no TCP/NewReno. No TFRC, o receptor envia para o transmissor relatórios sobre as perdas observadas e, com base nesse relatório, o transmissor calcula a nova taxa de transmissão. O TFRC é categorizado com um protocolo de controle de congestionamento baseado em uma equação matemática
(\textit{Equation Based Congestion Control}) e algoritmos desse tipo são adotados em diversos protocolos, como no CCIDs 3 e 4 do DCCP~\cite{RFC4341,RFC4342}. Em resumo, o algoritmo TFRC funciona da seguinte forma:

\begin{enumerate}[{\tab}1$^{\circ}$]
 \item o receptor mede a taxa de perda de pacotes e a envia para o
nó transmissor;
 \item o nó transmissor usa esse relatório para medir o RTT até o
receptor;
 \item o nó transmissor utiliza a Equação~\ref{eq:trfcmudccp} para determinar
qual será a sua próxima taxa de transmissão em função do relatório de perdas e o
RTT obtidos;
 \item o nó transmissor ajusta sua taxa de transmissão para o valor
calculado no passo anterior.
\end{enumerate}

\begin{equation}
R(s,p) = \frac{s}{RTT \times \left(\sqrt{\frac{2 \times p}{3}} + \left(12 \times
\sqrt{\frac{3 \times p}{8}}\right) \times p \times (1 + 32 \times p^2)\right)}
\label{eq:trfcmudccp}
\end{equation}

\vspace{0.5cm}

Na Equação~\ref{eq:trfcmudccp}~\cite{Padhye98model}, $R(s,p)$ é a taxa de
transmissão medida em bytes/segundo definida em função de \textit{s}, que é o
tamanho do pacote medido em bytes e $p$, que corresponde a taxa de perda de
pacotes observado pelo nó receptor; $RTT$ é o tempo de ida-volta entre o nó
transmissor e o receptor, medido em segundos.

Apesar de ser uma estratégia interessante e funcionar em conexões \textit{unicast}, em transmissões \textit{multicast} o algoritmo descrito anteriormente não é eficiente. O algoritmo é limitado devido a um problema conhecido por \textit{explosão de confirmações} (\textit{feedback implosion}). Esse problema ocorre quando há muitos receptores enviando relatórios de perdas para o mesmo transmissor, o que resulta em uma inundação de relatórios, os quais o transmissor é incapaz de processar em tempo hábil.

Nesse contexto, para evitar o problema da \textit{explosão de confirmações}, determinou-se que apenas alguns nós \clis são obrigados a enviar tais relatórios ao nó \repass. Estes nós são chamados de relatores e
representados por \rel. No GMTP-MCC, a versão original do TFRC foi alterada e funciona da segunte forma:

\begin{enumerate}[{\tab}1$^{\circ}$]

  \item O nó \repasss executa um algoritmo de eleição de nós \rels
$\in$ \subsetcli(\repass). Na Seção~\ref{subsec:electrelsreps}, descreve-se o
procedimento para eleger os nós \rel.

  \item Os nós \rels calculam a taxa de transmissão utilizando a
Equação~\ref{eq:trfcmudccp}, em vez do transmissor realizar este cálculo,
como na versão original do TFRC;
  \label{step:gmtp-mcc2}

  \item Os nós \rels determinam a taxa de eventos de perda, e não todos os
receptores do grupo \textit{multicast}. Para calcular o evento de perda $p$, utiliza-se
o mesmo procedimento feito pelo TFRC, onde um intervalo de perda é determinado
por consecutivas perdas de pacotes, desde do primeiro pacote perdido até o
último pacote perdido, seguido de um pacote recebido com
sucesso~\cite{RFC3448,Padhye98model};

  \item O RTT é calculado entre o nó \rels e o nó \repass, com o temporizador controlado pelos nós \rels e não pelo nó \repass. Isto evita que o nó \repasss tenha que manter estado de temporizador para cada fluxo de dados \setpks transmitido para os nós \clis $\in$ \subsetcli(\repass). Para determinar o valor do parâmetro RTT e calcular a taxa de transmissão através da Equação~\ref{eq:trfcmudccp}, o GMTP-MCC utiliza a Equação~\ref{eq:calcrtt-rcp}, que também é utilizada no GMTP-UCC, porém com $\theta = 0.25$, valor igual ao utilizado no TCP e no DCCP;

  \item A taxa de transmissão a ser utilizada pelo nó \repasss é a média aritmética de todas as taxas enviadas pelos nós \rel;

  \item Repetem-se todos os passos a partir do passo~\ref{step:gmtp-mcc2} a cada intervalo igual ao RTT ou quando um intervalo de perda $p$ é determinado.

\end{enumerate}

Teoricamente, o GMTP-MCC seria um protocolo \textit{TCP-Friendly} se $R(s,p)$
fosse o valor máximo entre as taxas de transmissão relatadas pelos nós \rel.
Porém, optou-se por utilizar a média aritimética dos valores relatados pelos
nós \rels porque, na prática, diversos fatores podem alterar o estado da rede no
instante da transmissão usando o valor máximo da taxa de transmissão reportada
pelos nós \rel. Com esta decisão, define-se uma margem de segurança
evitando-se que o GMTP-MCC alcance o limite superior para o valor da taxa de
transmissão de um fluxo transmitido com TCP. Além disso, a média aritimética
suaviza os valores subsequentes para a taxa de transmissão a ser utilizada pelo
nó \repass.

Um aspecto importante na medição do RTT está relacionado com o início de uma
conexão GMTP, pois não se sabe o valor para inicial para RTT até o final do
processo de estabelecimento de uma conexão. Nesse caso, deve-se utilizar um
valor consideravelmente alto para evitar taxas de transmissões maiores do
que a rede tem capacidade de suportar. No GMTP, utiliza-se o valor inicial de
RTT igual a \ut{64}{ms}, que é um valor relativamente alto se considerar apenas redes locais em condições normais, que é o caso aqui. Quando um nó \clis envia um pedido de conexão utilizando o pacote do tipo \pac{GMTP-Request}, o mesmo deve realizar a sua primeira medição do valor de RTT, iniciando-se o marcador de tempo para o cálculo do RTT quando enviar o primeiro \pac{GMTP-Request} e parando-o quando receber o pacote do tipo \pac{GMTP-Response}. Em seguida, deve-se acionar o mecanismo de cálculo da taxa de transmissão através da Equação~\ref{eq:trfcmudccp}, caso o respectivo nó \clis seja eleito um relator.

% No caso do \mudccp-MCC, cada nó \rels
% agrega as perdas de pacotes que ocorrem dentro de um evento de perda, definido
% por uma ou mais perdas de pacotes no espaço de tempo de um RTT. Para o cálculo
% de $p$, utiliza-se a média dos tamanhos dos intervalos de perda, calculada
% através da média ponderada dos $m$ mais recentes intervalos de perdas $l_k,
% \dots, l_{k-m+1}$ seguindo a Equação~\ref{eq:losseventmean}. O conjunto de todos
% os intervalos de perda é chamado de \textit{histórico de perdas}.
%
% \begin{equation}
% l_{avg} = \frac{\sum_{i=0}^{m} w_i \times l_{k-i}}{\sum_{i=0}^{m} w_i}
% \label{eq:losseventmean}
% \end{equation}
%
% Os pesos $w_i$ são escolhidos de tal forma que os intervalos de perdas mais
% recentes recebem pesos mais altos, decrescendo-os gradualmente até $1$
% para os intervalos de perdas mais antigos. Por exemplo, para $8$ intervalos de
% perda $m$, pode-se utilizar os pesos $w = [5, 5, 5, 5, 4, 3, 2, 1]$. Ao
% utilizar-se da média ponderada para o cálculo da média dos tamanhos dos
% intervalos de perda, obtem-se mudanças mais suaves para o valor de $l_{avg}$ à
% medida que os tamanhos dos intervalos de perdas se tornam mais antigos. Para
% grandes valores de $m$, obtem-se mudanças mais suaves para $p$ ao longo do
% tempo, porém isto também reduz a capacidade de resposta e portanto a equidade do
% protocolo. No TFRC, recomenda-se utilizar valores de $m$ entre $8$ e $32$ e por
% este motivo no \mudccps é considerada esta recomendação. A
% Equação~\ref{eq:losseventmean} é definida na RFC 3448~\cite{RFC3448} e foi
% mantida no \mudccp. O protocolo DCCP também utiliza essa mesma abordagem no
% algoritmo de controle de congestionamento CCID-3~\cite{RFC4342}.
%
% Uma vez definido como determina-se a média dos tamanhos dos intervalos de
% perda, a taxa dos eventos de perda $p$ é definido pelo inverso de $l_{avg}$,
% definido na Equação~\ref{eq:losseventrate}. Como um intervalo de perda é
% definido em função do número de pacotes entre de eventos de perdas consecutidos,
% o mais recente evento de perda não pode influenciar na taxa do evento de perda,
% por isto utilizou a função \textit{max} no denominador da
% Equação~\ref{eq:losseventrate}.
%
% \begin{equation}
% p = \frac{1}{max(l_{avg}(k), l_{avg}(k-1))}
% \label{eq:losseventrate}
% \end{equation}
%
%
% Uma outra observação com relação ao ajuste da nova taxa de transmissão de $s_i$
% está relacionado ao fato de um nó $\hat{r}_i$ se desconectar ou perder
% repentinamente sua conexão. Caso isto aconteça com algum nó $\hat{r}_x$, seu
% valor $T_{\hat{r}_x}$ deverá ser desconsiderado no cálculo da nova taxa de
% transmissão $T_{s_{i}}$. Existem duas formas que um relay $s_i$ pode perceber a
% desconexão de um ou mais nós $\hat{r}_i$. A primeira forma é quando um nó
% $\hat{r}_x$ envia explicitamente um pedido de desconexão para $s_i$,
% tal processo é discutido na Seção~\ref{subsec:mudccp-desconexao}, ao passo que a
% segunda forma é quando um contador de tempo de manutenção de conexão, mantido
% pelo relay $s_i$ se expira, tal processo é discutido na
% Seção~\ref{subsec:electrelsreps}. Com esta medida, evita-se utilizar um taxa de
% transmissão $T_{s_{i}}$ incorreta, portanto não correr o risco de utilizar uma
% taxa de transmissão não condizente com o estado atual da rede.
%
% \subsection{Taxa de Eventos de Perda $p$}
% \label{subsec:mcclossevent}


% Para mais discussões acerca de como funciona o mecanismo para medição dos
% intervalos de perda, consulte a referência~\cite{CONG:Floyd00:TFRC:art}.

% Um aspecto importante no cálculo do valor de $p$ é determinar o seu valor
% inicial.

% \subsection{Cálculo do RTT}
% \label{subsec:mccrtt}
%
% O cálculo do RTT realizado no \mudccp-MCC é feito apenas pelos nós
% reporters e funciona da seguinte forma. Um nó $\hat{r}_i$ transmite ao seu
% respectivo relay $\hat{s}_i$ um pacote de controle e inicia um marcador de
% tempo. Ao receber uma resposta do nó relay $\hat{s}_i$, o nó reporter
% $\hat{r}_i$ pára o marcador de tempo e utiliza este tempo chamado de
% $RTT_{instant}$ para calcular o valor do próximo $RTT$ de acordo com a
% Equação~\ref{eq:calcrtt}.
%
% \begin{equation}
% RTT = \beta \times RTT_{instant} + (1 - \beta) \times RTT
% \label{eq:calcrtt}
% \end{equation}
%
% Note que no \mudccp-MCC não se utiliza o valor de $RTT$ instantâneo
% ($RTT_{instant}$) como o valor do $RTT$, mas sim utiliza-se de um mecanismo
% para suavizar as mudanças do $RTT$ ao longo do ciclo de vida de uma conexão.
% Desta forma, procura-se evitar que valores absurdos de $RTT_{instant}$ -- muito
% baixos ou muito altos com relação aos valores medidos anteriormente --
% influenciem demasiadamente na taxa de transmissão $T_{\hat{s}_i}$.
%
% O mecanismo mencionado anteriormente para suavizar as medições do valor de
% $RTT$ é chamado de Médias Móveis Exponencialmente Ponderadas ou
% \textit{Exponentially Weighted Moving Average} (EWMA). O EWMA foi primeiramente
% utilizado para índices financeiros de medição de risco, onde a série de retornos
% diários com $n$ observações é ponderada por um fator de decaimento. As
% observações mais recentes no tempo são ponderadas com um peso maior que as
% observações mais antigas. O peso de uma observação decai exponencialmente com
% $n$. Em seguida, utilizou-se EWMA em medições de tempo do $RTT$ em protocolos
% como o TCP. Como trata-se de uma estratégia conhecida para medição de RTT, no
% \mudccp-MCC manteve-se o mesmo mecanismo, principalmente por já ter sido
% exaustivamente testado e utilizado. Tanto no TCP quanto no caso do \mudccp,
% utiliza-se $\beta = 0.25$ para o cálculo do valor de $RTT$ através da
% Equação~\ref{eq:calcrtt}~\cite{kurose2006}.

% Porém, diferentemente do mecanismo de medição de $RTT$ no TCP e no TFRC, os nós
% reporters $\hat{r}_i$ são os responsáveis pela medição do $RTT$ e não o nó
% transmissor. Um aspecto importante na medição do RTT está relacionado com o
% início de uma conexão \mudccp, pois não se sabe o valor para $RTT_{instant}$
% até o final do processo de estabelecimento de uma conexão. Nesse caso, deve-se
% utilizar um valor consideravelmente alto para evitar taxas de transmissões
% $T_{\hat{s}_i}$ muito maiores do que a rede tem capacidade de suportar. No
% \mudccp, utiliza-se o valor inicial de $RTT_{instant}$ igual a \ut{150}{ms}.
% Quando um nó $\hat{r}_i$ enviar um pedido de conexão utilizando o pacote do tipo
% \mudccp-Request, o mesmo deve realizar a sua primeira medição do valor de
% $RTT_{instant}$, iniciando-se o marcador de tempo para o cálculo do RTT quando
% enviar o primeiro \mudccp-Request e parando-o quando receber o pacote do tipo
% \mudccp-Response. Em seguida, deve-se acionar o mecanismo de cálculo de
% $T_{\hat{r}_i}$, caso o respectivo nó $\hat{r}_i$ seja eleito como reporter.

% \subsubsection{Confirmação de recepção de \pk}
%
% O GMTP realiza confirmação de recepção de pacotes \pks para avaliar a
% capacidade de entrega e realizar controle de congestionamento.
%
% Nesse contexto, o GMTP é um protocolo orientado a mensagem, como o UDP e o DCCP,
% e não a cadeia de bytes, como é o caso do TCP. Dessa forma, a unidade básica de
% transporte no GMTP é um segmento completo e não cada byte individualmente. O
% tamanho de um segmento varia de acordo com o MTU (\textit{Maximum Transport
% Unit}) da rede, que em geral tem tamanho de \ut{1500}{bytes}, contando com o
% espaço ocupado pelo cabeçalho.
%
% Vetor de ACK \pac{GMTP-DataAck}

\section{Autenticidade de \setpk}
\label{sec:seguranca}

Em uma solução baseada em um modelo de serviço P2P, é possível que nós mal-intencionados \repasss poluam o sistema com conteúdos que não foram gerados pelo servidor.
%  (Figura~\ref{fig:bucket-brigade-principle-4}).
%
% \begin{figure}[ht]
% \begin{center}
% \includegraphics[natwidth=797,natheight=213,scale=.74]{imgs/bucket-brigade-principle-4.png}
% \end{center}
% \vspace{-0.8cm}
% \caption{Um nó \repasss mal-intencionados podem poluir o sistema com conteúdos
% que não foram gerados pelo nó \serv.}
% \label{fig:bucket-brigade-principle-4}
% \end{figure}
Para evitar esse tipo de ataque, executa-se um procedimento para verificar a autenticidade de um fluxo de dados \setpk. Para isto, os próprios nós \ways $\in$ \setwayis verificam se o conteúdo de um pacotes de dados \pks $\in$ \setpks foi alterado por algum nó \ways anterior durante o procedimento de repasse. Apenas após comprovar a autenticidade de um pacote \pk, o nó \ways repassa tal pacote de dados \pks para o próximo nó \wayu{\wayconst+1}, transmitindo-os também para seus nós \clis $\in$ \subsetcli$($\way$)$, se houver demanda. Este procedimento evita que todos os nós \clis que receberem o fluxo de dados \setpks tenham que verificar a autenticidade dos pacotes \pk, evitando-se que a rede repasse conteúdo multimídia errados, consequentemente não consumindo recursos computacionais desnecessários.

Na prática, o ideal seria que todos nós \ways verificassem a autenticidade de cada pacote \pk, porém, tal ação pode onerar os recursos computacionais de cada nó \ways e aumentar o tempo de entrega de \pks aos nós \clis $\in$ \subsetcli$($\way$)$. Isto porque os nós \ways também processam cada pacote de dados \pks para decidir sobre seu repasse e para executar os algoritmos de controle de congestionamento, como discutiu-se nas
Seções~\ref{sec:connformnet}, \ref{sec:asptransrecep} e~\ref{sec:ccgmtp}.

Para reduzir a sobrecarga de verificação de autenticidade de um fluxo de dados \setpks em cada nós \way, definiram-se duas regras, uma para decidir quais nós devem realizar a verificação de autenticidade (Regra 1) e a outra para determinar a quantidade de pacotes que se deve realizar tal procedimento
(Regra 2). Tais regras são definidas a seguir.

\begin{enumerate}

  \item apenas os nós \way, tal que \transmitqu{\way} = 1 devem realizar o
procedimento de verificação de autenticidade do fluxo de dados \setpk; e

  \item os nós \way, definidos pela Regra 1, não devem verificar todos os
pacotes \pks $\in$ \setpk, mas apenas uma quantidade $pc(t)$ de pacotes de dados
\pks $\in$ \setpk, em um instante $t$. Nesse caso, define-se
$pc(t)$, apresentada na Equação~\ref{eq:qtpxcheck}, em função de:

  \begin{itemize}

    \item $bs(t, \setpkc)$, o número de pacotes \pks $\in$ \setpks presentes no
\textit{buffer} de repasse de \ways em um instante $t$;

    \item $\frac{1}{\mid \setwayc^{\lhd}_{\setwayii} \mid -1}$, a probabilidade
de um nó \repasss $\in$ \setwayids ter alterado o conteúdo de um ou mais \pks
presente(s) no \textit{buffer} de repasse de \way, onde \setwayids $=$
\invert{$\delta(\wayconst_{\wayi+1}$, \setwayi$)$} e \setwayis é o caminho
através do qual se transmite os pacotes de dados \pks $\in$ \setpk;

  \end{itemize}

\end{enumerate}

\begin{equation}
pc(t) = \floor*{bs(t, \setpkc) \times \left(1 - \frac{1}{\mid
\setwayc^{\lhd}_{\setwayii} \mid -1}\right)}
\label{eq:qtpxcheck}
\end{equation}

\vspace{0.5cm}

Sendo assim, quanto mais distante um nó \ways estiver do nó \serv, mais pacotes \pks $\in$ \setpks devem ser verificados. Antes de entender o procedimento para verificar a autenticidade de um pacote \pks $\in$ \setpk, deve-se entender como o nó \servs gera os pacotes de dados para que seja possível verificar sua autenticidade.

\subsection{Transmissão e assinatura de autenticidade de \pks $\in$ \setpk}
\label{subsec:gerar-pacote-assinado}

Quando o nó \servs gerar cada pacote de dados \pks $\in$ \setpk, este deve
gerar uma assinatura digital dos dados da aplicação a serem transportados. Em
seguida, o nó \servs deve incluir a assinatura digital gerada no cabeçalho do
pacote de dados \pk, no campo assinatura (\textit{signature}). Para assinar
digitalmente o conteúdo da aplicação, utiliza-se o método de criptografia
assimétrica RSA, onde $K^{-}_{\servconst_{\servi}}$ e
$K^{+}_{\servconst_{\servi}}$ representam a chave privada e a chave pública de
\serv, respectivamente. No Trecho de Código~\ref{algo:digitalSignPacket},
apresenta-se o procedimento de assinatura de um pacote \pks $\in$ \setpks
adotado no GMTP, utilizando-se a mesma técnica apresentada
na Seção~\ref{sec:crypthashdigitalsign}.

\vspace{0.5cm}

\begin{algorithm}[H]
\label{algo:digitalSignPacket}
\caption{digitalSignPacket(\pk: \pac{GMTP-Data})}

\SetAlgoLined
\tcc{\servs executes this algorithm to digital sign the packet content using
its private key $K^{-}_{\servconst_{\servi}}$ and a pre-defined hash function,
such as the well-know md5 or sha1 function. \servs get the value of data field,
which is the content that application wants to transport and generates a
signature by encrypt the hash of the data using the \servs private key. After,
put the generated signature in the signature field of the packet \pk. The
signature field will be used later by a note \repasss to verify the packet \pks
authenticity executing the Algorithm~\ref{algo:verifyPacketAuthenticity}.}

\SetKwFunction{Union}{Union}\SetKwFunction{getPacketFieldValue}{getPacketFieldValue}
\SetKwFunction{Union}{Union}\SetKwFunction{setPacketFieldValue}{setPacketFieldValue}
\SetKwFunction{Union}{Union}\SetKwFunction{hash}{hash}
\SetKwFunction{Union}{Union}\SetKwFunction{encrypt}{encrypt}

\textit{data} \attrib \getPacketFieldValue{\pk, `data'}\;
\textit{hashValue} \attrib \hash{\textit{data}}\;
\textit{signature} \attrib \encrypt{$K^{-}_{\servconst_{\servi}}$,
\textit{hashValue}}\;
\setPacketFieldValue{\pk, `signature', \textit{signature}}\;
\Return{\pk}\;

\end{algorithm}
\vspace{0.8cm}

\subsection{Verificação de autenticidade de \pks $\in$ \setpk}
\label{subsec:verifyPacketAuthenticity}

Após definir as regras para verificação de autenticidade do fluxo de dados \setpks e a quantidade de pacotes $pc(t)$ que um nó \ways deve verificar, nesta seção discute-se como ocorre o procedimento de verificação de autenticidade de um ou mais pacotes de dados \pks $\in$ \setpk.

Dada a quantidade $pc(t)$ de pacotes que \ways deve verificar suas respectivas autenticidades, o nó \ways escolhe aleatoriamente (distribuição uniforme) os pacotes \pks disponíveis no \textit{buffer} de recepção, gerando um conjunto \setpk' $\subset$ \setpk. Uma vez definido \setpk', \ways executa o procedimento de verificação de autenticidade que funciona da seguinte forma. Para cada pacote \pks $\in$ \setpk', extrai-se a assinatura do pacote \pk, gerada pelo nó \serv, como explicado na Seção~\ref{subsec:gerar-pacote-assinado}. Em seguida, extrai-se o campo de dados para que se possa verificar sua autenticidade. Para isto, gera-se o valor de \textit{hash} do campo de dados e compara-se com o valor de \textit{hash} gerado pelo nó \servs no momento da transmissão do pacote \pk. Salienta-se que o valor de \textit{hash} gerado pelo nó \servs é obtido através do processo de decriptar a assinatura do pacote de dados \pks utilizando a chave pública do nó \serv. Assim, se o valor de \textit{hash} gerado com base no conteúdo transportado no pacote \pks for igual ao valor de \textit{hash} disponível na assinatura do pacote, conclui-se que o pacote \pks não foi alterado por nenhum nó \ways $\in$ \setwayids $=$ \invert{$\delta(\wayconst_{\wayi+1}$, \setwayi$)$}. Se o pacote de dados \pks não foi alterado, marca-o como aprovado para ser repassado, caso contrário, marca-o como desaprovado e deve ser descartado. No Trecho de Código~\ref{algo:verifyPacketAuthenticity}, apresenta-se o procedimento de verificação de autenticidade de um pacote \pks $\in$ \setpk.

\vspace{0.5cm}

\begin{algorithm}[H]
\label{algo:verifyPacketAuthenticity}
\caption{verifyPacketAuthenticity(\setpk': \textbf{array of} \pac{GMTP-Data})}

\SetAlgoLined
\tcc{\ways executes this Algorithm to check if the content of a subset of
packets \setpk' $\subset$ \setpks was modified. It marks each \pks $\in$ \setpk'
to be relayed or discarded. \ways uses the \servs public key to decrypt the \pks
signature and compares it to the hash value of the \pks content. It marks \pks
to be relayed if \pks content was not modified, otherwise it marks \pks to be
discarded, because \pks was modified by a node in \setwayids $=$
\invert{$\delta(\wayconst_{\wayi+1}$, \setwayi$)$}.}

\SetKwFunction{Union}{Union}\SetKwFunction{getPacketFieldValue}{getPacketFieldValue}
\SetKwFunction{Union}{Union}\SetKwFunction{GMTPResponse}{GMTPResponse}
\SetKwFunction{Union}{Union}\SetKwFunction{hash}{hash}
\SetKwFunction{Union}{Union}\SetKwFunction{decrypt}{decrypt}
\SetKwFunction{Union}{Union}\SetKwFunction{destroy}{destroy}

verifiedPackets \attrib \textbf{array of} boolean;

\ForEach{\pks $\in$ \setpk} {
  \textit{signature} \attrib \getPacketFieldValue{\pk, `signature'}\;
  \textit{data} \attrib \getPacketFieldValue{\pk, `data'}\;
  \textit{verifiedPackets[$x$]} \attrib $($\hash{\textit{data}} =
\decrypt{$K^{+}_{\servconst_{\servi}}$, \textit{signature}}$)$\;
}
\Return{\textit{verifiedPackets}}\;

\end{algorithm}
\vspace{0.8cm}


\subsection{Habilitar / desabilitar a validação de pacotes \pks $\in$ \setpk}

A função de verificação de autenticidade de um fluxo de dados \setpks do GMTP é opcional e desabilitada por padrão. Isto porque um sistema de transmissão, em execução na camada de aplicação, pode ou não desejar tal função. Por isso, considera-se que apenas o nó \servs tem o controle de habilitar tal funcionalidade, e este procedimento requer sinalizar os nós \ways para que estes executem o procedimento de verificação de autenticidade descrito na Seção~\ref{subsec:verifyPacketAuthenticity}. Para isto, o nó \servs ativa a opção assinado (\textit{signed}), disponível no pacote de dados \pac{GMTP-Register-Reply}, sinalizando que todos os pacotes de dados \pks $\in$ \setpks conterá a assinatura da porção de dados sendo transportados naquele pacote de dados, podendo ser verificado pelos nós \ways $\in$ \setwayi, desde que \transmitqu{\way} $=$ 1.

Quando um nó \clis $\in$ \subsetcli$($\repass$)$ solicitar um fluxo de dados \setpk, em resposta a tal pedido, o nó \repasss retornará um pacote do tipo \pac{GMTP-Request-Notify}. No cabeçalho desse pacote, o nó \repasss deve também ativar a opção \textit{assinado}, para que o nó \clis seja notificado e entenda que seu nó \repasss realizará a verificação de autenticidade do fluxo de dados \setpks da forma descrita anteriormente na Seção~\ref{subsec:verifyPacketAuthenticity}. Este procedimento permitirá que a aplicação em execução em \clis possa informar ao usuário final que tal funcionalidade está habilitada, por exemplo.

Além disso, como parâmetros de configuração, o usuário administrador do nó \repasss pode habilitar ou desabilitar a opção de verificação de autenticidade dos fluxos de dados \setpk, mesmo que o nó \servs possibilite tal verificação, como descrito anteriormente. Por fornecer essa função de verificação da porção de dados transportado em um pacote, no GMTP não se realiza checagem de erro por soma de verificação (\textit{checksum}), tal como em protocolos como TCP, UDP, DCCP e SCTP.

\subsection{Obtenção da chave pública $K^{+}_{\servconst_{\servi}}$ de \serv}
\label{subsec:obterchavepublica}

Um nó \repasss obtém a chave pública $K^{+}_{\servconst_{\servi}}$ de \servs através do certificado digital disponível na URI especificada no parâmetro \textit{f} da descrição da mídia, como ilustrou-se no Trecho de Código~\ref{algo:sdp-mediadesc}, Linha~\ref{line:sdp-mediadesc:f}, da Seção~\ref{subsubsec:desc-conteudo}. Isto ocorre após o nó \repasss receber o pacote \pac{GMTP-Register-Reply}, que confirma o registro de participação ou a conexão para obter um fluxo de dados \setpk, como apresentou-se no Trecho de Código~\ref{algo:registerRelay}, Linha~\ref{algo-line:respondToClients1}, Seção~\ref{subsec:registro-participacao}.

Após obter o referido certificado digital do nó \serv, o nó \repasss pode
realizar \textit{cache} do certificado, que pode ser utilizado quando os
próximos nós \clis realizarem outras requisições ao nó \serv, evitando
ter que obtê-lo a todo instante. De forma alternativa, o usuário administrador
do nó \repasss pode obter o arquivo de certificação digital do nó \repasss e
informá-lo, por meio de \textit{upload} nas configurações do nó \repass. Deve
ser opcional também para o usuário administrador do nó \repasss escolher se tal
nó deve ou não realizar \textit{cache} dos certificados digitais dos nós \serv.

%
% Para evitar esta situação, empregou-se no GMTP um mecanismo para validação do
% conteúdo de \pks antes que o mesmo seja transmitido para os nós \clis $\in$
% \subsetcli(\repass). Esta função é opcional no GMTP e funciona da forma
% apresentada a seguir.
%
% \begin{enumerate}
%  \item
% \end{enumerate}


\section{Outras Considerações}
\label{sec:outros-aspectos}

Nesta seção, apresentam-se brevemente outras funcionalidades do GMTP, tais como os canais de comunicação, eleição de relatores e procedimentos de desconexão e falha de um nó repassador.

% =========
%
%
% \subsection{Modos de Transmissão:}
% \label{subsec:tiposconexao}
%
% \begin{itemize}
%
%   \item \textbf{\textit{Unicast}:} ocorre em toda comunicação entre dois nós
% \textit{Repassadores GMTP}, com a interpretação do conceito definido por
% \textit{unicast} em sua forma tradicional no contexto de redes de
% computadores.
%
%   \item \textbf{\textit{Multi-unicast}:} é a combinação de dois ou mais
% fluxos de dados \textit{unicast}.
%
% \item \textbf{\textit{Multicast}:} ocorre em toda comunicação entre um nó
% \textit{Repassador GMTP} e seus respectivos \textit{Clientes GMTP}, com a
% interpretação do conceito definido por \textit{multicast} em sua forma
% tradicional no contexto de redes de computadores.
%
% \end{itemize}
%
% O modo \textit{multicast} sempre é utilizado para a transmissão dos datagramas
% correspondentes ao fluxo de dados multimídia. É mandatório que o modo
% \textit{multicast} seja utilizado para transmissões entre um nó
% \textit{Repassador GMTP} e seus \textit{Clientes GMTP} diretos. O modo
% \textit{unicast} é utilizado para que \textit{Clientes GMTP} estabeleçam uma
% conexão com um \textit{Servidor GMTP} ou um \textit{Repassador GMTP} e passe a
% distribuir o conteúdo de dados multimídia em sua rede local.
%
% =========



\subsection{Canais de comunicação}
\label{subsec:canaiscommudccp}

No GMTP, utilizam-se três canais de comunicação para executar suas
funcionalidades, o canal de controle, o de transmissão \textit{unicast} e o de
transmissão \textit{multicast}. A seguir, definem-se tais conceitos.

% (Figura~\ref{fig:canais-comunicacao}).
%
% \begin{figure}[ht]
% \begin{center}
% \includegraphics[scale=.86]{imgs/canais-comunicacao.pdf}
% \end{center}
% \vspace{-1cm}
% \caption{Canais de Comunicação do \mudccp.}
% \label{fig:canais-comunicacao}
% \end{figure}

\subsubsection{Canal de Controle:}

Quando um repassador iniciar uma instância do protocolo \mudccp, este deve
criar um \textit{socket} \textit{multicast} no endereço IP 238.255.255.250 e na porta $1900$, em
toda interface de rede local, ou seja, nas interfaces por onde se permite
acesso aos clientes. Através desse \textit{socket}, um nó GMTP é capaz de enviar e
receber pacotes de controle utilizados para negociar as funções de transmissão
de um determinado fluxo de dados de mídia ao vivo. Por exemplo, utiliza-se este
canal para permitir que um cliente envie pedidos de conexão e descobrir quais
fluxos de dados já estão sendo recebidos e qual canal \textit{multicast} cada um deles
está disponível.

A decisão do uso do endereço IP \textit{multicast} \textit{238.255.255.250} foi baseada
na RFCs 2365~\cite{RFC2365}, que define o escopo administrativo do uso dos
endereços \textit{multicast} entre 239.0.0.0 e 239.255.255.255. O endereço
\textit{238.255.255.250} é definido no escopo de uso global e sua alocação deve
ser confirmada pela IANA antes do uso massivo do GMTP na Internet.

\subsubsection{Canal de transmissão \textit{unicast}:}

O canal de controle e recepção \textit{unicast} é criado por todos os repassadores ao
iniciar uma instância do protocolo GMTP. Na prática, trata-se de um \textit{socket} que
os repassadores formam as devidas parcerias para transmitir os fluxos de
dados uns para os outros e, posteriormente, serem disseminados em
modo \textit{multicast} pelos respectivos repassadores aos seus clientes.

Do ponto de vista de roteamento, todo repassador deve avaliar os datagramas
GMTP e realizar as ações apropriadas, definidas nas próximas seções deste
capítulo. Por exemplo, no processo de estabelecimento de conexão, a ser
detalhado na Seção~\ref{subsec:conexao-requisicao}, ao processar um pacote GMTP
transmitido por um cliente, o repassador deve verificar se o pacote é do
tipo \pac{GMTP-Request} e, em caso positivo, deve-se retornar um pacote do tipo
\pac{GMTP-Response} ao cliente, se o fluxo de dados de interesse do nó
cliente especificado no pacote \pac{GMTP-Request} já estiver sendo recebido por
tal repassador.

% \subsubsection{Canal de Controle Unicast}
%
% Tal canal de controle é criado apenas entre os repassadores e relatores
% para troca de informações implementar as funcionalidades do protocolo, tais
% como
% procedimentos de estabelecimento de conexão, descoberta de nós e notificações
% de
% desconexões, eleição de nós relatores e envio e recebimento de relatórios para
% controle de congestionamento.

\subsubsection{Canal de repasse \textit{multicast}}

O canal de repasse \textit{multicast} é utilizado por um repassador para encaminhar datagramas vindos de um servidor ou de outro repassador para a rede local. Na prática, esse canal de repasse é um \textit{socket} \textit{multicast}, criado pelo repassador, para transmitir os datagramas para todos os seus clientes interessados por um evento ao vivo.

O \textit{socket de repasse multicast} deve ser criado quando um repassador começa a receber um determinado fluxo de dados correspondente a um evento de interesse de pelo menos um dos seus clientes. Na prática, quando isto acontece, o repassador deve criar um \textit{socket} \textit{multicast} em um endereço IP e número de porta
escolhida aleatoriamente na faixa de endereços IP de escopo local 239.192.0.0/14, definida na RFC 2365~\cite{RFC2365}. Como se trata de uma faixa de endereçamento IP \textit{multicast} de domínio local, não se faz necessário registrar o uso desses endereços. Isto significa que para todo fluxo de dado de um evento ao vivo, deve-se alocar um endereço IP e uma porta. No caso do esquema de endereçamento IPv4, será possível definir a transmissão de exatos 17.179.607.040 (dezessete bilhões, cento e setenta e nove milhões, seiscentos e sete mil e quarenta) diferentes fluxos de dados em uma rede local, o que é mais do que suficiente e escalável por vários séculos.


% \subsubsection{Canal de Recepção de Dados:}
%
% O canal de recepção de dados é um \textit{socket} \textit{multicast} criado por um
% cliente para receber um fluxo de dados transmitindo por um repassador em
% algum endereço IP da faixa 239.192.0.0/14. Alternativamente, um canal de
% recepção de dados será um \textit{socket} \textit{unicast} quando existir apenas um
% cliente em uma rede interessado por um fluxo de dados, utilizando-se o
% endereço da sua própria interface de rede local. O endereço IP e o
% número de porta que o cliente deve se conectar é determinado pelo nó
% repassador
% no momento da conexão.

% \subsection{Diagrama de Estados do GMTP}
%
% TBD

% \section{Fluxograma de Estados do \mudccp}
%
% Após o processo de estabelecimento de conexão do \mudccp, o protocolo entra no
% estado de transmissão de dados, se o nó for um servidor ou um relay, ao passo
% que o protocolo entra no estado de recepção de dados, se o nó for um cliente.
%
% Um servidor ou um relay começa a transmitir os dados após o processo de
% estabelecimento de conexão e até quando o fluxo de dados no servidor se
% encerrar ou quando o relay não desejar mais receber o fluxo de dados.
%
% =========


\subsection{Procedimentos para desconexão de nós \cli, \rels e \repass}
\label{subsec:desconexao}

% \begin{figure}[ht]
% \begin{center}
% \includegraphics[natwidth=797,natheight=173,scale=.73]{imgs/bucket-brigade-principle-3.png}
% \end{center}
% \vspace{-0.8cm}
% \caption{Um usuário pode desconectar e é preciso um mecanismo de tolerância à
% desconexão.}
% \label{fig:bucket-brigade-principle-3}
% \end{figure}
%
% \vspace{0.5cm}

O processo de finalização de uma conexão \mudccps ocorre com algumas
diferenças se comparado com outros protocolos orientados à conexão. Para
sinalizar uma desconexão, um nó \clis transmite um pacote do tipo
\pac{GMTP-Close} pelo canal de controle, contendo o nome do fluxo que deseja
se desconectar. Ao receber este tipo de pacote, o nó \repasss transmite ao nó
\clis um pacote do tipo \pac{GMTP-Reset}, sinalizando que está ciente do
fechamento da conexão. Nesse ínterim, os nós desalocam recursos relacionados à
respectiva conexão. Este procedimento é suficiente para o pedido de finalização
de uma conexão de um cliente \mudccp, porém para finalizar uma conexão de um nó
\rels e \repasss outros procedimentos são necessários.

\subsubsection{Desconexão de um nó \rel:}

Como apresentado na Seção~\ref{subsec:mudccp-mcc}, um nó \rels é responsável
por relatar ao nó \repasss as condições de recepção de pacotes \pks $\in$
\setpks em uma transmissão \textit{multicast} e assim determinar a taxa de transmissão
que deve ser utilizada para repassar o referido fluxo de dados. Sem os nós
\rel, tal procedimento não seria possível. Sendo assim, deve-se realizar um
procedimento para eleger um novo nó \rels quando um nó com tal responsabilidade
solicite desconexão. Os candidados a se tornar nó \rels são os nós \clis já
recebendo o fluxo de dados \setpk, sendo que o nó \rels em procedimento de
desconexão deve esperar que o procedimento de nova eleição seja concluído. Nesse
ínterim, o nó \rels em processo de desconexão deve continuar enviando pacotes
do tipo \pac{GMTP-Ack} para o nó \repass.

\subsubsection{Desconexão de um nó \repass:}

Um nó \repasss realiza o procedimento de desconexão não por intervenção da aplicação, mas sim quando \subsetcli(\repass) $=$ $0$ para um determinado fluxo de dados \setpk, ou quando o nó \servs explicitamente sinaliza a desconexão. Neste caso, pode ocorrer uma situação crítica para todos os nós parceiros \repassu{q} de \repass, pois teoricamente estes não poderão mais receber os pacotes de dados \pks $\in$ \setpk. Para evitar um período de instabilidade na recepção de \setpks por parte dos nós parceiros de \repass, define-se um parâmetro chamado de período de carência para novas parcerias (\textit{grace period for new partnerships}). Trata-se de um parâmetro que determina o tempo em que um nó \repass, em processo de desconexão, continuará repassando o fluxo de dados \setpks para seus parceiros \repassu{q}.

O valor para o \textit{período de carência para novas parcerias} é transmitido
para os nós parceiros \repassu{q} de \repass, que por sua vez deve iniciar o
procedimento de realizar outras parcerias a fim de continuar recebendo o fluxo
de dados \setpks (Fase 3 do procedimento de conexão do GMTP). Opcionalmente, um
nó \repasss pode aceitar receber de seus nós parceiros \repassu{q}, o valor
para o período de carência, desde que não ultrapasse um limite máximo definido
pelo administrador de \repass.

% \subsubsection{Falha de um nó \repass}
%
% \begin{figure}[ht]
% \begin{center}
% \includegraphics[scale=.5]{imgs/esquema-abstrato-formacao-parceria-intra-falha.pdf}
% \end{center}
% \vspace{-0.8cm}
% \caption{Cenário de falha do nó \repassu{6} em um caminho \setwayiu{1}, seguida
% de constituição de um novo caminho \setwayiu{3} formado pelo procedimento de
% formação de parceria intra \setwayi.}
% \label{fig:esquema-abstrato-formacao-parceria-intra-falha}
% \end{figure}
%
% Além da desconexão explícita de um nó \repass, uma ação específica deve ser
% realizada se um nó \ways $\in$ \setwayis circunstancialmente falhar. Para tratar
% estes casos, definiu-se que o nó \repasss pode formar parcerias com os próprios
% nós \repasss $\in$ \setwayid, tal que \setwayid\space $=$
% \invert{$\delta($\wayu{\wayi+1}, \setwayi$)$}, através
% de uma outra rota de rede que também alcance o nó \servs -- isto pode acontecer
% devido à execução de algoritmos de roteamento dinâmico \textit{Intra-AS
% (Autonomous Systems)}, por exemplo, o OSPF, e \textit{Inter-AS}, por exemplo, o
% BGP~\cite{kurose2006}.
%
% Para entender o comportamento do GMTP em caso de falha de um nó \repass,
% observe a Figura~\ref{fig:esquema-abstrato-formacao-parceria-intra-falha}. Se o
% nó \repassu{6} falhar e o nó \repassu{14} também estiver repassando \setpk, uma
% nova parceria é formada transparentemente entre o nó \repassu{7} e o nó
% \repassu{14}. Isto porque o nó \repassu{14} interceptará os pacotes de controle
% de \textit{keep-aline} que o nó \repassu{7} está transmitindo para o nó \serv.
% Mas, pode acontecer o caso de que \transmitru{14} $ = 0$ e \transmitru{13} $ =
% 0$ para o fluxo de dados \setpk, portanto o pedido de conexão enviado pelo nó
% \repassu{9} alcançará o nó \servu{1} como antes. Isto resultará na constituição
% de um novo caminho \setwayiu{3} $=$ \setwayidu{1} $\cup$ \setwayidu{2}, tal que
% \setwayidu{1} $=$ \invert{$\delta($\repassu{6}, \setwayiu{1}$)$} e \setwayidu{2}
% $=$ $\delta($\invert{\setwayiu{2}}, \repassu{15}$)$. Isto fará com que todo o
% caminho \setwayiu{3} repasse o fluxo de dados \setpk. Como consequência,
% aumenta-se a possibilidade de parcerias futuras com nós \repasss cujo pedido de
% conexão para obter \setpks seja roteado pelo caminho \setwayiu{3}. Para este
% caso, criou-se o procedimento de formação de parceria por intersecção de
% caminhos \setwayi, detalhado mais adiante.
%
% Na Seção~\ref{subsec:desconexao}, apresenta-se uma discussão geral sobre o
% comportamento do GMTP em outros casos de desconexões. O procedimento de formação
% de parceria intra \setwayi, apresentado nesta seção, está intimamente
% relacionado com o processo de estabelecimento de conexão do GMTP, detalhado mais
% adiante na Seção~\ref{subsec:conexao-requisicao}.

\subsection{Eleição de nós \rel}
\label{subsec:electrelsreps}

Para um fluxo de dados \setpk, o primeiro nó \rels será o nó \clis que iniciar a
primeira conexão para obter o referido fluxo. Os seguintes nós \rels serão os
próximos nós \clis que se conectar para receber o fluxo de dados \setpk, até
atingir um parâmetro que determinará a quantidade máxima de nós \rels por fluxo
de dados \setpk. Tal parâmetro pode ser determinado pelo administrador do nó
\repass. Por padrão, utiliza-se $\frac{1}{6}$ dos nós \clis $\in$
\subsetcli$($\repass$)$ como sendo relatores para a transmissão de um fluxo
de dados \setpk.

Sendo assim, à medida que um nó \repasss recebe pacotes do tipo
\pac{GMTP-Request}, no pacote de resposta \pac{GMTP-Response}, o nó
\repasss ativa um indicador sinalizando que o referido nó \clis em processo de
conexão deverá se comportar como um nó \rel, passando a enviar relatórios
da taxa de transmissão calculada, como discutiu-se na
Seção~\ref{subsec:mudccp-mcc}.

% Note que este modo de transmissão deve
% ser implementado com garantia de entrega, ou seja, com a confirmação de recepção
% de pacotes e retransmissão caso este tipo de pacote seja perdido. Assim, um nó
% \repasss poderá ter controle sobre a quantidade de nós \rels e receber
% relatórios apenas dos nós \rels $\in$ \setrel.

Uma outra situação que se faz necessária a eleição de nós \rels é no
procedimento de desconexão, como explicado na Seção~\ref{subsec:desconexao}.
Para esse caso, quando o nó \repasss receber o pacote do tipo
\pac{GMTP-Close}, este deve verificar se o referido nó \clis é um nó \rel. Em
caso afirmativo, o nó \repasss deve transmitir para um dos nós \clis que
também recebe o referido fluxo de dados \setpks (se houver), um pacote do tipo
\pac{GMTP-Elect-Request} e aguardar por um \pac{GMTP-Elect-Response}. Este procedimento
deve ocorrer com garantia de entrega.






% Ao \mudccps foi incorporado um mecanismo de tolerância a desconexão que
% funciona de modo a evitar que os clientes deixem de receber dados da
% transmissão em questão, caso um nó relay desconecte repentinamente sem conseguir
% transmitir um pacote do tipo \mudccp-ElectAck, tal como explicado na
% Seção~\ref{subsec:mudccp-desconexao}. Considere $T$ uma variável corresponde a
% $4$ vezes o valor do tempo do RTT. Um nó relay deve transmitir no canal de
% controle um pacote do tipo \mudccp-AdvConn a cada instante de $T$, anunciando
% aos demais nós da rede que está ativo e operando corretamente. Caso um nó relay
% secundário não receba o pacote do tipo \mudccp-AdvConn durante o período de
% tempo $T$, assume-se que o relay atual foi desconectado por algum motivo
% desconhecido e o relay secundário que não recebeu o pacote do tipo
% \mudccp-AdvConn deverá transmitir um pacote do tipo \mudccp-ElectAck. Na
% prática, o nó relay secundário torna-se um nó relay primário do o grupo de
% clientes, incluindo os nós reporters, conectados ao relay que foi desconectado.
% Neste caso, o novo nó relay deve iniciar um novo processo de estabelecimento de
% conexão. Após o estabelecimento dessa conexão, como descritos na
% Seção~\ref{sec:conexaomudccp}, o novo nó relay deve criar o canal de repasse e
% começa a repassar os dados da transmissão multimídia.


% \subsection{Adaptação de Fluxo de Dados}
% \label{subsec:adapt-flow}
%
% \begin{figure}[ht]
% \begin{center}
% \includegraphics[natwidth=794,natheight=170,scale=.73]{imgs/bucket-brigade-principle-2.png}
% \end{center}
% \vspace{-0.8cm}
% \caption{Uma aplicação pode não ter recurso suficiente, adaptações devem ser realizadas.}
% \label{fig:bucket-brigade-principle-2}
% \end{figure}
%
%
% Uma funcionalidade peculiar do \mudccps é sua capacidade de permitir a
% realização de adaptação de fluxos multimídia de forma distribuída. A maioria
% das soluções para transmissão de dados multimídia, além de realizar controle
% de congestionamento em nível de aplicação, realizam adaptação de fluxo
% multimídia na fonte geradora dos dados. Em diversas soluções
% existentes, os autores consideram a transmissão de fluxos de dados multimídia
% adaptados e transmitidos em diferentes canais, sendo que em cada canal
% transmite-se os fluxos multimídia em uma determinada qualidade. Dependendo da
% qualidade desejada pelo nó receptor, o sistema cliente solicita a transmissão em
% um determinado canal. O problema dessa abordagem é que o nó transmissor,
% necessariamente deve transmitir os dados em múltiplos canais, o que aumenta a
% complexidade da aplicação e a quantidade de fluxos de dados sendo transmitidos a
% partir do servidor.
%
% No \mudccp, é possível realizar a adaptação de fluxo de dados de forma
% distribuída, na prática, em cada relay. Por exemplo, considere duas redes
% adjacentes, rede 1 e rede 2. Considere que existe um nó relay na rede 1 e entre
% a rede 1 e o nó transmissor a largura de banda de transmissão disponível seja de
% \ut{100}{Mbps}. Caso a largura de banda disponível na rede 2 seja de no
% máximo \ut{10}{Mbps}, um nó receptor na rede 2 teria que solicitar um fluxo
% multimídia em um canal diferente, considerando as soluções que adotam a
% estratégia de adaptação de fluxo com o uso de múltiplos canais de transmissão.
% No caso do \mudccps é possível que um nó na rede 2 obtenha o fluxo multimídia
% através do relay presente na rede 1, com o relay da rede 1 adaptando o fluxo
% multimídia de acordo com a capacidade do canal de transmissão disponível para a
% rede 2. Desta forma, pode-se diminuir o tráfego na rede do nó transmissor e
% ainda permitir que nós em redes com largura de banda limitada consigam obter o
% fluxo multimídia adaptado (caso mais comum para clientes residenciais).
%
%
%
%
%
%
%
%
%
%
% Com essa estratégia, fica óbvio que quanto mais requisições de
% \textit{pull} por uma parte da mídia, mais urgente é o seu conteúdo para
% reprodução. Muitas requisições via \textit{pulling} é um sinal que a rede não
% está sendo capaz de entregar \pks tão rápido quanto o suficiente para permitir
% a reprodução sem que haja interrupções. Essa informação pode ser utilizada para
% adaptar o fluxo de dados \setpk, reduzindo-se sua qualidade e consequentemente
% exigindo menos da rede.
%
%
%
%
%

% \section{Implemetação e Implantação}
% \label{sec:impl}
%
% PROVER API PARA SETAR AS INFOS DO SDP
%
% O \mudccp\space não necessita explicitamente da instalação de um nó na rede para
% encaminhar o conteúdo de uma rede externa para uma rede interna
% (\textit{proxy}). Além disso, o \mudccp\space mantém a \textit{interface} de
% programação com a camada de aplicação inalterada, apenas adicionando uma
% extensão na API padrão de \textit{socket} BSD para preservar a compatibilidade
% com as aplicações multimídia existentes e, ao mesmo tempo, permitir que as
% aplicações façam uso dos novos recursos do \mudccp. Esta decisão pode ajudar em
% uma rápida adoção do GMTP nas aplicações multimídia, permitindo-se simples
% alterações das aplicações existentes e, ao mesmo tempo, a efetiva padronização
% da forma como algumas funcionalidades hoje em dia são implementadas.


% \section{Benefícios, Aplicabilidade e Justificativas}
% \label{sec:benef}


%\subsection{Seleção de Parceiros e de \textit{Chunks}}

% \subsection{Balanceamento de Carga}
%
% Um outro aspecto interessante do protocolo \mudccps é sua capacidade em
% permitir divisão de carga entre nós relays. Como os nós relays recebem e
% repassam os fluxos de dados oriundos de um servidor, obtem-se natualmente uma
% solução de distribuição de conteúdo multimídia sem sobrecarregar a fonte
% geradora de dados (geralmente o servidor). Porém, mesmo considerando o
% mecanismo atualmente empregado no \mudccps para divisão de carga entre nós
% relays, atualmente estuda-se um mecanismo complementar de balanceamento de
% carga a fim de evitar que os nós relays entre em colapso de congestionamento
% devido ao grande número de clientes conectados a um determinado nó relay.
%
% Considerando isso, está em estudo no contexto do protocolo \mudccps um
% mecanismo
% de balanceamento de carga que quando um nó relay possui muitas conexões de
% clientes permite-se que outro cliente seja... PROBLEMA: UM RELAY POR REDE!


% \subsection{Outra Estratégia para Descoberta de Nós Relays}
% \label{sec:arcdescorels}
%
% Um aspecto primordial do \mudccps é a capacidade de obter fluxos de
% dados multimídia através de nós relays, os quais repassam esses dados vindo de
% uma fonte geradora. No processo de conexão, esses nós relays são encontrados,
% aceitam conexões de clientes e repassam dados da aplicação como se fossem o
% servidor. Um gargalo no procedimento padrão adotado no \mudccps é que pode-se
% demorar até que um cliente \mudccps encontre um nó relay e comece a receber o
% fluxo de dados desejado devido ao mecanismo de busca por profundidade por nós
% relays utilizando transmissões \textit{multicast}, utilizando-se valores incrementais
% para o campo de TTL presente no cabeçalho IP.
%
% Diante disso, está em estudo no contexto desse trabalho um mecanismo alternativo
% para permitir que um cliente encontre um nó relay mais rapidamente. Este
% mecanismo consiste em permitir que um cliente solicite diretamente ao nó
% servidor a lista de nós relays conectados a ele, ou seja, a lista dos nós
% relays de primeiro nível (Figura~\ref{fig:cenario-global-detailed}).
%
% O mecanismo de busca por nós relays permitirá que o cliente consulte, ao longo
% dos níveis dos nós relays, aquele nó relay que mais se adequa aos requisitos da
% aplicação, principalmente com relação ao atraso observado desde do servidor até
% um determinado relay. Um cliente que desejar solicitar esse tipo de
% requisição, utiliza o pacote do tipo \mudccp-RelayQuery e transmite o pedido de
% consulta ao servidor, o qual responde ao cliente com a lista dos nós relays
% de primeiro nível utilizando o pacote do tipo \mudccp-RelayReply. Com isto, é
% possível encontrar um melhor relay cujo atraso não ultrapasse um determinado
% limiar de tempo definido pela aplicação, o que não necessariamente será o nó
% relay mais próximo geograficamente do cliente.



% , dentre
% outros referenciados em~\cite{REF, REF, REF, REF, REF}.

% discutir aqui sobre o que o protocolo trás de bom para as aplicações
%
% - cloud computing
%
% - transmissão de casa
%
% - vod
%
% - youtube/copa america
%
% - twitcam

% \section{Outros Aspectos Importantes do \mudccp}
%
% \subsubsection{Uso do Campo \textit{Offset} de Dados}
%
% \subsubsection{Uso do Campo \textit{CCVal} de Dados}
%
% \subsubsection{Soma de Verificação e Validação de Pacotes}
%
% \subsection{Compatibilidade com outras recomendação da IETF}
%
% - NAT - http://www.brynosaurus.com/pub/net/p2pnat/
% - 4340
% - GERAÇÃO DO NÚMERO DE SEQUÊNCIA
% - RFC2365
% - RFC4086
% - RFC2119
% - TFMCC 4654
% - 5166
% - TFRC 3448

%\section{Considerações sobre redes de distribuição de conteúdo}

%\section{Considerações sobre a escolha do DCCP como base para o \mudccp}

\section{Sumário do Capítulo}
\label{sec:sumario-gmtp}

Neste capítulo, apresentou-se o \textit{Global Media Transmission Protocol} (\mudccp), um protocolo baseado em uma arquitetura híbrida P2P/CDN para distribuição de mídias ao vivo através da Internet. Para viabilizar a distribuição de um fluxo de dados, uma aplicação obtém o conteúdo e requisita sua transmissão ao protocolo GMTP, por meio de uma API \textit{socket}. Para disseminar o conteúdo da aplicação, o GMTP utiliza servidores dispostos em uma rede CDN e constitui dinamicamente uma rede P2P, formada pelos roteadores localizados entre os clientes interessados em obter o fluxo de dados multimídia e os servidores da CDN. Para isto, os roteadores expressam interesse em participar da rede ao realizarem registros de participação (previamente ou sob-demanda) em um ou mais servidores, ao passo que os servidores começam a conhecer todas as possíveis rotas para alcançar os clientes.

Quando um cliente requisita um fluxo de dados a um servidor, seu roteador de borda, participante da rede P2P, assume a responsabilidade de obter o fluxo de dados de interesse. Nesse ínterim, o roteador do cliente transmite um pedido ao servidor e receber como resposta os pacotes de dados referentes à mídia de interesse (em modo \textit{unicast/push}). À medida que transmissões diretas (servidor $\rightarrow$ cliente) ocorrem, os roteadores presentes nas rotas entre o servidor e os clientes vão sendo ``alimentados'' pelos pacotes de dados referentes à mídia em questão, ao passo que os roteadores intermediários interceptam os mesmos pacotes de dados quando seus clientes locais também têm interesse pela mesma mídia. Isso habilita o conceito de sub-fluxo.

Os roteadores formam parcerias entre si, diretamente por interceptação de pacotes de dados ou com base em instruções obtidas através dos servidores, que executam um algoritmo para determinar a intersecção de rotas usadas por outros roteadores para obter o mesmo fluxo a partir do servidor. Isto ocorre quando o servidor detecta pontos comuns nas rotas e, em vez de aceitar um novo pedido de conexão de um nó solicitante em obter o fluxo de dados, recusa-o e sugere ao nó solicitante uma lista de roteadores candidatos a parceiros, de modo a evitar múltiplas conexões em direção ao servidor. Um roteador pode também solicitar explicitamente uma lista de candidatos a parceiros a fim de obter mais rapidamente os pacotes de dados e, secundariamente, conhecer outros roteadores e contata-los em caso de desconexões dos seus parceiros atuais.

A distribuição do conteúdo em uma rede local sempre ocorre em modo \textit{multicast}. Para isto, o roteador cria dinamicamente canais \textit{multicast} e os divulga na rede à medida que recebem pedidos de conexão para obter fluxos de dados que já estão sendo recebidos. Sendo assim, não se transmite mais de um pedido de conexão ao servidor para uma mesma mídia, partindo da mesma rede. O GMTP executa três fases de conexão. A primeira fase de conexão ocorre quando o primeiro nó em uma rede local solicita receber um determinado fluxo de dados; a segunda fase ocorre através do compartilhamento dos pacotes de dados de um fluxo em modo \textit{multicast}; e a terceira fase permite que os roteadores aumentem suas parcerias.

Em seguida, discutiu-se sobre a estratégia para realizar controle de congestionamento durante o processo de disseminação de uma mídia ao vivo. Nesse contexto, propõe-se dois algoritmos. O GMTP-UCC tem como objetivo controlar o congestionamento no núcleo da rede P2P, além de expor as informações de seu estado aos servidores. Os servidores podem utilizar tal informação para adaptar o conteúdo multimídia de acordo com a capacidade de transmissão da rede, que sempre tende a ser próxima da capacidade de um PS. Além disso, o algoritmo GMTP-UCC pode auxiliar os nós receptores a selecionarem os melhores parceiros de acordo com a capacidade de transmissão do canal entre os receptores e os transmissores. Já o GMTP-MCC tem como objetivo controlar o congestionamento na rede local, em transmissões dos fluxos de dados \textit{multicast}. O roteador elege um sub-conjunto de clientes (relatores) responsáveis por enviar relatórios de suas respectivas capacidade de recepção de dados, ao passo que o roteador define a próxima taxa de transmissão com base nesses relatórios. Por utilizar uma estratégia adaptada do TFRC, o GMTP-MCC emula a taxa de transmissão que seria utilizada pelo TCP caso este fosse utilizado para transmitir o fluxo de dados, tornando o GMTP um protocolo TCP-Friendly.

Por fim, discutiram-se aspectos sobre segurança e os métodos empregados no GMTP para evitar ataques de poluição. O mecanismo de segurança do GMTP permite que os servidores assinem digitalmente os dados transmitidos, ao passo que se permite aos repassadores validarem se tal conteúdo não foi alterado ao longo do caminho entre o servidor e os diversos clientes. Além disso, discutiram-se outros aspectos relacionados ao GMTP, como as ações realizadas na desconexão dos repassadores, relatores e clientes, bem como a eleição de relatores.

As definições das funções do GMTP foram propostas com base em investigações dos trabalhos disponíveis no estado da arte e guiadas por questionamentos sobre quais funções se mostraram eficazes ao longo de 15 anos de pesquisa quando aplicadas em sistemas P2P e P2P/CDN, bem como aquelas que podem ser aprimoradas (ou ainda, aquelas que fazem sentido manter na camada de aplicação). Com esta visão, decidiu-se reduzir as responsabilidades dos clientes e aumentar a responsabilidade dos roteadores de rede no processo de disseminação dos pacotes de dados multimídia, fazendo uso de informações mais precisas sobre a capacidade de transmissão do núcleo da rede e abstraindo-se a complexidade desse processo da camada de aplicação. Consequentemente, padroniza-se a forma como as aplicações distribuem e recebem conteúdos multimídia, permitindo-se que aplicações, desenvolvidas por diferentes fornecedores, possam cooperar entre si para obter um mesmo conteúdo multimídia de interesse.

A decisão de utilizar roteadores para formar uma rede colaborativa, a fim de disseminar o conteúdo multimídia, pode melhorar o desempenho das transmissões de conteúdos multimídia ao vivo, pois reduz-se o impacto negativo causado por fatores que desestabilizam a rede e a qualidade de serviço, tais como a capacidade de processamento e memória dos dispositivos, mobilidade e dinâmica de entrada/saída dos clientes (\textit{churn}). Esses fatores são os mais críticos em se utilizar uma rede P2P para distribuição de conteúdos multimídia, principalmente com a popularização dos dispositivos móveis. Por exemplo, usar dispositivos móveis como nós contribuidores de recurso não é uma estratégia apropriada, principalmente em redes híbridas IP/celular (por exemplo, 3G). A partir do uso do GMTP, bastará posicionar um roteador GMTP entre a rede IP e a rede celular para atender à demanda de todos os nós móveis.

% No próximo capítulo, apresentam-se os resultados e discussões acerca do uso do protocolo GMTP para a distribuição de conteúdos multimídia ao vivo.