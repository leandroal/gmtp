\chapter{Global Media Transmission Protocol (\mudccp)}
\label{cap:mudccp}

O \textit{Global Media Transmission Protocol} (\mudccp) é um protocolo que atual
nas camadas de transporte e de rede (\textit{cross-layer})
projetado para operar na Internet, a ser utilizado em sistemas de distribuição
de fluxos dados multimídia ao vivo. Trata-se de um protocolo baseado em uma
arquitetura híbrida P2P/CDN, transmitindo-se os dados de um ou mais
sistemas através de uma rede de favores P2P constituída por roteadores de
rede, que cooperam entre si a fim de obterem o conteúdo multimídia de
interesse, ao mesmo tempo que ocorrem interações entre os servidores de uma ou
mais redes CDNs, os quais atuam como super nós para os nós da rede P2P,
auxiliando-os no envio e recebimento dos fluxos de dados. Os nós cliente
reproduzem os conteúdos multimídia aos usuários finais à medida que recebem
pacotes de dados gerados pelos servidores da CDN, através de um processo em
execução na camada de aplicação, ao passo que o roteador de sua rede realiza
parcerias com outros roteadores, os quais também possuem nós clientes
interessados no mesmo conteúdo, motivados pelos seus respectivos usuários
finais que o controlam.

As trocas de dados entre nós GMTP ocorrem por meio do envio e recebimento de
partes de uma mídia (\textit{chunks}), que são transmitidas por diferentes nós
da rede, constituindo um fluxos de datagramas IP. Estes fluxos são
transmitidos em modo \textit{unicast} e compartilhados (\textit{multi-unicast})
pelos roteadores, quando são entregues aos nós clientes em modo
\textit{multicast}, realizando-se controle de congestionamento sem garantia de
entrega. A escolha do modo de transmissão utilizado para disseminar um fluxo de
dados ocorre sem a influência da aplicação, que precisa simplesmente
``sintoniza'' sua conexão em um determinado canal \textit{multicast} definido
pelo roteador. Tal abstração para a camada de aplicação ocorre de modo que os
processos em execução utilizam o GMTP através de uma API compatível com as
especificações de socket BSD e POSIX, o que permite adaptações mais simples das
atuais aplicações de rede de transmissão de mídias ao vivo.

Por conseguinte, o GMTP permite o estabelecimento de conexões entre diversas
aplicações, executadas de forma distribuída em cada sistema final, tornando-as
compatíveis entre si, uma vez que o protocolo desacopla a forma como os dados
são transportados da forma como estes são exibidos ao usuário final, emulando
os sistemas tradicionais de TV e rádio. Sendo assim, promove-se a integração do
GMTP em aplicações já existentes, consideradas futuras adoções, ao tempo que
permite-se a utilização dos novos recursos introduzidos no protocolo,
evitando-se a complexidade de construção dos sistemas de transmissão de fluxos
de dados de eventos ao vivo, especialmente aqueles baseados em arquitetura
P2P/CDN.

Nas próximas seções deste capítulo, detalham-se os aspectos teóricos e
computacionais empregados do GMTP de acordo com os blocos funcionais
ilustrados na Figura~\ref{fig:blocos-funcionais}, a fim de construir uma rede de
sobreposição formada por roteadores, pela execução de quatro grandes passos:

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=.5]{imgs/blocos-funcionais.pdf}
\end{center}
\vspace{-0.8cm}
\caption{Blocos funcionais do GMTP e as relações com a pilha de protocolos
TCP/IP.}
\label{fig:blocos-funcionais}
\end{figure}

\begin{enumerate}

  \item \textit{Constituição da rede de favores:} descobrir, definir, efetivar e
desfazer parcerias entre os roteadores de acordo com o evento a ser
transmitido.

  \item \textit{Distribuição de fluxos de dados através de uma camada de
\textit{socket}:} conectar os nós clientes interessados em receber um fluxo de
dados de um evento, bem como transmitir tal fluxo de dados através da rede de
sobreposição constituída no Passo 1.

  \item \textit{Controle de congestionamento:} controlar a taxa de transmissão
dos fluxos de dados distribuídos no Passo 2.

  \item \textit{Autenticidade do conteúdo:} verificar a autenticidade do fluxo
de dados antes de entregá-los aos nós clientes.

\end{enumerate}

Com base nesse quatro grandes passos, organizou-se a estrutura deste capítulo da
seguinte forma:

\begin{itemize}

  \item Na Seção~\ref{sec:visaogeral}, apresenta-se uma visão geral do
protocolo, como cenário de atuação, arquitetura, canais de comunicação e tipos
de nós e pacotes.

  \item Na Seção~\ref{sec:defsrests}, formalizam-se as definições e restrições
do protocolo.

  \item Na Seção~\ref{sec:connformnet}, descrevem-se o processo de
constituição da rede de favores e os aspectos de conexão multi-ponto
através da introdução de conceitos como sockets P2P, registro de participação de
um nó e a seleção de nós parceiros.

  \item Na Seção~\ref{sec:asptransrecep}, discutem-se os aspectos de
transmissão e recepção de fluxos de dados, relacionando os algoritmos utilizados
para compartilhar um fluxos de dados e as estratégias de disponibilização e
obtenção das partes de uma mídia.

  \item Na Seção~\ref{sec:ccgmtp}, apresentam-se detalhes de funcionamento dos
algoritmos de controle de congestionamento utilizados no GMTP e como estes
influenciam na formação de parcerias.

  \item Na Seção~\ref{sec:seguranca}, discutem-se os aspectos relacionados à
autenticidade de um fluxo de dados.

  \item E, por fim, na Seção~\ref{sec:outros-aspectos}, apresentam-se outros
aspectos relacionados ao GMTP, tais como finalização de conexão, tolerância à
desconexão e eleição de nós relatores para o funcionamento do algoritmo de
controle de congestionamento em modo \textit{multicast}.

% e
% integração com outros protocolos de rede.
%
% \item Na Seção~\ref{sec:impl}, discute-se brevemente sobre aspectos de
% implementação e implantação do GMTP.
%
% \item E, por fim, na Seção~\ref{sec:benef}, apresenta-se um resumo sobre os
% benefícios e as justificativas de decisões de projeto do protocolo GMTP.

\end{itemize}

\section{Visão Geral}
\label{sec:visaogeral}

O protocolo GMTP é composto por dois módulos chamados de \textit{GMTP Intra} e
\textit{GMTP Inter}, que operam na camada de transporte e de rede,
respectivamente, definindo assim sua arquitetura, ilustrada na
Figura~\ref{fig:arq_geral_gmtp}.

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=.8]{imgs/protocolo-arquitetura.pdf}
\end{center}
\vspace{-1cm}
\caption{Arquitetura do Protocolo \mudccp.}
\label{fig:arq_geral_gmtp}
\end{figure}

As responsabilidades dos módulos GMTP Intra e GMTP Inter são:

\begin{itemize}

 \item \textbf{GMTP Intra:} fornecer serviços às aplicações de rede a
fim de abstrair a complexidade na execução de tarefas comuns a qualquer
sistema final, tais como conexão multi-ponto, multiplexação/demultiplexação de
segmentos IP entre as camadas de transporte/rede/aplicação e controle de
congestionamento. Este módulo compreende a instância do GMTP em
execução no sistema operação do nó cliente, acessível através de uma API de
socket GMTP. Um socket GMTP é a representação de uma instância do protocolo GMTP
em execução, sendo responsável por gerenciar todas as atividades de comunicação
da aplicação correspondente ao meio externo (outros processos GMTP). No contexto
de uma conexão, o GMTP Intra mantém diversas variáveis de estado relacionadas à
execução dos algoritmos para gerenciamento de conexão (estabelecimento e
desconexão), controle de congestionamento multicast, multiplexação e
demultiplexação dos datagramas, eleição de nós parceiros e determinação do
formato e preenchimento dos parâmetros que definem uma mídia, permitindo-se que
a aplicação defina os valores de tais parâmetros ou obtenham acesso aos seus
valores.

 \item \textbf{GMTP Inter:} constituir uma rede de favores P2P composta por
roteadores, os quais funcionam como pontes de acesso aos servidores de uma rede
CDN. Trata-se do módulo em execução nos roteadores que cooperam entre si para
constituir a rede de favores, aceitando conexões oriundas de um nó cliente ou de
um outro roteador. No contexto de uma conexão, o GMTP Inter mantém variáveis de
estado relacionadas às funções de sua responsabilidade, tais como
estabelecimento de conexão com nós servidores ou roteadores, seleção de nós
roteadores parceiros, eleição de nós relatores, compartilhamento de fluxos
multimídia e controle de congestionamento assistido pela rede. No GMTP Inter,
permite-se a configuração de parâmetros iniciais de configuração da rede de
favores e da integração com servidores de uma ou mais CDN, como ilustra-se na
Figura~\ref{fig:tela-gmtp-inter}. Nesse caso, o usuário administrador de um nó
repassador pode definir os seguintes parâmetros:

\begin{itemize}

  \item configurações sobre registro de participação em uma ou mais redes
CDN. Este assunto foi detalhado na Seção~\ref{subsec:registro-participacao};

  \item largura de banda máxima (\textit{download} e \textit{upload}) que o nó
repassador está autorizado a compartilhar;

  \item o período (faixa de dias e horários) que o roteador funcionará como nó
repassador;

  \item quantidade máxima de parcerias que podem ser realizadas;

  \item quantidade máxima de fluxos de dados que podem ser compartilhados;

  \item parâmetros avançados relacionados aos algoritmos de controle de
congestionamento. Este assunto foi discutido na Seção~\ref{sec:ccgmtp}; e

  \item configurações acerca dos certificados digitais, tais como
\textit{download} automático e realização de cache. Este assunto foi abordado
na Seção~\ref{sec:seguranca}.

\end{itemize}


\begin{figure}[ht]
\begin{center}
\includegraphics[natwidth=664,natheight=340,scale=.5]{imgs/tela-gmtp-inter.png}
\end{center}
\vspace{-1cm}
\caption{Tela da ferramenta de administração da distribuição Linux OpenWRT com
suporte ao GMTP. Nessa tela, permitir que o administrador do roteador configure
parâmetros do módulo GMTP Inter.}
\label{fig:tela-gmtp-inter}
\end{figure}

\end{itemize}

Sendo assim, para viabilizar a disseminação de conteúdos multimídia, cada nó
roteador no caminho entre o servidor que transmite a mídia e o cliente
interessado em obtê-la, pode repassar os pacotes de dados para seus clientes
locais também podem replicá-los para outros roteadores interessados em receber o
fluxo de dados correspondente. No GMTP, permite-se que um roteador atende à
demanda dos seus clientes locais, ao passo que ajuda os outros roteadores a
fazerem o mesmo, evitando múltiplas conexões para obter um mesmo fluxo de dados
no nó servidor.

% \vspace{0.2cm}
%
% \begin{figure}[ht]
% \begin{center}
% \includegraphics[natwidth=706,natheight=152,scale=.71]{imgs/bucket-brigade-principle-1.png}
% \end{center}
% \vspace{-0.8cm}
% \caption{Analogia do Princípio da Cooperação de Brigadas utilizado no \mudccps
% para distribuição de conteúdos multimídia ao vivo.}
% \label{fig:bucket-brigade-principle-1}
% \end{figure}

Na Figura~\ref{fig:cenario-global-detailed}, observa-se o cenário geral de
atuação do protocolo \mudccp, onde ilustram-se os nós \textit{Clientes GMTP}
interessados em obter o conteúdo de um determinado evento ao vivo. Neste caso,
observa-se também um \textit{Servidor GMTP}, que está conectado a uma rede CDN e
atua como fonte geradora de dados; ao passo que os nós \textit{Clientes GMTP}
conectam-se a um nó \textit{Repassador GMTP} que, na prática, é um roteador de
rede. Os \textit{Repassadores GMTP} efetivamente constituem a rede de
sobreposição P2P, conectando-se a um ou mais \textit{Servidores GMTP}.
Com base na Figura~\ref{fig:cenario-global-detailed}, definiu-se a
Figura~\ref{fig:protocolo-tipos-nos}, onde se observa os seguintes tipos de nós
GMTP:

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=.85]{imgs/cenario-global-detailed.pdf}
\end{center}
\vspace{-1cm}
\caption[Rede de sobreposição construída pelo \mudccp]{Rede de sobreposição
construída dinamicamente pelo \mudccps com a presença de nós repassadores e
relatores.}
\label{fig:cenario-global-detailed}
\end{figure}

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=.6]{imgs/protocolo-tipos-nos.pdf}
\end{center}
\vspace{-1cm}
\caption{Tipos de Nós e modos de conexões do GMTP.}
\label{fig:protocolo-tipos-nos}
\end{figure}

\begin{itemize}

%   \item \textbf{Nó GMTP ou Processador GMTP:} qualquer processador de rede que
% implementa o protocolo GMTP. É um sistema computacional que implementa parte ou
% todo o protocolo GMTP, sendo capaz de interpretar os cabeçalhos dos pacotes
% definidos pelo GMTP e realizar ações pré-definidas. Não há restrições de qual
% tipo de processador de rede pode implementar qual(is) parte(s) do GMTP.

  \item \textbf{Cliente GMTP:} é capaz de reproduzir e gerar conteúdos
multimídia ao vivo. Em geral, um \textit{Cliente GMTP} é um sistema final que
executa um processo a nível de sistema operacional, representando uma aplicação
manipulada pelo usuário final. A maioria dos \textit{Clientes GMTP} funciona
apenas de forma passiva, recebendo o fluxo de dados de um conteúdo multimídia e
entregando-o para um processo de aplicação em execução, sendo um sub-conjunto
destes, contribuidores efetivos no processo de execução do algoritmo de controle
de congestionamento em transmissões \textit{multicast}.

  \item \textbf{Servidor GMTP:} é um sistema final que participa de uma rede CDN
e obtém a mídia a ser transmitida através de três formas: i) diretamente a
partir de uma unidade geradora de conteúdo (filmadora e/ou microfone); ii) a
partir de um \textit{Cliente GMTP}; e/ou iii) a partir de outro \textit{Servidor
GMTP} (troca de dados entre os servidores da CDN). Os \textit{Servidores GMTP}
recebem sinalizações de controle contendo requisições dos nós
\textit{Repassadores GMTP} que, ao receberem uma resposta correspondente a sua
requisição, atendem à demanda de um ou mais nós \textit{Clientes GMTP}.

  \item \textbf{Repassador GMTP:} participa efetivamente da rede de favores e
tem a responsabilidade de repassar os fluxos de dados originados em um ou mais
\textit{Servidores GMTP} para outros nós \textit{Repassador GMTP} até que o
conteúdo de tal fluxo (pacotes de dados) alcancem os nós \textit{Clientes GMTP}.
Este nó sempre é um roteador de rede.

  \item \textbf{Relator GMTP:} é um \textit{Cliente GMTP} com habilidades de
enviar relatórios periódicos ao nó \textit{Repassador GMTP} sobre o estado da
transmissão.

\end{itemize}

% \begin{figure}[ht]
% \begin{center}
% \includegraphics[scale=.65]{imgs/cenario-global.pdf}
% \end{center}
% \vspace{-1cm}
% \caption{Cenário global de atuação do \mudccp.}
% \label{fig:cenario-global}
% \end{figure}

Deste ponto em diante, os termos \textit{Cliente GMTP}, \textit{Servidor GMTP},
\textit{Repassador GMTP} e \textit{Relator GMTP} serão utilizados em sua forma
simplificada, ou seja, \textit{cliente}, \textit{servidor}, \textit{repassador}
e \textit{relator}, respectivamente. Além disso, estes termos não serão mais
formatados em itálico, bem como os termos \textit{socket}, \textit{unicast},
\textit{multi-unicast} e \textit{multicast}. Ademais, quando o termo
\textit{transmissão} ou \textit{transmissão de um evento} for mencionado,
denotar-se-á a transmissão de um fluxo de datagramas IP correspondente a um
evento ao vivo, utilizando-se o protocolo GMTP.

Quando um nó cliente deseja reproduzir um determinado evento, este envia uma
requisição em direção ao nó servidor que está transmitindo o conteúdo de
interesse, como atualmente acontece em qualquer conexão na Internet. A diferença
é que um nó repassador pode interceptar tal requisito durante seu trajeto até o
nó servidor, que então determina os melhores parceiros para atendê-la. Em geral,
isto ocorre já no roteador de borda do nó cliente, que funciona como nó
repassador de origem. Caso o nó repassador não encontre nenhum nó parceiro capaz
repassar a mídia de interesse ou já esteja recebendo o referido fluxo, este
encaminha tal requisição ao nó servidor que transmite a mídia correspondente, já
que o pedido de conexão é intencionalmente endereço ao nó servidor que transmite
o fluxo de dados de interesse. Em todo caso, sempre o nó repassador de origem
assumirá o controle de uma requisição do nó cliente, habilitando-se como
candidato a parceiro para outros nós repassadores, quando motivados por
requisições originadas pelos seus respectivos nós clientes.

O posicionamento dos nós repassadores e suas habilidades permitem a redução do
número de fluxos de dados na rede correspondente a um mesmo evento, ao tempo
que maximiza a quantidade de nós clientes interessados em receber o mesmo fluxo
(escalabilidade). Por este mesmo motivo, o protocolo GMTP é flexível para
permitir que um nó repassador atue somente encaminhando conteúdos multimídias
entre duas ou mais redes distintas, mesmo que este não tenha demandas
explícitas dos seus nós clientes por tal conteúdo. Desta forma, maximiza-se o
uso dos canais de transmissão ociosos, em particular das redes residenciais,
principalmente quando seus usuários estão ausentes e portanto sem fazer uso dos
recursos de redes disponíveis. Isto pode ocorrer sem a necessidade de
manter um determinado computador ligado e conectado à rede, bastando apenas
manter o roteador de rede ligado, diferentemente de todas as outras soluções
existentes baseadas em arquitetura P2P ou P2P/CDN, que requer pelo menos um nó
cliente ligado.

As requisições de conexão podem ser originados não apenas por nós clientes para
seu respectivo nó repassador, mas também estas podem ocorrer entre nós
repassadores que, motivados pelos interesses dos seus nós clientes, formam
parcerias entre si. Isto significa que um nó repassador pode agir como se fosse
um nó servidor, respondendo às requisições originadas por seus nós clientes
GMTP ou por outros nós repassadores, como se a requisição estivesse alcançado o
nó servidor que originalmente transmite o conteúdo. Essa estratégia gera uma
diminuição significativa do número de requisições de conexão aos nós servidores,
evitando-se portando a tragédia dos bens comuns, como discutiu-se na
Seção~\ref{sec:problematica}. Além disso, na
Figura~\ref{fig:cenario-global-detailed}, observa-se um grupo especial de nós
chamados de nós \textit{Relatores GMTP}. Estes nós são responsáveis por enviar
relatórios periódicos sobre o estado da transmissão ao seu nó \textit{Repassador
GMTP}, que os utiliza para regular a taxa de transmissão de um ou mais fluxos de
dados, impedindo que a rede entre em colapso de congestionamento.

Embora alguns autores considerem os termos \aspas{repasse} e \aspas{roteamento}
como conceitos distintos, neste trabalho ambos os termos são considerados
sinônimos e devem ser interpretados como a capacidade que um nó \mudccps tem de
receber dados em uma interface de rede de entrada e encaminhar estes dados
através de uma interface de rede de saída, permitindo-se que uma mesma interface
de rede seja utilizada como entrada e saída ao mesmo tempo. Ademais, nas seções
subsequentes, as palavras \aspas{deve}, \aspas{não deve}, \aspas{requerido},
\aspas{pode}, \aspas{não pode}, \aspas{recomendado} e \aspas{opcional},
incluindo suas variações morfológicas, devem ser interpretadas como descrito na
RFC 2119~\cite{RFC2119}.


\subsection{Resumo das Principais Funcionalidades}

\begin{itemize}

  \item Registro de participação de um nó repassador em um nó servidor. Isto
permite que um nó repassador sinalize interesse em participar de uma rede CDN.
Como resultado, pode-se pré-selecionar nós parceiros filtrados por métricas que
influenciam na qualidade de serviço oferecido aos sistemas finais. Este assunto
será retomado na Seção~\ref{subsec:registro-participacao}.

  \item Acesso a uma transmissão de um evento ao vivo através de um processo de
conexão em três-vias (\textit{3WHS}), com a requisição de conexão transmitida ao
servidor e podendo ser interceptada por um nó repassador em seu trajeto ao
servidor, com suporte automático de detecção e uso dos modos de transmissão
suportados pelo nó repassador (unicast e/ou multicast). Este assunto será
retomado na Seção~\ref{subsec:conexao-requisicao}.

  \item Descoberta de nós parceiros entre redes distintas e negociação de
parcerias, com suporte a formação de parcerias baseadas em métricas de rede,
tal como a largura de banda fim-a-fim. Além disso, o GMTP é capaz de distribuir
um fluxo de dados em múltiplas taxas de transmissão de acordo com a largura de
banda dos nós repassadores. Para isto, o GMTP segmenta os canais de transmissão
(rota entre um nó servidor e os nós repassadores) quando existem múltiplos nós
repassadores em uma determinada rota e estes estão interessados em receber o
mesmo fluxo de dados. Este assunto será retomado nas
Seções~\ref{sec:connformnet} e~\ref{sec:ccgmtp}.

  \item Envio e recebimento de fluxos de dados compartilhados entre nós
da mesma rede através do uso do modo de transmissão multicast, sendo o modo de
transmissão unicast restrito apenas para uso em transportar os fluxos de dados
entre redes distintas, evitando-se a relação de uma conexão por cliente ao nó
servidor. Este assunto será retomado na Seção~\ref{sec:asptransrecep}.

  \item Uso de algoritmo de controle de congestionamento assistidos pela
rede, em transmissões em modo unicast; e uso do \textit{TCP Friendly Rate
Control} (TFRC) adaptado às transmissões de fluxos de dados em modo multicast.
Este assunto será retomado na Seção~\ref{sec:ccgmtp}.

  \item Eleição de nós relatores com suporte a tolerância a desconexões de nós,
com notificação e reeleição de novos nós. Este assunto será retomado na
Seção~\ref{subsec:electrelsreps}.

  \item Verificação de autenticidade dos pacotes de dados que transportam parte
de uma mídia, por meio do uso de assinaturas digitais disponibilizadas pelos nós
servidores, impedindo assim ataques de poluição de conteúdo. Este assunto será
retomado na Seção~\ref{sec:seguranca}.

\end{itemize}


% \begin{table}[ht]
%         \caption{Tipos de Pacotes do protocolo \mudccp.}
%         \label{tab:tipospacotemudccp}
%     \begin{center}
% 	\vspace{-0.8cm}
%         \begin{tabular}{|p{1.0cm}|p{1.5cm}|p{1.5cm}|}
%             \hline
%
% \multicolumn{1}{|>{\columncolor[rgb]{0.05,0.2,0.43}}c}{\textcolor{white}{\textbf
% {\#}}} &
% \multicolumn{1}{|>{\columncolor[rgb]{0.05,0.2,0.43}}c|}{\textcolor{white}{
% \textbf{Tipo}}} &
% \multicolumn{1}{>{\columncolor[rgb]{0.05,0.2,0.43}}c|}{\textcolor{white}{\textbf
% {Descrição}}}
% 	    \\
% 	    \hline
% 	    \hline
%             \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c}{\textbf{0}}
% & \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c|}{Request} &
% \multicolumn{1}{>{\columncolor[rgb]{0.66,0.7,0.759}}l|}{Requisição de um fluxo
% de dados multimídia a partir do seu nome}
% 	    \\
%
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c}{\textbf{1}} &
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c|}{RequestNotify} &
% \multicolumn{1}{>{\columncolor[rgb]{0.913,0.929,0.957}}l|}{Notificar um nó
% cliente que um fluxo de dados está pronto para ser transmitido.}
% 	    \\
%
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c}{\textbf{1}} &
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c|}{Response} &
% \multicolumn{1}{>{\columncolor[rgb]{0.913,0.929,0.957}}l|}{Resposta ao pedido de
% estabelecimento de conexão multicast}
% 	    \\
%             \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c}{\textbf{2}}
% & \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c|}{Data} &
% \multicolumn{1}{>{\columncolor[rgb]{0.66,0.7,0.759}}l|}{Contém dados da
% aplicação}
% 	    \\
%
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c}{\textbf{3}} &
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c|}{Ack} &
% \multicolumn{1}{>{\columncolor[rgb]{0.913,0.929,0.957}}l|}{Confirmação de
% recebimento de pacote}
% 	    \\
%
%             \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c}{\textbf{4}}
% & \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c|}{DataAck} &
% \multicolumn{1}{>{\columncolor[rgb]{0.66,0.7,0.759}}l|}{Dados da aplicação e
% confirmação de recepção}
% 	    \\
%
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c}{\textbf{5}} &
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c|}{Elect} &
% \multicolumn{1}{>{\columncolor[rgb]{0.913,0.929,0.957}}l|}{Inicia o processo de
% eleição de um nó em relay ou reporter}
% 	    \\
%
% \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c}{\textbf{6}}
% & \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c|}{ElectReply} &
% \multicolumn{1}{>{\columncolor[rgb]{0.66,0.7,0.759}}l|}{Sinaliza o interesse de
% um nó em se transformar em relay ou reporter}
% 	    \\
%
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c}{\textbf{7}} &
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c|}{ElectAck} &
% \multicolumn{1}{>{\columncolor[rgb]{0.913,0.929,0.957}}l|}{Confirmação do nó
% eleito para relay ou reporter}
% 	    \\
%
% \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c}{\textbf{8}}
% & \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c|}{RelayQuery} &
% \multicolumn{1}{>{\columncolor[rgb]{0.66,0.7,0.759}}l|}{Transmitido por um nó
% para consultar a lista de relays}
% 	    \\
%
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c}{\textbf{9}} &
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c|}{RelayReply} &
% \multicolumn{1}{>{\columncolor[rgb]{0.913,0.929,0.957}}l|}{Resposta ao pedido
% de consulta da lista de relays}
% 	    \\
%
% \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c}{\textbf{10}}
% & \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c|}{AdvConn} &
% \multicolumn{1}{>{\columncolor[rgb]{0.66,0.7,0.759}}l|}{Utilizado por um nó
% relay ou reporter para anunciar que está ativo na rede}
% 	    \\
%
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c}{\textbf{11}} &
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c|}{Reservado} &
% \multicolumn{1}{>{\columncolor[rgb]{0.913,0.929,0.957}}l|}{Uso futuro e ignorado
% pelo receptor}
% 	    \\
%
% \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c}{\textbf{12}} &
% \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c|}{Reservado} &
% \multicolumn{1}{>{\columncolor[rgb]{0.66,0.7,0.759}}l|}{Uso futuro e ignorado
% pelo receptor}
% 	    \\
%
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c}{\textbf{13}} &
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c|}{CloseReq} &
% \multicolumn{1}{>{\columncolor[rgb]{0.913,0.929,0.957}}l|}{Servidor ou
% Relay solicita término de conexão sem TIMEWAIT}
% 	    \\
%
%             \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c}{\textbf{14}}
% & \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c|}{Close} &
% \multicolumn{1}{>{\columncolor[rgb]{0.66,0.7,0.759}}l|}{Servidor/Cliente/Relay
% solicita término da conexão}
% 	    \\
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c}{\textbf{15}} &
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c|}{Reset} &
% \multicolumn{1}{>{\columncolor[rgb]{0.913,0.929,0.957}}l|}{Determina,
% incondicionalmente, o final da conexão}
% 	    \\
%             \hline
%         \end{tabular}
%     \end{center}
% % 	\scriptsize
% % 	$^1$ O tipo de pacote \textbf{\mudccp-Reset} é utilizado com este
% % propósito, porém utiliza-se também para outros motivos: para sinalizar número
% % de
% % porta incorreto; comportamento inapropriado de opções; desconexão prevista de
% % um
% % \mdrel\space etc.
% \end{table}

% \normalsize


% ver: http://peerstreamer.org

% Anotações após defesa:
%  - Ler o survey: http://www.aicit.org/jcit/ppl/%20JCIT_MAY_30.pdf
%  - Simuladores mais robustos: SimGrid [23], OPSS [26, 27], ChunkSim [29], 3LS
% [30], OPNET [30] (não sei se vai ser bom!)
%  -

\section{Definições, Relações e Restrições}
\label{sec:defsrests}

Nesta seção, descrevem-se as definições, relações e restrições do protocolo
GMTP. Para isto, faz-se uso de fundamentos de álgebra booleana, lógica
proposicional, teoria de conjuntos e teoria dos
grafos~\cite{Jonathan2003,Seroul2000,Courant1996,Devlin1979}.

\newcommand{\transmission}{\Large$\tau$\normalsize\normalfont}
\newcommand{\transmissions}{\transmission\space}
\newcommand{\event}{\Large$\varepsilon$\normalsize\normalfont}
\newcommand{\events}{\event\space}

\newcommand{\setservrepass}{$Z$}
\newcommand{\setservrepasss}{\setservrepass\space}

\newcommand{\settranc}{T}
\newcommand{\transconst}{t}
\newcommand{\settrans}{$\settranc$}
\newcommand{\settranss}{\settrans\space}
\newcommand{\transi}{u}
\newcommand{\transu}[1]{$\transconst_{#1}$}
\newcommand{\transsu}[1]{\transu{#1}\space}
\newcommand{\trans}{\transu{\transi}}
\newcommand{\transs}{\trans\space}

\newcommand{\setrepassc}{R}
\newcommand{\repassconst}{r}
\newcommand{\setrepass}{$\setrepassc$}
\newcommand{\setrepasss}{\setrepass\space}
\newcommand{\repassi}{d}
\newcommand{\repassu}[1]{$\repassconst_{#1}$}
\newcommand{\repasssu}[1]{\repassu{#1}\space}
\newcommand{\repass}{\repassu{\repassi}}
\newcommand{\repasss}{\repass\space}

\newcommand{\setclic}{C}
\newcommand{\cliconst}{c}
\newcommand{\setcli}{$\setclic$}
\newcommand{\setclis}{\setcli\space}
\newcommand{\subsetclii}{i}
\newcommand{\subsetcli}{\setcli$_{\subsetclii}$}
\newcommand{\subsetclis}{\subsetcli\space}
\newcommand{\cliu}[1]{$\cliconst_{#1}$}
\newcommand{\clisu}[1]{\cliu{#1}\space}
\newcommand{\clii}{f}
\newcommand{\cli}{\cliu{\clii}}
\newcommand{\clis}{\cli\space}

\newcommand{\setservc}{S}
\newcommand{\servconst}{s}
\newcommand{\setserv}{$\setservc$}
\newcommand{\setservs}{\setserv\space}
\newcommand{\servi}{a}
\newcommand{\servu}[1]{$\servconst_{#1}$}
\newcommand{\servsu}[1]{\servu{#1}\space}
\newcommand{\serv}{\servu{\servi}}
\newcommand{\servs}{\serv\space}

\newcommand{\setrelc}{L}
\newcommand{\relconst}{l}
\newcommand{\setrel}{$\setrelc$}
\newcommand{\setrels}{\setrel\space}
\newcommand{\subsetrel}{\setrel$_{\theta}$}
\newcommand{\subsetrels}{\setrel$_{\theta}$\space}
\newcommand{\reli}{w}
\newcommand{\rel}{$\relconst_{\reli}$}
\newcommand{\rels}{$\relconst_{\reli}$\space}
\newcommand{\relu}[1]{$\relconst_{#1}$}
\newcommand{\relsu}[1]{$\relconst_{#1}$\space}

\newcommand{\semifullsymb}{\circ}
\newcommand{\fullsymb}{\bullet}
\newcommand{\setwayc}{W}
\newcommand{\setway}{$\setwayc$}
\newcommand{\setways}{\setway\space}
\newcommand{\setwayii}{v}
\newcommand{\setwayiu}[1]{$\setwayc_{#1}$}
\newcommand{\setwayiua}[2]{$\setwayc_{#1}^{#2}$}
\newcommand{\setwayiuas}[2]{\setwayiua{#1}{#2}\space}
\newcommand{\setwayius}[1]{\setwayiu{#1}\space}
\newcommand{\setwayi}{\setwayiu{\setwayii}}
\newcommand{\setwayis}{\setwayius{\setwayii}}
\newcommand{\setwayia}{\setwayiua{\setwayii}{'}}
\newcommand{\setwayias}{\setwayiuas{\setwayii}{'}}

\newcommand{\setwayifu}[1]{$\setwayc^{\fullsymb}_{#1}$}
\newcommand{\setwayifus}[1]{\setwayifu{#1}\space}
\newcommand{\setwayif}{\setwayifu{\setwayii}}
\newcommand{\setwayifs}{\setwayifus{\setwayii}}

\newcommand{\setwayisfu}[1]{$\setwayc^{\semifullsymb}_{#1}$}
\newcommand{\setwayisfus}[1]{\setwayisfu{#1}\space}
\newcommand{\setwayisf}{\setwayisfu{\setwayii}}
\newcommand{\setwayisfs}{\setwayisfus{\setwayii}}

\newcommand{\setwayidu}[1]{$\setwayc^{\lhd}_{#1}$}
\newcommand{\setwayidus}[1]{\setwayidu{#1}\space}
\newcommand{\setwayid}{\setwayidu{\setwayii}}
\newcommand{\setwayids}{\setwayidus{\setwayii}}

\newcommand{\setwayidfu}[1]{$\setwayc^{\lhd\fullsymb}_{#1}$}
\newcommand{\setwayidfus}[1]{\setwayidfu{#1}\space}
\newcommand{\setwayidf}[1]{\setwayidfu{\setwayii}}
\newcommand{\setwayidfs}[1]{\setwayidfus{\setwayii}}

\newcommand{\setwayidsfu}[1]{$\setwayc^{\lhd\semifullsymb}_{#1}$}
\newcommand{\setwayidsfus}[1]{\setwayidsfu{#1}\space}
\newcommand{\setwayidsf}[1]{\setwayidsfu{\setwayii}}
\newcommand{\setwayidsfs}[1]{\setwayidsfus{\setwayii}}

\newcommand{\wayconst}{w}
\newcommand{\wayi}{m}
\newcommand{\wayu}[1]{$\wayconst_{#1}$}
\newcommand{\waysu}[1]{\wayu{#1}\space}
\newcommand{\way}{\wayu{\wayi}}
\newcommand{\ways}{\way\space}

\newcommand{\setpkc}{P}
\newcommand{\pkconst}{p}
\newcommand{\pkalli}{h}
\newcommand{\setpk}{$\setpkc$}
\newcommand{\setpks}{\setpk\space}
\newcommand{\setpkf}{$\setpkc^{\fullsymb}$}
\newcommand{\setpkfs}{\setpkf\space}
\newcommand{\setpkallc}{\mathbb{\setpkc}}
\newcommand{\setpkall}{$\setpkallc$}
\newcommand{\setpkalls}{\setpkall\space}
\newcommand{\subsetpkall}{\setpkall$_{\theta}$}
\newcommand{\subsetpkalls}{\subsetpkall\space}
\newcommand{\subpkf}{\Large$\rho$\normalsize}
\newcommand{\subpkfs}{\subpkf\space}
\newcommand{\subsetpk}{$\setpkc^\lhd$}
\newcommand{\subsetpks}{\subsetpk\space}
\newcommand{\subsetpkf}{$\setpkc^{\lhd\fullsymb}$}
\newcommand{\subsetpkfs}{\subsetpkf\space}
\newcommand{\pki}{x}
\newcommand{\pku}[1]{$\pkconst_{#1}$}
\newcommand{\pksu}[1]{\pku{#1}\space}
\newcommand{\pk}{\pku{\pki}}
\newcommand{\pks}{\pk\space}

\newcommand{\setnetrc}{B}
\newcommand{\setnetr}{$\setnetrc$}
\newcommand{\setnetrs}{\setnetr\space}
\newcommand{\netrconst}{b}
\newcommand{\netri}{e}
\newcommand{\netru}[1]{$\netrconst_{#1}$}
\newcommand{\netrsu}[1]{\netru{#1}\space}
\newcommand{\netr}{\netru{\netri}}
\newcommand{\netrs}{\netr\space}

\newcommand{\net}{$\eta$}
\newcommand{\nets}{\net\space}

\newcommand{\powerset}[1]{$2^{#1}$}
\newcommand{\powersets}[1]{\powerset\space}
\newcommand{\transmit}{$\varphi($\serv$,$ \setpk$)$}
\newcommand{\transmits}{\transmit\space}
\newcommand{\transmitr}{$\varphi($\repass$,$ \setpk$)$}
\newcommand{\transmitrs}{\transmitr\space}
\newcommand{\transmitru}[1]{$\varphi($\repassu{#1}$,$ \setpk$)$}
\newcommand{\transmitrus}[1]{\transmitru{#1}\space}
\newcommand{\transmitqu}[1]{$\varphi($#1$,$ \setpk$)$}
\newcommand{\transmitqus}[1]{\transmitqu{#1}\space}
\newcommand{\invert}[1]{$\sim$$($#1$)$}

\begin{enumerate}

  \item Seja o conjunto finito dos nós repassadores, definido por
\setrepasss $ = \{\repassconst_1, \repassconst_2, \repassconst_3,
\ldots, $ \repass$\}$, tal que $\repassi \in \mathbb{N}$.

  \item Seja o conjunto finito dos roteadores de uma rede de computadores,
definido por \setnetrs $ = \{\netrconst_1, \netrconst_2,
\netrconst_3, \ldots, $ \netr$\}$, tal que $\netri \in \mathbb{N}$. Existe uma
relação \setrepasss $\rightarrow$ \setnetrs que determina a sobreposição
dos nós repassadores \repasss $\in$ \setrepasss sob os roteadores em \setnetrs
(\textit{rede de sobreposição}).

  \item Seja o conjunto finito dos nós servidores, definido por \setservs $ =
\{\servconst_1, \servconst_2, \servconst_3, \ldots, $ \serv$\}$, tal que $\servi
\in \mathbb{N}$.

  \item Seja o conjunto finito dos nós clientes, definido por \setclis $ =
\{\cliconst_1, \cliconst_2, \cliconst_3, \ldots, $ \cli$\}$, tal que $\clii \in
\mathbb{N}$.

  \item Seja o conjunto \textit{totalmente ordenado (toset)} dos pacotes de
dados gerados pelos nós \servs $\in$ \setservs durante a transmissão de um
evento ao vivo \event, definido por $($\setpkall$,\prec) = \{\pkconst_1,
\pkconst_2, \pkconst_3, \ldots, $\pku{\pkalli}$\}$, tal que $\pkalli \in
\mathbb{N}$. Note que o símbolo $\prec$ é utilizado para representar
precedência entre dois elementos.

  \item Seja um grafo determinado pelo conjunto de vértices \setservrepass, que
podem estar interligados entre si por um conjunto de diferentes arestas,
chamadas de caminhos \setway, por onde se transmite o fluxo de dados \setpk,
definido por $\eta = G($\setservrepass$,$ \setway$)$, tal que:

    \begin{enumerate}

      \item \setservrepasss $=$ \setservs $\cup$ \setrepass;

      \item Sejam as relações e restrições estabelecidas entre os diferentes
tipos de nós de uma transmissão de um evento ao vivo \event, definida por
\transmission $= \{$\setservrepass, \setpk, \subsetcli$\}$, tal que:

      \begin{enumerate}

	  \item Seja \setpk, o conjunto \textit{parcialmente ordenado
(\textit{poset})} dos pacotes de dados \pks transmitidos por um nó \repass,
também chamado de fluxo de pacotes de dados ou
apenas fluxo de dados, definido por $($\setpk$,\prec) =
\{\pkconst_{1},\pkconst_{2}, \pkconst_{3},
\ldots, $\pku{x}$\}$, tal que $x \in \mathbb{N}$. Trata-se de um \textit{poset}
porque o GMTP não garante entrega de \pk;

	  \item Seja \subsetcli, uma função que denota os nós \clis relacionados
a um nó \repass, de modo que nenhum nó \clis $\in$ \setclis pode estar
relacionado com dois ou mais nós \repass, definida por \subsetclis $:$ \repasss
$\rightarrow$ \powerset{\setclic}, $\forall$\repass,\repassu{q} $\in$
\setrepass, \subsetcli$($\repass$)$ $\cap$ \subsetcli$($\repassu{q}$)$
= $\{\emptyset\}$, tal que $q \neq d$ e $q \in \mathbb{N}$;
	  \label{item:funcao-subsetcli}

% , de modo que:
%   \begin{itemize}
%     % se disser que P \subset P_{total} já é suficiente pra ser um P*?
%     \item Um fluxo de dados \setpks é dito \textit{fluxo completo},
% representado por \setpkf, se e somente se \setpks $\leftrightarrow$
% $\exists$\subsetpkalls (relação bijetora), tal que \subsetpkalls $\in$
% \powerset{\setpkallc} e \subsetpkalls $\neq \{\emptyset\}$. Ou seja, um
% \textit{fluxo completo} \setpkfs é um conjunto \textit{toset} e portanto
% não apresenta lacunas;
%
%     \item \subpkfs $: ($\pk$, $\setpk$) \rightarrow ($\subsetpk$, \prec) =
% \{$\pk, \pku{\pki+1}, \pku{\pki+2}, \pku{\pki+3}, $\ldots\}$, tal que
% \subsetpks $\subset$ \setpk, uma função \subpkf$($\pk$, $\setpk$)$ que define
% um sub-fluxo de pacotes de dados \setpks a partir de um determinado pacote
% \pks
% $\in$ \setpk. Neste caso, como \subsetpks $\subset$ \setpk, se \subsetpkfs
% $\rightarrow$ \setpkf.
%   \end{itemize}

	  \item Seja \setrel, o conjunto finito dos nós relatores, definido por
\setrels $= \{\relconst_1, \relconst_2, \ldots, $\rel$\}$. Como todo nó \clis
pode atuar como \rel, tem-se que $\exists$\subsetrels $\in$
\powerset{\setclic_\subsetclii(\repassconst_\repassi)}, tal que \rels $\in$
\subsetrel. Pelo item~\ref{item:funcao-subsetcli}, tem-se portanto que
\subsetrels $\subset$ \setrels e \subsetrels $\cup$ \subsetcli$($\repass$)$ $ =
$ \subsetcli$($\repass$)$.

      \end{enumerate}

    \item \setway $=$ $\bigcup^{j}_{\setwayii=1}$ \setwayi, onde $j \in
\mathbb{N}$ e corresponde à quantidade de todos os possíveis caminhos \setwayi,
tal que um caminho é definido por um conjunto \textit{toset}
$($\setwayi,$\prec)$, que denota um dos possíveis caminhos por onde um fluxo de
dados \setpks pode ser transmitido, obrigatoriamente a partir de um nó servidor
\servs até um nó \repassu{1}, tal que:

      \begin{enumerate}

	  \item $($\setwayi$,\prec) = \{$\ways $\mid$
\serv$,\repassconst_{1},\repassconst_{2},\repassconst_3,
\ldots, $\repass$\}$, $\forall$\way$,$\waysu{\wayi+1}$\in$ \setwayis $:$
\way$ \prec$ \wayu{\wayi+1} e $\mid$\setwayi$\mid$ $\ge$ $2$;

	  \item Um caminho \setwayis é dito \textit{caminho semi-completo},
representado por \setwayisf, se e somente se \setwayis $\leftrightarrow$
$\exists$\setnetr$_{\theta}$ (bijetora), tal que \setnetr$_{\theta}$
$\in$ \powerset{\setnetrc} e \setnetr$_{\theta} \neq \{\emptyset\}$. Isto é,
todos os roteadores \netrs $\in$ \setnetrs são sobrepostos por um nó \repasss
$\in$ \setwayisf;

	  \item Um caminho \setwayis é dito \textit{caminho completo},
representado por \setwayif, se for \setwayisfs e se \setwayis $\subset$
\settrans, tal que \settranss $\subset$ \setservrepasss é o conjunto dos nós
\repasss que transmitem os pacotes de dados \pks $\in$ \setpks a seus nós \clis
$\in$ \subsetcli(\repass), definido por \settranss $= \{$\transs$\mid$
\transmitqus{\trans} $ = 1\}$, sendo $\transi \in
\mathbb{N}$ e $\varphi$ uma função booleana que determina se um nó \transs $\in$
\settranss transmite os pacotes \pks $\in$ \setpks para \clis $\in$
\subsetcli(\trans), ou seja:

	      \begin{enumerate}

		  \item $\varphi:$ (\trans, \setpk) $\rightarrow \{0, 1\},
\forall ($\trans, \setpk$) \in \{$\settrans$ \times \{$\setpk$\}\}$, onde 0 e 1
denotam, respectivamente, \textit{falso} e \textit{verdadeiro}.

	      \end{enumerate}

      \end{enumerate}

    \item Seja $\sim$, uma função reversa de um conjunto \textit{toset}, tal que
$\sim$ $: ($\setwayi$,\prec)$ $\rightarrow ($\setwayi$,\succ)$. Isto é, para um
conjunto $($\setwayi$, \prec) = \{$\ways $\mid$
\serv$,\repassconst_{1},\repassconst_{2},\ldots, $\repass$\}$, então
\invert{\setwayi} produzirá $($\setwayi$, \succ) = \{$\ways $\mid$ \repass
$,\repassconst_{\repassi-1},\repassconst_{\repassi-2},\ldots,\repassconst_{1},
$\serv$\}$;

    \item Seja $\delta$, uma função que define um sub-caminho de \setwayi,
representado por \setwayid, a partir de um nó \transs $\in$ \setwayis até um nó
\transu{1} $\in$ \setwayi, tal que $\delta: ($\trans$,$\setwayi$) \rightarrow
($\setwayid$, \prec)$. Ou seja, para um caminho qualquer $($\setwayi$, \prec) =
\{$\transu{\transi+2}$,$\transu{\transi+1}$,$\trans$,$\transu{\transi-1}$,
$\transu{\transi-2}$, \ldots,$\transu{2}$,$\transu{1}$\}$,
$\delta($\trans$,$\setwayi$) = $ \setwayids $ =
\{$\trans$,$\transu{\transi-1}$,$\transu{\transi-2}$,\ldots,$\transu{2}$,
$\transu{1}$\}$.
% Neste caso, como $\delta$ faz um corte no conjunto \setwayi,
% pode-se obter \textit{caminho semi-completo} ou \textit{completo},
% representados por \setwayidsfs\space e \setwayidfs\space, respectivamente;

    \item Seja $\zeta$ uma função que calcula o custo total para transmitir um
pacote \pks $\in$ \setpk através de um caminho \setwayi, definida por $\zeta :
\sum_{\setwayii=1}^{\mid\setwayc_\setwayii\mid} \gamma($\way$,$
\wayu{\wayi+1}$)$, tal que $\gamma$ é uma função que determina o custo para
transmitir o pacote \pks entre dois nós distintos
$\forall$\way$,$\wayu{\wayi+1} $\in$ \setwayi. No GMTP, a função
$\gamma$ calcula o custo apenas entre dois nós \trans,\transu{\transi+1},
com base pela largura de banda disponível nos nós \trans. Porém, pode-se definir
outras métricas, por exemplo, o número total de saltos no caminho \setwayis ou o
RTT entre o nó \servs e um nó \repass;

    \item \textit{Conjectura 1}: $\forall$\repasss $\in$ \setrepasss e
$\forall$\clis $\in$ \setcli, \repasss é mais estável que qualquer \clis com
relação a sua disponibilidade e participação em uma rede de favores $\eta$. Em
uma rede comutada por pacotes IP, um nó \netrs $\in$ \setnetr, ou seja, um nó
\repasss fica menos indisponível se comparado aos seus nós
\subsetcli(\repass). Por exemplo, nas transmissões de dados na Internet, a
participação de um roteador no processo de transmissão de um fluxo de dados
\setpks é fundamental, mesmo que seja apenas para rotear os respectivos pacotes.
Apesar de óbvia, tal observação é importante porque para qualquer nó \clis
receber os pacotes de dados \pks $\in$ \setpk, primeiramente os pacotes de dados
\pks passam, obrigatoriamente, pelo roteador de \cli, ou seja, o seu roteador
padrão. Sendo assim, quando um nó \repasss se desconecta, todos seus nós
\subsetcli(\repass) tornam-se capazes de receber \setpk, mas a recíproca não
é verdadeira -- se um nó \clis se tornar indisponível, não necessariamente
\repasss também se torna indisponível. Com a aceitação dessa conjectura para a
rede \net, permite-se que outros nós \clis possam continuar recebendo \setpk,
mesmo ocorrendo a desconexão de um nó \clis que também esteja recebendo \setpk.
No GMTP, adota-se tal estratégia quando um nó \repasss passa a manter estado
sobre a transmissão de \setpks e não mais os nós \cli, antes prática
comumente adotada em soluções tradicionais de distribuição de conteúdos
multimídia baseado em uma arquitetura P2P ou em qualquer protocolo disponível no
estado da arte;
    \label{item:conjecture1}

    \item \textit{Conjectura 2}: as tabelas de roteamento dos nós \ways $\in$
\setwayis não mudam frequentemente e são independentes umas das outras. Em
redes comutadas por pacotes IP, as rotas entre quaisquer nós \cliu{\clii_1} e
\cliu{\clii_2} $\in$ \setclis não se alteram com uma frequência que
desestabilize a comunicação entre estes. Mesmo se estas mudanças ocorrerem em
uma rota de um caminho \setwayi, o impacto causado é temporário e insignificante
para a transmissão de um evento \events quando se utiliza um conjunto de
algoritmos que tratem essas mudanças. Com base na aceitação dessa conjectura,
pode-se antecipar a formação de parcerias pré-selecionando nós \repasss em
\setservrepasss antes da efetiva transmissão de um fluxo de dados \setpk. No
GMTP, adota-se tal estratégia ao permitir que no processo de conexão, todos os
nós \repasss $\in$ \setrepasss informem sua posição na mensagem de requisição
transmitida ao nó \serv. Quando o nó \servs recebe tal mensagem, este passa a
conhecer o caminho até o referido nó \repass. Posteriormente, o nó \servs
utiliza o conjunto de caminhos conhecidos para sugerir parcerias entre os nós
\repass.
    \label{item:conjecture2}

%   \item $\zeta:$ $\hat{r}_x$, $\hat{r}_y$, $\hat{t}_i$)} =
% \textit{min$\{$cost($\hat{r}_y$, $\hat{r}_z$, $\hat{t}_i$)}$\}$, uma função
% recursiva que determina o custo para um nó repassador $\hat{r}_x$ obter, a
% partir de um nó repassador parceiro $\hat{r}_y$, um evento $\gamma$,
% transmitido em $\hat{t}_i$. Sendo assim, \textit{cost($\hat{r}_x$,
% $\forall\hat{r}_y$, $\hat{t}_i$)} $ = 0$ para $\hat{r}_x = \hat{t}_i$;


%   \item f: \textit{link($\hat{r}_i$, $\hat{r}_j$)} $ =
% \hat{r}_i \leftrightarrow \hat{r}_j$ ou f: \textit{link($\hat{r}_i$,
% $\hat{s}$)} $ = \hat{r}_i \leftrightarrow \hat{s}$, uma função que relaciona um
% nó $\hat{r}_i$
% a um nó $\hat{r}_j$ $\mid$ $\hat{r}_i$ e $\hat{r}_j \in R_{\tau}$ ou a um nó
% $\hat{s}$ $\mid$ $\hat{s} \in S_{\tau}$, respectivamente. A propriedade de
% comutatividade de \textit{link()} é válida, ou seja, \textit{link($\hat{r}_i$,
% $\hat{r}_j$)} $=$ \textit{link($\hat{r}_j$, $\hat{r}_i$)};;
%   \label{i:linkrepass}

    \end{enumerate}

\end{enumerate}

Desta forma, \nets representa formalmente a rede de sobreposição constituída
pelo GMTP, definindo-se as relações, restrições estabelecidas em \transmissions
e as conjecturas consideradas para a execução de tal protocolo.

\section{Constituição da Rede de Favores \net}
\label{sec:connformnet}

A constituição da rede de favores \nets ocorre por meio do registro
de participação de um ou mais nós \repasss $\in$ \setrepasss a um ou mais
nós \servs $\in$ \setserv. Isto ocorrer de forma direta ou indiretamente
por meio de outros nós \repassu{q} $\in$ \setrepass. Todo esforço realizado
nesse processo objetiva transmitir um determinado fluxo de dados $P$ para um ou
mais nós \clis $\in$ \setcli, podendo ser distribuído pelos nós \repasss por
meio de diferentes caminhos \setwayis $\in$ \setway.

O GMTP tenta determinar um caminho sub-ótimo \setwayiu{\theta} através do qual
os pacotes de dados \pks $\in$ \setpks sejam entregues o mais rápido possível ao
nó \clis interessado em obter \setpk. Para isto, deve-se determinar
\setwayiu{\theta}, tal que \setwayiu{\theta} $= min(\zeta(\forall$\setwayi$))$
e, sempre que possível, que \setwayiu{\theta} seja um caminho completo
\setwayifu{\theta}. Sempre buscar um caminho completo é importante porque como
todos os nós de tal caminho são roteadores sobrepostos por \repasss e utilizados
para transmitir \setpk, pode-se distribuir \setpks para mais nós \clis sem que
sejam necessárias múltiplas conexões em \serv, evitando a tragédia dos bens
comuns, discutida no Capítulo~\ref{cap:introducao}. Além disso, quanto mais nós
\repasss estiverem disponíveis na rede, menor será o impacto causado pelas
desconexões nos sistemas finais que recebem o fluxo de dados \setpk.

\subsection{Tipos de Pacotes}
\label{subsec:tipodepacotesmudccp}

Antes de prosseguir com os passos do GMTP para constituir uma rede de
favores \net, é importante entender os diferentes tipos de pacotes utilizados
no GMTP. Isto porque, toda comunicação entre dois ou mais nós GMTP ocorre
através da troca de pacotes IP, os quais carregam sinalizações de controle
e/ou dados da aplicação. No mundo real (Internet), será necessário registrar
na \textit{Internet Assigned Numbers Authority} -- IANA\footnote{IANA:
http://www.iana.org/} o uso de um código para o campo \textit{Protocolo} do
cabeçalho de um datagrama IP. Com a padronização do protocolo \mudccps e a
publicação da sua RFC, provavelmente será utilizado o código 100, como já está
definido no documento \textit{Protocol Numbers}\footnote{O código 100 foi
utilizado no passado por um outro protocolo de mesma sigla, mas foi
descontinuado e se tornou obsoleto. No momento da escrita desse documento, o
uso de tal identificador está sendo negociado junto a IETF e a IANA
\murl{http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml}}
da IANA.

No cabeçalho dos pacotes \mudccp, existe um campo denominado \emph{tipo do
pacote} com tamanho de \ut{5}{bits}, que são descritos a seguir. Este campo
determina qual tipo de informação está contida em um determinado pacote \mudccps
e, ao processá-lo, o nó \mudccps deve executar uma determinada ação.

\begin{enumerate}
\setcounter{enumi}{-1}

  \item \textit{GMTP-Request:} o nó cliente envia requisição para obter um fluxo
de dados multimídia com base no nome do fluxo de interesse;

  \item \textit{GMTP-RequestNotify:} o nó repassador notifica um cliente que um
fluxo de dados está prestes a ser transmitido ou já está sendo transmitido em um
determinado canal de repasse multicast. O campo de dados desse tipo de pacote
contém a descrição da mídia a ser reproduzida;

  \item \textit{GMTP-Response:} o nó repassador confirma o estabelecimento de
uma parceria com outro nó repassador, dado um determinado fluxo de dados;

  \item \textit{GMTP-Register:} o nó repassador registra participação no
servidor para funcionar como distribuidor de um fluxo de dados;

  \item \textit{GMTP-Register-Reply:} o nó servidor responde sobre o pedido de
registro de participação enviado por um nó repassador;

  \item \textit{GMTP-RelayQuery:} o nó repassador pode solicitar ao servidor uma
lista de possíveis nós repassadores parceiros;

  \item \textit{GMTP-Data:} qualquer nó utiliza esse tipo de pacote para
transmitir dados da
aplicação;

  \item \textit{GMTP-Ack:} qualquer nó utiliza esse tipo de pacote para
confirmar a recepção de um determinado pacote, seja pacotes previamente contendo
dados ou não;

  \item \textit{GMTP-DataAck:} combinação dos pacotes GMTP-Data e GMTP-Ack
(\textit{PiggyBack});

  \item \textit{GMTP-MediaDesc:} o nó servidor transmite esse pacote para
descrever informações sobre a mídia sendo transmitida em uma
determinado fluxo de dados (conexão);

  \item \pac{GMTP-DataPull-Request:} o nó repassador envia um pedido para obter
o mapa de buffer atual de um outro repassador parceiros;

  \item \pac{GMTP-DataPull-Response:} resposta ao pedido para obtenção de um
mapa de buffer;

  \item \pac{GMTP-Elect-Request:} o nó repassador envia para um cliente o pedido
para tal cliente atuar como nó relator;

  \item \pac{GMTP-Elect-Response:} o nó cliente envia para o repassador uma
confirmação de que pode atuar como relator;

  \item \pac{GMTP-Close:} os nós servidor, repassador ou cliente solicitam o
término de uma conexão;

  \item \pac{GMTP-Reset:} determina, incondicionalmente, a finalização de
uma conexão;

  \item \pac{Reservado:} a partir deste identificador ao 31, tratam-se de
valores reservados para uso futuro e ignorado pelos nós que o processa.

\end{enumerate}

% No Apêndice~\ref{app:mudccp-tecnica}, apresenta-se detalhes acerca do uso dos
% tipos de pacotes do GMTP, sendo seu teor bastante técnico e portanto dedicado
% aos leitores interessados em sua implementação.

\subsection{Registro de Participação de \repasss em \net}
\label{subsec:registro-participacao}

O procedimento de registro de participação de um nó \repasss em uma rede $\eta$
é o primeiro passo e um dos mais importante. O registro de participação permite
que um nó \repasss se registre a um nó \servs para sinalizar interesse em
funcionar como um nó repassador de um fluxo de dados \setpk. O
registro de participação pode ocorrer antes do nó \servs iniciar a transmissão
de um fluxo de dados \setpk, ou durante sua transmissão. Em ambos os casos, o
algoritmo de registro de participação é similar, com uma diferença: se um nó
\repasss solicitar previamente um registro de participação a um \servs sem
interesse por um fluxo de dados \setpks qualquer, será possível mapear
antecipadamente e selecionar um subconjunto de possíveis nós parceiros
\repassu{q} para executar a distribuição de um fluxo de dados \setpk. Neste
caso, pode-se utilizar \repasss para repassar pacotes de dados \pks $\in$
\setpks mesmo quando \subsetcli$($\repass$) = \{\emptyset\}$, ou seja, mesmo se
o nó repassador não tiver nós clientes para repassar o fluxo de dados \setpk.
Assim, os nós \repass passam a funcionar como se fossem servidores de uma rede
CDN, que podem ser acionados dinamicamente, quando conveniente.

Para realizar um registro de participação, um nó \repasss envia uma mensagem
para um nó \servs utilizando o pacote \pac{GMTP-Register}, o que permite a
descoberta de um caminho \setwayi. Isto porque todos os nós repassadores
existentes no caminho entre \repasss e \servs devem adicionar seu identificador
no pacote \pac{GMTP-Register} antes de rotea-lo para o próximo salto da rota em
direção ao nó \serv. Para definir um identificador de um nó \repass, gera-se um
código \textit{hash} da soma dos endereços MAC (\textit{Media Access Control})
de todas as interfaces de rede do roteador. Quando o pacote \pac{GMTP-Register}
alcançar o destino \serv, o nó \servs conhecerá o caminho \setwayis composto por
todos os nós \repasss até \servs e o armazenará como sendo um dos possíveis
caminhos para distribuir um fluxo de dados \setpk. Como resposta ao nó \repass,
o nó \servs deve enviar um pacote do tipo \pac{GMTP-Register-Reply}, que
confirma o registro de participação. O caminho \setwayis pode ser utilizado
futuramente no processo de formação de parcerias, a ser discutido na
Seção~\ref{sec:descparc}.

% Pelas conjecturas~\ref{item:conjecture1} e~\ref{item:conjecture2}, apresentadas
% na Seção~\ref{sec:defsrests}, o nó \servs pode utilizar os caminhos conhecidos
% \setwayis $\in$ \setways para coordenar o processo de formação de futuras
% parcerias entre os nós \repasss $\in$ \setrepass.

% Um registro de participação ocorre quando um nó deseja participar
% da rede de sobreposição, não necessariamente quando se deseja obter um fluxo de
% dados \setpk.

% Um registro de participação também pode ocorre no mesmo instante
% que um nó \repasss desejar receber um fluxo de dados \setpk.


Dessa forma, se um nó \repasss for um nó comum entre dois caminhos, será
necessário apenas enviar um fluxo de dados \setpks até \repasss e este replicará
o referido fluxo de dados para os nós \repassu{d+1}, \repassu{d+2},
\repassu{d+3} e assim por diante. De forma similar, se $\exists$\clis $\in$
\subsetcli$($\repass$)$ interessado em obter \setpk, com \transmitr\space $ =
1$, ou seja, quando um nó \repasss já está recebendo \setpk, o registro de
participação já terá ocorrido e o fluxo já estará sendo recebido pelo nó
\repasss em questão, vindo diretamente do nó \servs ou repassado por outros nós
\repass. Como consequência, reduz-se o tempo de início de reprodução do
referido fluxo de dados \setpks para aqueles nós \clis que solicitarem o mesmo
fluxo de dados \setpks após o primeiro nó repassador pedir, bastando apenas que
os próximos nós \clis ``sintonizem'' sua interface de comunicação (socket de
rede) no canal apropriado e informado por \repass, pois a transmissão ocorre em
modo multicast. Por analogia, o registro de participação faz com que o roteador
de uma rede funcione como se fosse uma antena de recepção de uma transmissora de
TV, podendo-se receber um ou mais sinais de canais de TV diferentes. Em seguida,
estes sinais são repassados para os clientes conectados diretamente à antena, ou
melhor, ao roteador.

No Algoritmo~\ref{algo:registerRelay}, executado por um \repass, resume-se os
passos para o envio do pedido de registro de participação em um nó \serv. Note
que o nó \repasss não é obrigado a informar qual fluxo de dados \setpks está
interessado em obter. Se o fluxo de dados \setpks for especificado, o nó \servs
executará um procedimento para determinar se aceita ou não o pedido de registro
de participação para transmitir \setpks a \repass. Em caso de aceite, a
transmissão do fluxo de dados \setpks de \servs para \repasss ocorrerá em modo
unicast, caso contrário o nó \servs instruirá um outro nó \repassu{q} a
transmitir o referido fluxo de dados ao nó \repass solicitante. Já no
Algoritmo~\ref{algo:onReceiveGMTPRegisterReply}, resume-se os passos após um nó
\repasss receber uma resposta do tipo \pac{GMTP-Register-Reply} transmitida pelo
nó \serv, referente ao pedido de registro de participação transmitido
anteriormente por \repass.

% , caso contrário, o nó \servs delegará a transmissão de tal fluxo de
% dados \setpks para algum outro nó repassador \repassu{q} que se tornará parceiro
% do nó requisitante \repass.

Note que, no GMTP, toda transferência de pacotes de controle entre nós \repasss
ocorre com garantia de entrega, representando-se tais ações pelas funções com
nomes contendo o sufixo \textit{Rdt} (\textit{Reliable data transfer}). Uma
outra decisão importante tomada no GMTP é que um nó \repasss deve periodicamente
sinalizar sua participação na rede de favores \nets através de um método
conhecido por \textit{keep-alive}, comumente utilizado em
outros protocolos de rede consolidados, como o TCP. Nesse aspecto, o GMTP segue
a RFC 1122, \textit{Requirements for Internet Hosts - Communication
Layers}~\cite{RFC1122}.

Além disso, um nó \repasss pode sinalizar explicitamente sua desconexão a
\servs quando não desejar mais participar da rede de favores $\eta$ ou receber
um fluxo de dados \setpk. Para isto, deve-se enviar um pacote do tipo
\pac{GMTP-Close}. Em qualquer um dos casos de desconexão, por expiração do
tempo (devido ao procedimento de \textit{keep-alive}) ou explicitamente através
do envio do pacote do tipo \pac{GMTP-Close}, o nó \servs deve desconsiderar
\repasss no processo de formação de parcerias e enviar para este um pacote do
tipo \pac{GMTP-Reset}.

\newcommand{\attrib}{$\leftarrow$ }

\begin{algorithm}[H]
\label{algo:registerRelay}
\caption{registerRelay(\serv: PeerServer, \pks $=$ \pac{GMTP-Request})}
\SetAlgoLined

\SetKwFunction{Union}{Union}\SetKwFunction{makePkt}{makePkt}
\SetKwFunction{Union}{Union}\SetKwFunction{recvPktRdt}{recvPktRdt}
\SetKwFunction{Union}{Union}\SetKwFunction{sendPktRdt}{sendPktRdt}
\SetKwFunction{Union}{Union}\SetKwFunction{getCurrRegedServers}{getCurrRegedServers}
\SetKwFunction{Union}{Union}\SetKwFunction{parsePath}{parsePath}
\SetKwFunction{Union}{Union}\SetKwFunction{length}{length}
\SetKwFunction{Union}{Union}\SetKwFunction{getPacketFieldValue}{getPacketFieldValue}
\SetKwFunction{Union}{Union}\SetKwFunction{isFlowBeingReceived}{isFlowBeingReceived}
\SetKwFunction{Union}{Union}\SetKwFunction{respondToClients}{respondToClients}
\SetKwFunction{Union}{Union}\SetKwFunction{getChannelOfFlow}{getChannelOfFlow}
\SetKwFunction{Union}{Union}\SetKwFunction{GMTPRegister}{GMTPRegister}
\SetKwFunction{Union}{Union}\SetKwFunction{isWaitingRegisterReply}{isWaitingRegisterReply}
\SetKwFunction{Union}{Union}\SetKwFunction{waitRegisterReply}{waitRegisterReply}
\SetKwFunction{Union}{Union}\SetKwFunction{addClientWaitingFlow}{addClientWaitingFlow}
\SetKwFunction{Union}{Union}\SetKwFunction{GMTPRequestReply}{GMTPRequestReply}

\tcc{The node \repasss executes this algorithm to send a register of
participation to a given node \serv. If \pks is given, node \clis wants to
receive the flow \setpk, so notify \serv.}

\If(){\pks $\neq$ NULL} {
  \textit{\setpk} \attrib \getPacketFieldValue{\pk, `flow'}\tcc*[r]{Extracts \setpks in \pk}
  \label{algo-line:registerRelay-getP}
  \textit{\cli} \attrib \getPacketFieldValue{\pk, `client'}\tcc*[r]{Extracts \clis in \pk}
  \textit{channel} \attrib \isFlowBeingReceived{\setpk}\tcc*[r]{Ver Seção~\ref{subsec:tabela-recepcao}}
  \tcc{Add \clis in the list of receivers waiting \setpk.}
  \addClientWaitingFlow{\cli, \setpk}\;
  \label{algo-line:addClientWaitingFlow}
  \uIf(){\textit{channel} $\neq$ NULL} {
    \label{algo-line:isFlowBeingReceived}
    \tcc{Let \clis know that \setpks is already registered in this \repasss and is available from a multicast channel.}
    \respondToClients{\GMTPRequestReply{\textit{channel}}}\;
    \label{algo-line:respondToClients1}
    \Return{0}\;
    \label{algo-line:registerRelay-returnChannel}
  } \Else(\tcc*[f]{Flow \setpks not registered yet.}) {
      \tcc{Send request to \servs and wait registration reply. When \pac{GMTP-Register-Reply} is received, executes onReceiveGMTPRegisterReply (Algorithm~\ref{algo:onReceiveGMTPRegisterReply}).}
%  If the \pac{GMTP-Register} was already sent, nothing should be done other than wait for \pac{GMTP-Register-Reply}.
      \If() {\textbf{not} \isWaitingRegisterReply{\setpk}} {
	\isWaitingRegisterReply{\setpk, true}\;
	\sendPktRdt{\GMTPRegister{\serv, \setpk}}\;
% 	\Return{0}\;
      }
      \tcc{Ask \subsetcli$($\repass$)$ to wait registration reply for \setpk.}
      \respondToClients{\GMTPRequestReply{\setpk}}\;
      \label{algo-line:respondToClients2}
      \Return{0}\;
  }
}
\If(){\textbf{not} \isWaitingRegisterReply{\serv}} {
  \Return{\sendPktRdt{\GMTPRegister{\serv}}}\;
}
\Return{0};

\end{algorithm}

\vspace{0.8cm}

\begin{algorithm}[H]
\label{algo:onReceiveGMTPRegisterReply}
\caption{onReceiveGMTPRegisterReply(\pks $=$ \pac{GMTP-Register-Reply})}
\SetAlgoLined

\SetKwFunction{Union}{Union}\SetKwFunction{createMulticastChannel}{createMulticastChannel}
\SetKwFunction{Union}{Union}\SetKwFunction{getAndStoreServerPublicKey}{getAndStoreServerPublicKey}
\SetKwFunction{Union}{Union}\SetKwFunction{updateFlowReceptionTable}{updateFlowReceptionTable}
\SetKwFunction{Union}{Union}\SetKwFunction{startRelay}{startRelay}

\tcc{The node \repasss executes this algorithm when receives a packet of type
\pac{GMTP-Register-Reply}, as response for a registration of participation sent to a \servs node.}

\isWaitingRegisterReply{\setpk, false}\;
\uIf(\tcc*[f]{\servs confirmed registration}){\pks = OK} {
  \textit{\servs} \attrib \getPacketFieldValue{\pk, `server'}\tcc*[r]{Gets \servs in \pk}
  \textit{\setpk} \attrib \getPacketFieldValue{\pk, `flow'}\tcc*[r]{Gets \setpks in \pk}
  \If(\tcc*[f]{Reply to \subsetcli$($\repass$)$, waiting for \setpk}){\setpks $\neq$ NULL}{
    \If(\tcc*[f]{Section~\ref{subsec:obterchavepublica}}){\servs enabled security layer} {
      \getAndStoreServerPublicKey{\serv}\;
    }
    \textit{channel} \attrib \createMulticastChannel{\serv, \setpk}\;
    \updateFlowReceptionTable{\textit{channel}}\tcc*[r]{Section~\ref{subsec:tabela-recepcao}}
    \label{algo-line:updateFlowReceptionTable}
    \tcc{Let \clis $\in$ \subsetcli$($\repass$)$ know the multicast channel to receive \setpks (Section~\ref{subsec:conexao-requisicao}).}
    \respondToClients{\GMTPRequestReply{\textit{channel}}}\;
    \label{algo-line:respondToClients3}
    \tcc{Start to relay \setpks to clients (Section~\ref{subsec:trocdados}).}
    \startRelay{\textit{channel}}\;
    \label{algo-line:startRelay}
  }
  \tcc{It was just a reply of a registration of participation. Update flow reception table.}
  \updateFlowReceptionTable{\textit{\serv}}\tcc*[r]{Section~\ref{subsec:tabela-recepcao}}
} \Else() {
  \tcc{\servs refused to accept the registration of participation. This \repasss must notify the clients waiting for receiving \setpk.}
  \textit{errorCode} \attrib \getPacketFieldValue{\pk, `error'}\;
  \respondToClients{\GMTPRequestReply{\textit{errorCode}, \setpk}}\;
  \label{algo-line:respondToClients4}
}

\end{algorithm}
\vspace{0.8cm}

Por fim, salienta-se que o registro de participação do GMTP permite que quanto
mais nós \repasss se registrarem em nós \serv, mais caminhos \setwayis sejam
conhecidos. Quanto mais caminhos forem conhecidos, mais parcerias poderão ser
formadas entre os nós \repass. Quanto mais parcerias forem formadas, maior será
o número de nós \clis capazes de receber um fluxo de dados \setpks originado em
\serv, disponibilizado indiretamente através dos seus respectivos nós \repass,
sem nenhuma influência da camada de aplicação. No mundo real (Internet), os nós
\repasss podem passar a constituir dinamicamente a rede de distribuição de
conteúdos de uma empresa. Por exemplo, um usuário de uma conexão residencial
xDSL pode configurar seu roteador para registra-lo em múltiplas
redes de distribuição, como ilustrou-se na Figura~\ref{fig:tela-gmtp-inter}.
Nesses casos, as redes de distribuição podem fazer uso do roteador desse usuário
em momentos ociosos de recepção e transmissão de dados através da Internet. Como
consequência, relações comerciais podem ser construídas entre o usuário e os
provedores de rede, mas essa discussão está fora do escopo deste trabalho.

\subsubsection{Manutenção do registro de participação:}
\label{subsec:manutencao-conexao}

Após o registro de participação, o nó \repasss deve enviar periodicamente
sinalizações de controle sobre sua participação na rede de favores $\eta$.
Este procedimento deve ser feito usando o pacote do tipo
\pac{GMTP-Ack} em um tempo $t = max(300, t_{user})$, onde $t_{user}$ é definido
em segundos e corresponde a um tempo definido
pelo administrador do nó \repass, caso deseje um tempo menor que \ut{300}{s}
para mantém o registro de participação ativo. Quando \servs receber um pacote do
tipo \pac{GMTP-Ack} do nó \repass, este deve enviar um pacote do mesmo tipo.
Caso \repasss não receba \pac{GMTP-Ack} no período de $4 \times RTT$, deve-se
repetir tal procedimento por 3 vezes e somente após essas tentativas, o nó
\repasss deve considerar a conexão finalizada por tempo de expiração
(\textit{timeout}) e enviar um pacote do tipo \pac{GMTP-Reset}. Na RFC
5482~\cite{RFC5482}, discute-se sobre outros aspectos de expiração no tempo que
podem ser adaptadas para o GMTP.


\subsection{Tabela de Recepção de Fluxos de Dados}
\label{subsec:tabela-recepcao}

Antes de seguir com a explicação sobre o processo de estabelecimento de conexão
do GMTP, é importante entender que cada nó \repasss mantém uma tabela chamada
\textit{Tabela de Recepção de Fluxos de Dados}, como ilustra-se na
Figura~\ref{fig:tabela-recepcao-1}. O nó \repasss utiliza tal tabela para
registrar todos os fluxos de dados que estão sendo repassados para seus nós
\clis $\in$ \subsetcli$($\repass$)$, mantendo-se as seguintes informações:

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=.55]{imgs/tabela-recepcao-fluxo-1.pdf}
\end{center}
\vspace{-1cm}
\caption{Exemplo de uma tabela de recepção de fluxo mantida por um nó \repass.}
\label{fig:tabela-recepcao-1}
\end{figure}

\begin{itemize}

  \item \textbf{Nome do Fluxo de Dados \setpk:} é uma sequência de
\ut{128}{bits} que determina o nome de um fluxo de dados, como descrito na
Seção~\ref{subsec:content-index};

  \item \textbf{Servidores \serv:} o endereço IP do nó \servs que gera o fluxo
de dados \setpk;

  \item \textbf{Repassadores \repassu{q}:} o endereço IP do nó \repassu{q},
parceiro de \repass, que está transmitindo o fluxo de dados \setpks para
\repass. Se nulo, significa que o fluxo de dados \setpks está sendo recebido
diretamente do nó \serv;

  \item \textbf{Porta de Recepção de \setpk:} o número da porta do nó remoto
que está transmitindo o fluxo de dados \setpks para \repass. Nesse caso, o nó
remoto pode ser o nó \serv, em caso de conexão direta com o servidor, ou um nó
\repassu{q}, parceiro de \repass;

  \item \textbf{Endereço do Canal Multicast:} o endereço IP multicast utilizado
pelo nó \repasss para repassar o fluxo de dados \setpks para os nós clientes
\clis $\in$ \subsetcli$($\repass$)$; e

  \item \textbf{Porta do Canal Multicast:} o número da porta multicast utilizada
pelo nó \repasss para repassar o fluxo de dados \setpks para os nós clientes
\clis $\in$ \subsetcli$($\repass$)$.

\end{itemize}

Conceitualmente, quando um nó \repass adiciona um registro na tabela de
recepção de fluxos de dados, define-se \transmitrs $=$ $1$, ou seja, \repasss
$\in$ \settrans. Um nó \repasss consulta a tabela de recepção de fluxos de
dados quando recebe um
pedido de conexão (\pac{GMTP-Register}) para obter um fluxo de dados \setpk, tal
como apresentou-se na Linha~\ref{algo-line:isFlowBeingReceived} do
Algoritmo~\ref{algo:registerRelay}, Seção~\ref{subsec:registro-participacao}.
Além disso, um nó \repasss atualiza a tabela de recepção de fluxos de dados após
receber uma confirmação do registro de participação, tal como apresentou-se na
Linha~\ref{algo-line:updateFlowReceptionTable} do
Algoritmo~\ref{algo:onReceiveGMTPRegisterReply},
Seção~\ref{subsec:registro-participacao}. Mais adiante, na
Seção~\ref{subsec:conexao-requisicao}, discute-se em mais detalhes as ações de
consulta e atualização da tabela de recepção de fluxos de dados.

\subsection{Formação de Parcerias}
\label{sec:descparc}

Dado que as parcerias ocorrem entre os nós \repasss $\in$ \setrepasss
e não entre os nós \clis $\in$ \setcli, no GMTP, a formação de parcerias
consiste em determinar intersecções de caminhos \setwayi, considerando o nó
\textit{pivot} \servs e diversos nós \repasss interessados em obter \setpk, a
pedido de seus nós \clis $\in$ \subsetcli$($\repass$)$. Este processo pode
ocorrer antes e durante a transmissão de um fluxo de dados \setpks gerado por um
no \serv, de forma transparente para a aplicação em execução em \cli, durante
seu pedido de conexão transmitido em direção ao nó \serv. Como consequência,
constitui-se um ou mais caminhos \setwayis $\in$ \setway, os quais interconectam
um nó \servs e os nós \clis $\in$ \subsetcli(\way), tal que
$\exists$\setwayis $\mid$ \ways $\in$ \setwayi. Como regra geral para formação
de parcerias, definem-se três critérios:

\begin{enumerate}

  \item o melhor nó \servs para servir um nó \repasss é aquele que está
especificado em seu pedido de registro de participação, respeitando-se as
regras de balanceamento de carga definida pela CDN. Em geral, o servidor DNS
define tais regras com base no endereço (IP) do nó solicitante;

  \item se \transmitqu{\way} $=$ $1$, então \ways pode agir como se fosse um nó
\serv;

  \item se o nó \ways $\in$ \setwayi, tal que \setwayis é parte ou
todo do caminho entre \repasss e \serv; e se \ways se enquadra no Item 2, então
o melhor nó \servs para servir \repasss será o mesmo que serve o nó \way.

\end{enumerate}


\begin{figure}[ht]
\begin{center}
\includegraphics[scale=.5]{imgs/esquema-abstrato-formacao-parceria-intra.pdf}
\end{center}
\vspace{-0.8cm}
\caption{Cenário e passos para seleção de nós (exemplo 1).}
\label{fig:esquema-abstrato-formacao-parceria-intra}
\end{figure}

% $\{$\setwayiu{1}, \setwayiu{2}, $\dots$ \setwayiu{\setwayii}$\}$

Para entender detalhes desse processo, considere a
Figura~\ref{fig:esquema-abstrato-formacao-parceria-intra}. No Passo 1,
ilustra-se um cenário de rede \nets $=$ $G($\setservrepass, \setway$)$, onde
\setservrepasss $=$ $\{$\servu{1}, \repassu{1..19}$\}$, \setways $=$
$\{\emptyset\}$ e \transmission $=$ $\{\{\emptyset\}$, $\{\emptyset\}$,
$\{\emptyset\}\}$, ou seja, sem qualquer fluxo de dados \setpks sendo
transmitido, tampouco nenhuma parceria efetivada e suprimindo-se os nós \clis
$\in$ \subsetcli$($\repassu{1..19}$)$. Já no Passo 2, ilustra-se a mesma rede
\net, porém com \transmission $=$ $\{\{$\servu{1}, \repassu{5..9}$\}$, \setpk,
\subsetcli$($\repassu{9}$)\}$, constituindo-se o caminho \setwayiu{1} $=$
$\{$\servu{1},...,\repassu{9}$\}$ (linha tracejada e vermelha) e, portanto,
\setway $=$ $\{$\setwayiu{1}$\}$ com \transmitqu{\repassu{9}} $=$ $1$. Nesse
exemplo do Passo 2, o nó \repassu{9} recebe o fluxo de dados \setpks em modo
unicast e repassa \setpks para todos os nós \clis $\in$
\subsetcli$($\repassu{9}$)$ em modo multicast. Para constituir o caminho
\setwayiu{1}, o nó \repassu{9} deve transmitir o pedido de registro de
participação ao nó \servu{1} (como discutiu-se na
Seção~\ref{subsec:registro-participacao}) e, a partir de sua confirmação,
processada pelo nó \servu{1} e enviada ao nó \repassu{9}, este começa a receber
os pacotes \pks $\in$ \setpk. Com este procedimento, o nó \servu{1} passa a
conhecer o caminho \setwayiu{1}, que pode ser utilizado para determinar futuras
parcerias. Desse ponto em diante, utilizar-se-á tal exemplo como base para
explicar outros aspectos do processo de formação de parceria do GMTP.

Na Figura~\ref{fig:esquema-abstrato-formacao-parceria-interseccao}, considera-se
a formação de parceria por intersecção do fluxo de dados \setpk, a partir
do Passo 2 da Figura~\ref{fig:esquema-abstrato-formacao-parceria-intra}.
Este procedimento ocorre quando um outro nó \repasss envia um pedido de
registro de participação em direção ao nó \servu{1}, a fim de obter o fluxo de
dados \setpk, motivado por algum nó \clis $\in$ \subsetcli$($\repass$)$. Nesse
caso, se um nó \repasss transmitir um pedido de registro de participação através
de um sub-caminho \setwayids tal que $\exists$\setwayis $\in$ \setway, o
nó \servs determina a intersecção de ambos e instrui o nó comum \ways a
repassar o fluxo de dados \setpks também para \repass, sem a necessidade de
enviar um segundo fluxo de dados na mesma direção de \setwayid. Sendo assim, a
resposta de \servu{1} não resulta em uma nova transmissão do fluxo de dados
\setpk, mas sim em uma mensagem de controle para o nó \way, após identificá-lo
como o nó comum a dois ou mais caminhos \setwayi. Isto implicará que o referido
nó \ways replique o fluxo de dados \setpk, mesmo quando $|$\subsetcli$($\way$)|$
$=$ $0$, mas de modo conveniente para evitar múltiplas transmissões do
fluxo de dados \setpk, originadas no nó \serv. A fim de compreender o
funcionamento desse procedimento, acompanhe a explicação a seguir, com base na
ilustração da Figura~\ref{fig:esquema-abstrato-formacao-parceria-interseccao} e
no caminho \setwayiu{1}.

\begin{figure}
\begin{center}
\includegraphics[scale=.5]{imgs/esquema-abstrato-formacao-parceria-interseccao.pdf}
\end{center}
\vspace{-0.8cm}
\caption{Cenário para seleção de nós por interseção de caminhos \setwayi.}
\label{fig:esquema-abstrato-formacao-parceria-interseccao}
\end{figure}

Se qualquer um dos nós \repassu{7,8,10,11,12}, suponha \repassu{11}, enviar um
registro de participação em direção à \servu{1} para obter um fluxo de dados
\setpks (Passo 3 da
Figura~\ref{fig:esquema-abstrato-formacao-parceria-interseccao}), o nó
\servu{1} descobrirá o caminho \setwayiu{2} $=$ $\{$\repassu{5}, \repassu{6},
\repassu{7}, \repassu{10}, \repassu{11}$\}$ (Passo 4). Em seguida, pela
intersecção $($\setwayiu{1} $\cap$ \setwayiu{2}$)$, o nó \servu{1} determinará
que o nó \repassu{7} é o nó comum e portanto instruirá que \repassu{7} repasse o
fluxo de dados \setpks também para o nó solicitante \repassu{11}. A instrução de
\servu{1} para \repassu{7} deve determinar \transmitqu{\repassu{7}} $=$ $1$.
Em termos práticos, isto obriga o nó \repassu{7} a adicionar uma nova entrada na
tabela de recepção de fluxos de dados referente a \setpk, mesmo se
$|$\subsetcli$($\repassu{7}$)|$ $=$ $0$ para \setpk. É óbvio que, se
posteriormente $|$\subsetcli$($\repassu{7}$)|$ $>$ $0$ para \setpk, será
necessário apenas \repassu{7} criar um canal multicast para a transmissão
local de \setpk, evitando-se um novo registro de participação em \servu{1}. Na
Seção~\ref{subsec:conexao-requisicao}, discute-se em mais detalhes este aspecto
do GMTP, explicando-se os procedimentos de pedido de conexão de um nó \cli.

Ao estender a discussão sobre o cenário ilustrado na
Figura~\ref{fig:esquema-abstrato-formacao-parceria-interseccao}, percebe-se que
se o nó \repassu{10} necessitar obter o mesmo fluxo de dados \setpk, seu pedido
de registro de participação será interceptado pelo nó \repassu{7} e parte do
procedimento supracitado se repete. Uma situação similar ocorre se o nó
\repassu{12} ou qualquer nó \repasss $\in$ \setwayiu{4} também desejar obter o
fluxo de dados \setpk, tal que \setwayiu{4} $=$ $\{$\repassu{1},
\repassu{2}, \repassu{3}, \repassu{4}$\}$ (Passo 5 e 6). Para o caso do nó
\repassu{12}, o nó \repassu{11} interceptará o pedido de registro de
participação de \repassu{12}, ao passo que se for qualquer nó \repasss $\in$
\setwayiu{4}, o nó \repassu{6} realizará tal interceptação, pois o nó
\servu{1} determinará \transmitqu{\repassu{6}} $=$ $1$, depois do
primeiro pedido de registro de participação originado por qualquer nó \repasss
$\in$ \setwayiu{4}. A única diferença nesses últimos casos é que,
como \transmitqu{\repassu{7}} $=$ $1$ e \transmitqu{\repassu{11}} $=$ $1$, o nó
\repassu{7} tem autonomia para responder ao nó \repassu{10} e ao nó \repassu{11}
como se fosse o nó \servu{1}, sem repassar tal pedido em direção ao nó
\servu{1}.

Para generalizar essa discussão sobre o processo de formação de parcerias do
GMTP, caso existam outros nós \repassu{q} interessados em obter um fluxo de
dados \setpks e estão interligados direto ou indiretamente a \repass,
tal que \transmitqu{\repass} $=$ $1$, o nó \repasss sempre interceptará o pedido
de registro de participação dos nós \repassu{q} e atuará como se fosse o nó
\servu{1}. No caso do exemplo que se discute, independente da ordem em que as
requisições de registro de participação sejam enviadas por \ways $\in$
(\setwayiu{1} $\cup$ \setwayiu{2} $\cup$ \setwayiu{3} $\cup$ \setwayiu{4}), será
necessário transmitir apenas um fluxo de dados \setpks para ``alimentar'' os
quatro caminhos referidos. Isto significa que todos os nós \clis $\in$
\subsetcli$($\setwayiu{1} $\cup$ \setwayiu{2} $\cup$ \setwayiu{3} $\cup$
\setwayiu{4}$)$ receberão um único fluxo de dados, com repasse dos pacotes \pks
$\in$ \setpks realizado em modo multicast em cada sub-rede de cada nó
\ways (Passo 7). Como a transmissão será em modo multicast, torna-se indiferente
a quantidade de nós \clis desses caminhos, mas faz-se necessário um mecanismo
para controle de congestionamento em modo multicast, a ser discutido na
Seção~\ref{sec:ccgmtp}.

Note que, o nó \repasss que interceptar um pedido de conexão para um fluxo de
dados \setpk, deve transmitir para o nó \servs uma notificação sobre
a(s) parceria(s) formada(s) por intersecção. No caso do exemplo anterior, os nós
\repassu{6}, \repassu{7} e \repassu{11} devem realizar tal notificação enviando
um pacote do tipo \pac{GMTP-Register}, como explicado na
Seção~\ref{subsec:registro-participacao}. Para isso, deve-se
ativar o bit \textit{intercepted} do pacote \pac{GMTP-Register}. Esta ação é
importante devido aos aspectos gerenciais de uma transmissão, onde uma aplicação
poderá contabilizar os nós \repasss que estão recebendo \setpk, mesmo que
indiretamente, por meio da interceptação de registros de participação. Na
prática, não se faz necessário que o nó \repasss envie tal notificação
no instante da interceptação de um pedido de registro de participação. Em vez
disso, pode-se acumular diversos registros de participação durante um
determinado intervalo de tempo e, em seguida, transmiti-los para o nó \serv.
Como se trata de um aspecto a nível de implementação, tal decisão está fora do
escopo dessa discussão. No caso da implementação do GMTP realizada em simulador
e utilizada neste trabalho, definiu-se que para todo registro de participação
interceptado, gera-se e transmite-se uma notificação ao nó \serv.

No Algoritmo~\ref{algo:findPartnerIntersectPath}, resume-se os passos
descritos anteriormente na perspectiva do nó \serv, a fim de determinar a
formação de parcerias por intersecção. Executa-se tal algoritmo quando o nó
\servs recebe um pedido de registro de participação enviado por um nó \repasss
para obter um fluxo de dados \setpk. Através dessa estratégia de formação de
parceria, permite-se repasses de pacotes de dados levando-se em consideração o
nome do fluxo de dados de interesse e não o nó que o produz e transmite. Em todo
caso, o destino da requisição é sempre o nó servidor, garantindo-se que se
nenhum nó repassador interceptar o pedido de registro de participação, com
certeza tal pedido alcançará o nó servidor e o estabelecimento de conexão
ocorrerá normalmente. Esta decisão é fundamental para manter a compatibilidade
com as aplicações de rede existentes na Internet.

% O nó \servs compara os caminhos conhecidos
% \setwayis $\in$ \setways com o caminho \textit{\setwayiu{\repassconst_\repassi}}
% contido no pedido de conexão transmitido por \repass. Se \servs encontrar um nó
% \ways em comum entre algum \setwayis e
% \textit{\setwayiu{\repassconst_\repassi}}, \servs instrui o nó \ways a
% interceptar os próximos pedidos de registro de participação para obter \setpk;
% caso contrário, \servs aceita o novo pedido de conexão, permitindo-se futuras
% parcerias por intersecção. Note que, após este procedimento, o nó \servs passa a
% conhecer o caminho \textit{\setwayiu{\repassconst_\repassi}}.

\begin{algorithm}[H]
\label{algo:findPartnerIntersectPath}
\SetAlgoLined
\caption{handleRegisterParticipation(\repass: PeerRelay, \pks $=$
\pac{GMTP-Register})}
\tcc{\servs executes this algorithm to finds the first node \ways common to a
known path \setwayis and the path \setwayiu{\repassconst_\repassi}. \setwayis is
already used for transporting \setpks to node in $\delta($\way, \setwayi$)$, and
\setwayiu{\repassconst_\repassi} contains all nodes between \repasss (requester)
and \serv. The packet \pks carries \setwayiu{\repassconst_\repassi} and the
\setpks flow name.}
\textit{done} \attrib \textit{false}\tcc*[r]{It becomes true when \ways is found}

\SetKwFunction{Union}{Union}\SetKwFunction{makePkt}{makePkt}
\SetKwFunction{Union}{Union}\SetKwFunction{getPacketFieldValue}{getPacketFieldValue}
\SetKwFunction{Union}{Union}\SetKwFunction{recvPktRdt}{recvPktRdt}
\SetKwFunction{Union}{Union}\SetKwFunction{sendPktRdt}{sendPktRdt}
\SetKwFunction{Union}{Union}\SetKwFunction{length}{length}
\SetKwFunction{Union}{Union}\SetKwFunction{getKnownPathsOfFlow}{getKnownPathsOfFlow}
\SetKwFunction{Union}{Union}\SetKwFunction{GMTPRegisterReply}{GMTPRegisterReply}

\textit{\setpk} \attrib \getPacketFieldValue{\pk, `flow'}\tcc*[r]{Extracts \setpks in \pk}
\textit{\setwayiu{\repassconst_\repassi}} \attrib \invert{\getPacketFieldValue{\pk, `path'}}\;
\textit{\setwayiu{\setpkc}} \attrib \getKnownPathsOfFlow{\setpk}\tcc*[r]{\setwayiu{\setpkc} $\subset$ \setway}
% \tcc*[r]{For a given flow and all the known paths \setways in this \serv, get a sub set of paths used to transmit \setpk}

\ForEach{\setwayis $\in$ \setwayiu{\setpkc}}{
    \ForEach{\ways $\in$ \setwayi} {
      \If(){\ways $\in$ \textit{\setwayiu{\repassconst_\repassi}}} {
        \tcc{The node \ways is common in \setwayis and in \textit{\setwayiu{\repassconst_\repassi}}.}
        \textit{done} \attrib \textit{true}\;
        break\;
      }
    }
    \If(){\textit{done}} {
% \tcc{Create a \pac{GMTP-Response} and send it to \way. After receiving \textit{\pk}, \ways becomes a relay of the flow \setpk.}
% \pks \attrib \makePkt{\pac{GMTP-Response}(1), \ways}\;
      \tcc{\servs stores \textit{\setwayiu{\repassconst_\repassi}} as a known path and replies to \repass, asking \ways to act as a relay for \setpk. \servs actives flag 'relay' of the \pac{GMTP-RegisterReply}.}
      \setwayiu{\setpkc}[\length{\setwayiu{\setpkc}}] \attrib \textit{\setwayiu{\repassconst_\repassi}}\;
      \Return{\GMTPRegisterReply{\way, relay=1}}\;
% \sendPktRdt(\pk)\;
% \exit{}\;
    }
}
\tcc{\servs must register \textit{\setwayiu{\repassconst_\repassi}} as a known path and reply to \repasss by accepting its connection request, since no node \ways is intersecting \textit{\setwayiu{\repassconst_\repassi}}. In this case, \servs starts the transmission of \pks $\in$ \setpks to \repass.}
\setway[\length{\setway}] \attrib \textit{\setwayiu{\repassconst_\repassi}}\;
\Return{\GMTPRegisterReply{\repass, relay=0}}\;
% \pks \attrib \makePkt{\pac{GMTP-Response}(0), \repass}\;
% \sendPktRdt(\pk)\;

\end{algorithm}
\vspace{0.8cm}

Com relação à praticidade do processo de formação de parcerias empregado no
GMTP, um aspecto técnico muito importante deve ser ressaltado: apenas o nó
\repasss que repassar \pks $\in$ \setpks para seus nós \clis $\in$
\subsetcli$($\repass$)$ deve manter uma entrada sobre \setpks na tabela de
recepção de fluxos de dados, exceto quando sinalizado pelo nó \serv, como é o
caso dos nós \repassu{6} e \repassu{7} do exemplo anterior. Além disso, como a
transmissão de um fluxo de dados \setpks entre um nó \repasss e seus nós \clis
$\in$ \subsetcli$($\repass$)$ ocorrerá sempre em modo multicast, faz-se
necessária apenas uma entrada na tabela de recepção de fluxos de dados sobre
\setpk. Com essa estratégia, deve-se esperar uma quantidade significativa de nós
\clis capazes de reproduzir um fluxo de dados \setpk, sem sobrecarregar a rede
com demasiadas transmissões do mesmo fluxo de dados \setpk, além de reduzir o
tempo de inicialização para reproduzir o fluxo de dados \setpks (\textit{startup
delay}). Ademais, apresentou-se procedimentos que não são adotados em nenhum
protocolo de rede pesquisa no estado da arte. Trata-se da primeira solução em
que o nó servidor dar suporte aos roteadores no processo de formação de
parcerias, delegando-se para estes a responsabilidade de distribuir um
determinado fluxo de dados \setpk, tudo de forma transparente para as
aplicações. Como resultado, pode-se afirmar que os roteadores passam a
funcionar como se fossem servidores de uma CDN, só que participando
dinamicamente sempre que conveniente.

% \subsubsection{\space\space\space\space\space\space2. Formação de parcerias por
% intersecção de \setwayi}
% \label{subsec:parcintersec}

% \subsubsection{\space\space\space\space\space\space3. Formação de parcerias por
% combinação de \setwayi}
% \label{subsec:parccombina}
%
% O procedimento de formação de parcerias por combinação considera um nó
% \textit{pivot} \servs e consiste em combinar caminhos distintos \setwayiu{1} e
% \setwayiu{2}, tal que \setwayiu{1} $\cap$ \setwayiu{2} $= \{$\serv$\}$, como
% ilustra-se na Figura~\ref{fig:esquema-abstrato-formacao-parceria-combinacao},
% Passo 1. Dessa forma, dado um conjunto de caminhos conhecidos \setway, o nó
% \servs executa as combinações e instrui, por exemplo, dois nós \wayu{1} $\in$
% \setwayiu{1} e \wayu{2} $\in$ \setwayiu{2} a se tornarem parcerios para
% compartilharem o mesmo fluxo de dados \setpk, transmitindo apenas um fluxo de
% dados \setpks para ser distribuídos aos nós \clis $\in$
% $($\subsetcli$($\wayu{1}$)$ $\cup$ \subsetcli$($\wayu{2}$))$. Este procedimento
% resultará na constituição de um caminho \setwayis contendo todos os nós \repasss
% entre os \wayu{1} e \wayu{2}. Como consequência, pode-se repassar o mesmo fluxo
% \setpks também para outros nós \clis $\in$ \subsetcli$($\repass$)$.
%
% \begin{figure}[ht]
% \begin{center}
% \includegraphics[scale=.5]{imgs/esquema-abstrato-formacao-parceria-combinacao.pdf}
% \end{center}
% \vspace{-0.8cm}
% \caption{Cenário e passos para seleção de nós por combinação de caminhos
% \setwayi.}
% \label{fig:esquema-abstrato-formacao-parceria-combinacao}
% \end{figure}
%
% % Tal procedimento pode ajudar os nós \repasss a expandirem
% % suas parcerias, incluindo a possibilidade de obter pacotes de dados \pks $\in$
% % \setpks de múltiplos nós parceiros \repassu{q}.
%
% Com o registro de participação de cada nó \repasss em \serv, o nó \servs
% conhece os caminhos \setwayis $\subset$ \setways através dos quais se
% transmite o fluxos de dados \setpk. Sendo assim, \servs pode determinar
% candidados a parcerios \repassu{q} de um determinado nó \repasss e esse
% procedimento acontece da seguinte forma. Um nó \repasss enviar uma mensagem ao
% nó \servs para solicitando a lista de parceiros
%
% Para isso, o nó
% \servs instrui
% os nós \wayu{1} e \wayu{2} a executarem um algoritmo para determinar se
% \wayu{1} servirá \wayu{2} ou se \wayu{2} servirá \wayu{1}. Note que é possível
% que a parceria entre \wayu{1} e \wayu{2} não ocorra. Por exemplo, \wayu{1} se
% tornará parceiros de \wayu{2} apenas se o custo entre \wayu{1} e \wayu{2} for
% menor do que o custo entre \wayu{1} e \serv.
%
%  a
% execução da formação de parceria por combinação, o nó \servs envia um pacote do
% tipo \pac{GMTP-Partnership} aos nós \repass, escolhidos dentre os que estão
% conectados e recebendo o fluxo de dados \setpks diretamente de \serv, para
% executarem o Algoritmo~\ref{algo:findPartnerCombinePath}. Em geral funciona com
% base em busca binária, tendo como critério o custo entre $\zeta($\setwayiu{1}$)$
% e $\zeta($\setwayiu{2}$)$  da seguinte forma. O nó \servu{2} processa os
% caminhos
% \setwayis conhecidos e determina quais são os melhores parceiros \repassu{q}
% para um determinado nó \repass, sendo tal informação enviada para \repass. No
% caso do cenário ilustrado na
% Figura~\ref{fig:esquema-abstrato-formacao-parceria-combinacao}, Passo 2, é
% possível combinar os caminhos \setwayiu{1} e \setwayiu{2} pelos nós \repassu{6}
% e o \repassu{15}. Ao combinar dois caminhos \setwayiu{1} e \setwayiu{2}, sempre
% haverá duas direções para a transmissão do fluxo de dados \setpk, uma ilustrada
% no Passos 3 e outra ilustrada no Passo 4 da
% Figura~\ref{fig:esquema-abstrato-formacao-parceria-combinacao}. Para decidir
% qual opção escolher, o nó \servu{2} compara os custos $\zeta($\setwayiu{1}$)$ e
% $\zeta($\setwayiu{2}$)$. Se $\zeta($\setwayiu{1}$) \geq \zeta($\setwayiu{2}$)$,
% então o nó \servu{2} solicita que \repassu{9} envie um pedido de conexão para
% \repassu{16} (Passo 4). Por fim, o nó \repassu{15} deve enviar uma notificação
% para o nó \servu{2} informando sobre a constituição do novo caminho \setwayi. Em
% caso de $\zeta($\setwayiu{1}$) \leq \zeta($\setwayiu{2}$)$, então o nó \servu{2}
% solicitará que \repassu{16} envie um pedido de conexão para \repassu{9} (Passo
% 3), ao passo que o restante do procedimento ocorrerá de forma similar ao que
% acabara de ser explicado.
%
% Esta é a grande motivação da formação de parceria por combinação, pois quando o
% pedido de conexão do nó \repassu{9} alcançar o nó \repassu{15}, este o
% interceptará e, nesse instante, constitui-se um novo caminho \setwayis $=
% \{$\repassu{15}$,$\repassu{14}$,$\repassu{6}$,$\repassu{7}$,$\repassu{8}$,
% $\repassu{9}$\}$.
%
% É importante salientar que o pedido de conexão enviado pelo nó \repassu{9}
% para o nó \repassu{15} deve conter uma sinalização (\textit{flag}) que
% instruirá o nó \repassu{6} a não interceptar tal pedido de conexão. Para
% tal sinalização, dá-se o nome de \textit{ignorar pedido de conexão},
% do inglês \textit{bypass connection request}.
%
% Nessa estratégia de formação de parceria, permite-se que um nó \repasss obtenha
% os pacotes \pks $\in$ \setpks de duas ou mais fontes distintas. No caso do
% exemplo supracitado, o nó \repassu{6} pode continuar recebendo o fluxo de dados
% através do caminho \setwayiu{1} e também através do novo caminho \setwayis que
% acabara de ser constituído.
%
% Nesse contexto, para realizar a formação de parceria por combinação, o nó \servs
% executa o Algoritmo~\ref{algo:findPartnerCombinePath}.\\
%
% \begin{algorithm}[H]
% \label{algo:findPartnerCombinePath}
% \SetAlgoLined
% \KwData{\textit{relayPartners} \attrib [ ]}
%
% \SetKwFunction{Union}{Union}\SetKwFunction{make_pkt}{make\_pkt}
% \SetKwFunction{Union}{Union}\SetKwFunction{recv_pkt_rdt}{recv\_pkt\_rdt}
% \SetKwFunction{Union}{Union}\SetKwFunction{send_pkt_rdt}{send\_pkt\_rdt}
% \SetKwFunction{Union}{Union}\SetKwFunction{getKnownPaths}{getKnownPaths}
% \SetKwFunction{Union}{Union}\SetKwFunction{matchSimilarPath}{matchSimilarPath}
% \SetKwFunction{Union}{Union}\SetKwFunction{parse_path}{parse\_path}
% \SetKwFunction{Union}{Union}\SetKwFunction{length}{length}
%
% mspf \attrib 0.4\tcc*[r]{paths are considered similar if similarity level is
% equal or above mspf value}
% pathSet \attrib \getKnownPaths{}\tcc*[r]{get \setways known in this \serv}
%
% \ForEach{\setwayiu{x} $\in$ \setway}{
%   \If(){\matchSimilarPath{\setwayiu{x}, \setwayis} >= mspf}{
%     \tcc{Get the closest partner in the path (intersection between \setwayiu{x}
% and \setwayi) and add to the list of prospective partners for \repass.}
%
%     prosRelay = NULL\;
%     \ForEach{\ways $\in$ \setwayiu{x}} {
%       \If(){\ways $\in$ \setwayi} {
% 	\textit{relayPartners}[\length{relayPartners}] \attrib prosRelay\;
%       }
%     }
%   }
% }
%
% pkt $ \leftarrow$ make\_pkt(GMTP\_ADV\_RELAY(\textit{relayPartners}), \repass)\;
%
% send\_pkt\_rdt(pkt)\;
%
% \caption[matchPartnersByPathCombination(\setwayi,
% \repass)]{matchPartnersByPathCombination(\setwayi, \repass)}
% \end{algorithm}
% \vspace{0.8cm}

\section{Transmissão de \pks $\in$ \setpks através de \net}
\label{sec:asptransrecep}

No GMTP, transmite-se os pacotes de dados \pks $\in$ \setpks utilizando uma
estratégia híbrida \textit{push/pull}. Utiliza-se o método \textit{push} por
padrão, onde os nós \servs iniciam a transmissão de \pks $\in$ \setpks para os
demais nós \ways $\in$ \setwayi. Já o método \textit{pull} é utilizado somente
quando um nó \clis precisa obter parte de uma mídia que está na iminência de ser
reproduzida e ainda não foi repassada por um nó \repasss via \textit{push}, de
acordo com o seu mapa de \textit{buffer}.

% Os nós \repasss mantêm um mapas de
% \textit{buffer}, sendo que um no \repasss sempre terá um mapa de \textit{buffer}
% mais atualizado do que os mapas de \textit{buffer} dos nós \clis $\in$
% \subsetcli$($\repass$)$.

Nessa seção, apresentam-se detalhes sobre como se realiza a disseminação de
pacotes de dados \pks $\in$ \setpks e como os nós \clis recebem tal conteúdo
para reprodução, discutindo-se aspectos sobre indexação, requisição, recepção e
compartilhamento de um fluxo de dados \setpk.

\subsection{Indexação de Conteúdo}
\label{subsec:content-index}

No GMTP, um fluxo de dados \setpks tem um nome único que o identifica em
qualquer nó, seguindo o princípio das redes centradas no conteúdo. Na
prática, cada fluxo de dados \setpks corresponde a uma mídia gerada a partir de
um evento real \event, por exemplo, a transmissão de um jogo de futebol, corrida
de fórmula 1 etc.

No GMTP, define-se um nome de um fluxo de dados \setpks por um código de
\textit{hash} no formato UUID (\textit{Universally Unique IDentifier}) de 128
bits~\cite{RFC4122}. Na sua forma canônica, representa-se \setpks por uma
sequência de 32 dígitos hexadecimal, exibidos em cinco grupos separados por
hífen, na forma de \{8\}-\{4\}-\{4\}-\{4\}-\{12\}. Por exemplo, \setpks $=$
641f931f-d3ac-50e3-b625-537574541f1f. O nome de um fluxo de dados \setpks sempre
será informado no campo \textit{nome do fluxo de dados} (\textit{data flow
name}), disponível no cabeçalho de transporte dos pacotes \pac{GMTP-Register},
\pac{GMTP-Request}, \pac{GMTP-Data} e \pac{GMTP-Ack}.

Na prática, para gerar o nome para um fluxo de dados \setpk, utiliza-se uma
função de \textit{hash} do tipo SHA1. Sendo assim, para determinar o nome
de um fluxo de dados \setpk, disponibilizado por um servidor \serv, utiliza-se
MD5(IP$_{\servconst_\servi}$ + : + PORTA$_{\servconst_\servi}$). Por exemplo,
suponha que um servidor esteja disponibilizando um fluxo de dados \setpks
através do endereço 200.17.113.98, na porta 21200. O nome do fluxo de
dados \setpks será definido por \textit{MD5("200.17.113.98:21200") =
f8ea01fd-4d71-5d95-89ec-35646e11d7fe}. Opcionalmente, o nó \servs pode divulgar
o nome do fluxo de dados através do serviço DNS. Já com relação ao
título do conteúdo e sua descrição, tais informações podem ser divulgadas por
meio de um serviço web, ou por meio de uma busca de diretório via um \textit{Web
Services}. Independente da forma que o nó \servs disponibilize os nomes dos
fluxos de dados \setpk, os nós \repasss mantêm a tabela de recepção de fluxo de
dados que estão repassando para seus clientes \clis $\in$
\subsetcli$($\repass$)$ e, sendo assim, podem compartilhá-la para outros nós
repassadores. Dessa forma, o GMTP não requer alteração na camada de aplicação
para informar o fluxo de dados de interesse -- a aplicação continua informando
endereço IP e número da porta, mantendo-se a compatibilidade com as aplicações
existentes.

De posse de um identificador de um fluxo de dados \setpk, um nó GMTP poderá
solicitar os pacotes de dados \pks $\in$ \setpk. No caso do uso do DNS, o nó
\servs divulga os identificadores de todos os eventos sendo transmitido
por meio de um mecanismo de atualização dinâmica de registro de DNS, como
especificado na RFC 2136~\cite{RFC2136}. Para o GMTP, criou-se um novo
tipo de registro de DNS chamado de SID (\textit{Streaming IDentifier}).

No Quadro~\ref{algo:requestDNS}, ilustra-se um exemplo de uma requisição DNS,
utilizando a ferramenta \textit{dig}, um comando de terminal para Linux. Nesse
exemplo, apresenta-se a lista dos nomes dos fluxos de dados transmitidos pelo
domínio administrativo \textit{globo.com}. Por ser uma consulta simples de DNS,
qualquer sistema final conectado à Internet pode realizar tal procedimento,
enaltecendo-se a facilitar de adaptar aplicações multimídia existentes para
utilizar o GMTP. Ao indexar o conteúdo através de um serviço de DNS, permite-se
desacoplar a forma de indexar um determinado conteúdo e a forma de obtê-lo, que
passa a ser de responsabilidade da infra-estrutura de rede e não de uma
ou mais aplicações isoladamente. Isto pode permitir o aumento das aplicações
multimídia sem se preocupar como localizar um determinado conteúdo,
extrapolando-se as barreiras administrativas de cada sistema de geração de
conteúdos multimídia, bastando para isso apenas todas as aplicações utilizarem
o protocolo GMTP. Consequentemente, um fluxo de dados \setpk, gerado por uma
aplicação qualquer APL1, em execução em um nó \serv, poderá ser reproduzido por
uma aplicação APL2, em execução em um nó \clis independentemente de que as
desenvolveu. Isto somente é possível porque o GMTP também oferecer uma função
para descrever a mídia transmitida em um fluxo de dados \setpk.

\vspace{0.5cm}

\newcommand{\bigspace}{~~~~~}

\begin{algorithm}[H]
\label{algo:requestDNS}
\SetAlgoLined
\SetAlgorithmName{Quadro}{quadro}{.}

\caption{Exemplo de requisição e resposta da lista de nomes dos fluxos de dados
\setpks de um distribuidor de conteúdos multimídia.}

\textbf{dig} -t SID globo.com\tcc*[r]{comando de requisição}
\textbf{QUESTION SECTION:}\\
\bigspace globo.com.\bigspace IN\bigspace SID\\

\textbf{ANSWER SECTION:}\\
\bigspace globo.com.\bigspace IN\bigspace SID\bigspace
"111f931f-d3ac-10e3-b62f-f17f74541f1f"\\
\bigspace globo.com.\bigspace IN\bigspace SID\bigspace
"72c44591-7d82-427c-825f-722f015787c1"\\
\bigspace globo.com.\bigspace IN\bigspace SID\bigspace
"0bb0b9f5-f57d-4da5-8a6c-13acf1965188"\\

\textbf{SUMMARY:}\\
\bigspace Query time: 4 msec\\
\bigspace SERVER: 192.168.1.252:53(192.168.1.252)\\
\bigspace WHEN: Tue Jul 16 15:44:25 2013\\

\end{algorithm}
\vspace{0.8cm}

\subsubsection{Descrição de um fluxo de dados \setpk}
\label{subsubsec:desc-conteudo}

Uma outra caracteristica do GMTP é permitir a descrição da mídia a ser
transmitida e com isso promover a compatibilidade entre diferentes aplicações e
reduzir o tráfego de rede para um mesmo fluxo de dados \setpk. Para isto,
incorporou-se ao GMTP o protocolo o SDP (\textit{Session Description Protocol}),
definido na RFC 2327~\cite{RFC2327}, permitindo-se que as aplicações
consigam obter mais detalhes sobre a mídia transmitida, flexibilizando-se o
acesso a um determinado conteúdo, descrevendo para a aplicação o formato
do conteúdo, que então o decodificará e o reproduzirá ao usuário através da
aplicação final. Com esta decisão, torna-se mais fácil implementar novas
aplicações multimídia, ao passo que também fica mais fácil adaptar aplicações
existentes para fazer uso do GMTP, uma vez que, em sua grande maioria,
utiliza-se o protocolo SDP. Do ponto de vista de engenharia de software, isto
evitará a repetição de esforço com implementações já consolidadas e que, com o
passar dos anos, provou-se funcionar a contento, como foi o caso do SDP.
Consequentemente, caso seja necessário a atualização do referido padrão, tal
atualização será realizada internamente no GMTP e todas as aplicações
automaticamente já poderão usufruir dos novos recursos disponibilizados. Na
prática, isto significa uma atualização a nível de sistema operacional.

No ponto de vista de uma aplicação em execução no nó \serv, esta precisa
apenas determinar as informações da mídia e as fornece ao GMTP através de
passagem de parâmetro via socket GMTP. Em seguida, o GMTP fica pronto para
enviar a descrição da mídia como resposta ao pedido de conexão, dentro do campo
de dados do pacote do tipo \pac{GMTP-Register-Reply} ou \pac{GMTP-MediaDesc}.
Como um nó \repasss pode interceptar um pedido de conexão, \repasss também pode
transmitir a descrição da mídia aos seus nós parceiros \repassu{q}. No
Quadro~\ref{algo:sdp-mediadesc}, apresenta-se um exemplo de uma mensagem SDP e,
a seguir, descreve-se cada um dos possíveis atributos de uma mensagem SDP.

\begin{itemize}

  \item \textit{v}, a versão do SDP;

  \item \textit{o}, a lista de nós \servs que a distribui;

  \item \textit{s}, o nome da mídia, como discutido na
Seção~\ref{subsec:content-index};

  \item \textit{i}, o título da mídia;

  \item \textit{u}, a URI que descreve detalhes sobre a mídia;

  \item \textit{c}, as informações de conexão, como a versão do protocolo de
rede e o endereço do nó \repass;

  \item \textit{f}, o certificado digital emitido pelo nó \servs para
verificação
de autenticidade dos pacotes \pks $\in$ \setpks (opcional). Este assunto
será retomado na Seção~\ref{sec:seguranca};

  \item \textit{m}, o tipo da mídia, a porta de conexão e protocolo de
transporte; e

  \item \textit{a}, atributos adicionais sobre a mídia como, por exemplo,
qualidade, idioma, taxa de bits mínima e máxima necessária para transmitir a
mídia, em bytes.

\end{itemize}

\vspace{0.5cm}

\begin{algorithm}[H]
\label{algo:sdp-mediadesc}
\SetAlgoLined
\SetAlgorithmName{Quadro}{quadro}{.}

\bigspace v=0\\
\bigspace o=- IN IP4 177.135.177.241,
IP4 186.192.82.163, IP6 2001:0db8:85a3::7344\\
\bigspace s=72c44591-7d82-427c-825f-722f015787c1\tcc*[r]{ver
Seção~\ref{subsec:content-index}}
\bigspace i=An Introduction about Global Media Transmission Protocol (GMTP).\\
\bigspace u=http://www.ic.ufal.br/projects/gmtp/introduction.ps\\
\bigspace c=IN IP4 200.17.113.100\\
\bigspace f=x509:http://vid12.akamai.com/certs/cert.crt\tcc*[f]{ver
Seção~\ref{sec:seguranca}}\\
\label{line:sdp-mediadesc:f}
\bigspace m=audio 49170 GMTP/RTP/AVP 16000-20000\\
\bigspace m=video 51372 GMTP/RTP/AVP 163840-655360\\
\bigspace a=type:multicast\\
\bigspace a=sendrecv\\
\bigspace a=quality:10\\
\bigspace a=lang:en\tcc*[f]{ver RFC1766~\cite{RFC1766}}\\
\bigspace a=framerate:23.0\\

\caption{Exemplo de uma mensagem SDP no pacote \pac{GMTP-MediaDesc}.}
\end{algorithm}
\vspace{0.8cm}

No exemplo apresentado no Quadro~\ref{algo:sdp-mediadesc}, utiliza-se a
primeira versão do protocolo SDP e descreve-se a transmissão de dois fluxos de
dados \setpks (Linhas 10 e 11), sendo um de áudio e outro de vídeo.
A distribuição dos fluxos de dados \setpks ocorre com a geração dos pacotes de
dados \pks $\in$ \setpks em três nós \servs (Linha 2), dos quais dois são
acessíveis através de endereços IPv4 e um através de um endereço IPv6. Os fluxos
de áudio e vídeo são repassados por um nó \repass, acessível por um endereço
IPv4 (Linha 6), através das portas $49170$ e $51372$, respectivamente (Linhas 9
e 10). As informações de endereço IP e porta do nó \repasss são utilizadas para
que os nós \clis $\in$ \subsetcli$($\repass$)$ possam sintonizar seus sockets
de conexão e iniciar a reprodução da mídia, através do modo de transmissão
multicast (Linha 10). Em seguida, na Linha 8, observa-se uma URL do certificado
digital a ser utilizado pelo nó \repasss para verificar a autenticidade do
conteúdo de pacote de dados \pks $\in$ \setpks -- na
Seção~\ref{sec:seguranca}, discute-se este assunto em mais detalhes. Por fim,
entre as Linhas 11 e 17 especificam-se outros parâmetros para descrever a mídia,
tais como o nível de qualidade da mídia, que varia entre 1 e 10, as taxas de
bits para cada fluxo de dados, sendo para o áudio variando entre
\ut{16000}{Bytes} e \ut{20000}{Bytes} e, para o vídeo, variando entre
\ut{156250}{Bytes} e \ut{625000}{Bytes}. É importante salientar que os nós
\repasss utilizam as informações de taxa de bits para determinar o tamanho do
buffer necessário para permitir a transmissão da mídia, o que ocorre ao
adicionar uma nova entrada na tabela de recepção de fluxos de dados.

% Além
% disso, o tamanho do buffer é definido em consonância com os parâmetros
% determinados pelo algoritmo de controle de congestionamento executado no módulo
% GMTP-Inter, a ser discutido em detalhes na
% Seção~\ref{sec:ccgmtp}, a seguir.

\subsection{Estabelecimento de Conexão entre \clis e \servs para Obter \setpk}
\label{subsec:conexao-requisicao}

No GMTP, divide-se o processo de estabelecimento de conexão em três fases. A
Fase 1 acontece quando, por exemplo, um nó qualquer \cliu{1} $\in$
\subsetcli$($\repass$)$ deseja obter \setpks transmitido por um nó \servu{1} e
não existe nenhum outro nó \clis $\in$ \subsetcli$($\repass$)$ em sua rede local
recebendo \setpk. Já a Fase 2 acontece quando um outro nó \cliu{2} $\in$
\subsetcli$($\repass$)$ precisa obter o mesmo fluxo de dados \setpk, solicitado
previamente pelo nó \cliu{1}. E, por fim, a Fase 3 acontece quando o nó
\repasss começa a buscar novos nós parceiros \repassu{q} a fim de obter
\setpk. Na Figura~\ref{fig:processo-conexao}, ilustram-se um nó \serv, que gera
um fluxo de dados \setpks e 12 nós \repass, que constituem uma rede de
diferentes domínios administrativos, sendo o nó \repassu{1} o repassador de um
desses domínios, composto por 6 nós \clis $\in$ \subsetcli$($\repass$)$ (Rede
Local).

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=.7]{imgs/processo-conexao.pdf}
\end{center}
\vspace{-1cm}
\caption{Exemplo de rede para o estabelecimento de conexão do \mudccp.}
\label{fig:processo-conexao}
\end{figure}

A regra geral é que um nó \repasss deve consultar a tabela de recepção de fluxo
de dados todas as vezes que receber um pacote do tipo \pac{GMTP-Request} ou do
tipo \pac{GMTP-Register}, transmitido por um nó \clis $\in$
\subsetcli$($\repass$)$. Com base no estado da referida tabela, que define a
fase de conexão para um determinado fluxo de dados \setpks solicitado, o nó
\repasss realiza uma determinada ação de registro de participação e repasse.

\subsection{Fase 1: Primeira Requisição a um Fluxo de Dados \setpk}
\label{subsec:conn-fase1}

A Fase 1 ocorre quando nenhum nó \clis $\in$ \subsetcli$($\repass$)$ está
recebendo um fluxo de dados \setpk. Com base na
Figura~\ref{fig:processo-conexao-1}, onde ilustra-se um exemplo
de conexão na Fase 1, considere:

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=.7]{imgs/processo-conexao-1.pdf}
\end{center}
\vspace{-1cm}
\caption{Passos do processo de estabelecimento de conexão do \mudccps (Fase 1).}
\label{fig:processo-conexao-1}
\end{figure}

\begin{itemize}

  \item \setpk, um fluxo de dados;

  \item \servu{1}, o nó servidor que gera os pacotes de dados \pks $\in$ \setpk;

  \item \repassu{1}, o nó repassador para os clientes \clis $\in$
\subsetcli$($\repassu{1}$)$; e

  \item \cliu{1}, um nó cliente que deseja obter um fluxo de dados \setpk, tal
que \cliu{1} $\in$ \subsetcli$($\repassu{1}$)$.

\end{itemize}

Para obter o fluxo de dados \setpk, o nó \cliu{1} inicia o canal de controle
GMTP (detalhado na Seção~\ref{subsec:canaiscommudccp}) e transmite um pacote do
tipo \pac{GMTP-Request} (Figura~\ref{fig:processo-conexao-1}, Passo 1). Para
construir o pacote do tipo \pac{GMTP-Request}, qualquer nó \clis deve
especificar o valor para o endereço IP de destino como sendo o endereço do nó
\servs que transmite \setpk, com o valor para o campo do cabeçalho de rede
\textit{TTL=1}. Além dos valores para o IP de destino e para o \textit{TTL}, o
nó \clis também deve informar o nome do fluxo de dados \setpks que o usuário
deseja reproduzir, presente no cabeçalho de transporte do pacote do tipo
\pac{GMTP-Request}. O valor de \textit{TTL=1} é intencional, pois faz com que o
nó \repasss intercepte o referido pacote de requisição, evitando-se extrapolar
o domínio administrativo de sua rede local.

Quando o pacote \pac{GMTP-Request} alcançar o nó \repassu{1} (Passo 2 da
Figura~\ref{fig:processo-conexao-1}), este consulta a tabela de recepção de
fluxos de dados e constata que não há qualquer registro para o fluxo de dados
\setpk. Nesse instante, o nó \repasss inicia um processo de registro de
participação para obter o fluxo de dados \setpk. Isto significa que a execução
do procedimento \textit{registerRelay(\serv, \pk)}
(Seção~\ref{subsec:registro-participacao}), onde \pks é o pacote do tipo
\pac{GMTP-Request}, fará o nó \repassu{1} transmitir um pacote do
tipo \pac{GMTP-Register} em direção ao nó \servu{1}. À medida que os nós
\repasss repassam o pacote \pac{GMTP-Register} até alcançar o nó \servu{1},
constitui-se o caminho \setwayiu{1} $=$
$\{$\repassu{1},\repassu{2},\repassu{3},\repassu{4},\repassu{5},\servu{1}$\}$
(Passo 3 da Figura~\ref{fig:processo-conexao-1} e destacado na cor vermelha),
conforme discutiu-se na Seção~\ref{sec:descparc}.

Em seguida, ao receber o pacote do tipo \pac{GMTP-Register-Reply}, como
resposta ao registro de participação, o nó \repassu{1} cria um canal
multicast e envia um pacote do tipo \pac{GMTP-RequestNotify} para um ou mais
clientes \clis $\in$ \subsetcli$($\repassu{1}$)$ (Passo 4 da
Figura~\ref{fig:processo-conexao-1}). Esta notificação sinalizará aos nós
clientes \clis qual canal multicast seus respectivos sockets devem
ser ``sintonizados''. No caso do exemplo supracitado, o no \cliu{1}, após
sintonizar o socket no canal multicast informado pelo nó \repassu{1}, começa
a receber os pacotes de dados \pks do tipo \pac{GMTP-Data} ou \pac{GTMP-DataAck}
(Passo 5 da Figura~\ref{fig:processo-conexao-1}).

No Algoritmo~\ref{algo:respondToClients}, resume-se os passos descritos
anteriormente para iniciar a transmissão dos pacotes de dados \pks $\in$ \setpks
aos nós \clis $\in$ \subsetcli$($\repass$)$, após \repasss receber o pacote do
tipo \pac{GMTP-RequestReply}. Note que, o nó \repasss invoca tal procedimento
nas Linhas~\ref{algo-line:respondToClients1} e~\ref{algo-line:respondToClients2}
do Algoritmo~\ref{algo:registerRelay} e nas
Linhas~\ref{algo-line:respondToClients3} e~\ref{algo-line:respondToClients4} do
Algoritmo~\ref{algo:onReceiveGMTPRegisterReply}
(Seção~\ref{subsec:registro-participacao}). Como resultado da Fase 1, gera-se
uma nova entrada na tabela de recepção de fluxos de dados do nó \repass, tal
como ilustra-se na Figura~\ref{fig:tabela-recepcao-fluxo-11}. Com base no
exemplo citado, a tabela de recepção antes vazia, agora contém uma entrada que
informa a ocorrência de recepção do fluxo de dados \setpks $=$
\textit{72c44591-7d82-427c-825f-722f015787c1}, originado no nó \serv,
cujo endereço é \textit{177.135.177.241}, com porta de recepção \textit{49170}.
Além disso, define-se o canal multicast no endereço
\textit{239.192.68.79} e porta \textit{1900}, através do qual os nós \clis $\in$
\subsetcli$($\repass$)$ podem receber os pacotes de dados \pks $\in$ \setpk.

\vspace{0.8cm}

\begin{algorithm}[H]
\label{algo:respondToClients}
\caption{respondToClients(\pk: \pac{GMTP-RequestNotify})}
\SetAlgoLined
\tcc{A \repasss node executes this Algorithm to respond to clients waiting for
receiving a flow \setpk. This algorithm is invoked in Lines~\ref{algo-line:respondToClients1}
and~\ref{algo-line:respondToClients2} of
Algorithm~\ref{algo:registerRelay} and in
Lines~\ref{algo-line:respondToClients3} and~\ref{algo-line:respondToClients4}
of the Algorithm~\ref{algo:onReceiveGMTPRegisterReply}.}

\SetKwFunction{Union}{Union}\SetKwFunction{getClientsWaitingForFlow}{getClientsWaitingForFlow}
\SetKwFunction{Union}{Union}\SetKwFunction{getCtrlChannel}{getCtrlChannel}
\SetKwFunction{Union}{Union}\SetKwFunction{getMediaDescription}{getMediaDescription}
\SetKwFunction{Union}{Union}\SetKwFunction{setPacketFieldValue}{setPacketFieldValue}
\SetKwFunction{Union}{Union}\SetKwFunction{getPacketFieldValue}{getPacketFieldValue}
\SetKwFunction{Union}{Union}\SetKwFunction{sendPktRdt}{sendPktRdt}
\SetKwFunction{Union}{Union}\SetKwFunction{sendPkt}{sendPkt}
\SetKwFunction{Union}{Union}\SetKwFunction{waitAck}{waitAck}
\SetKwFunction{Union}{Union}\SetKwFunction{startRelay}{startRelay}
\SetKwFunction{Union}{Union}\SetKwFunction{removeClientsWaitingForFlow}{removeClientsWaitingForFlow}

% \clis \attrib \getPacketFieldValue{\pk, `client'}\;
\textit{destAddress} \attrib \getCtrlChannel{}\tcc*[r]{238.255.255.250:1900}
\setPacketFieldValue{\pk, `destinationAddress', destAddress}\;
\textit{\setpk} \attrib \getPacketFieldValue{\pk, `flow'}\tcc*[r]{Extracts \setpks in \pk}

\textit{errorCode} \attrib \getPacketFieldValue{\pk, `errorCode'}\;
\If(){errorCode $\neq$ NULL} {
  \removeClientsWaitingForFlow{\setpk}\tcc*[r]{See Algorithm~\ref{algo:registerRelay}}
  \sendPkt{\pk}\;
  \Return{0}\;
}

\textit{channel} \attrib \getPacketFieldValue{\pk, `channel'}\;
\label{algo-line:respondToClients-getChannel}
\uIf () {\textit{channel} $\neq$ NULL} {
  \tcc{Node \repasss is already receiving \setpks and clients \subsetcli$($\repass$)$ must know the media description.}
  \textit{mediaDescription} \attrib \getMediaDescription{\setpk}\;
  \setPacketFieldValue{\pk, `data', mediaDescription}\;
  \tcc{In Algorithm~\ref{algo:registerRelay}, Line~\ref{algo-line:addClientWaitingFlow}, \clis nodes are added in a list of clients waiting for flow \setpk. Now, \repasss notifies them, wait confirmation (ACKs) from them and start relaying \pks $\in$ \setpks to them through given channel.}
  \sendPkt{\pk}\;
  \subsetcli$($\repass$)$ \attrib \getClientsWaitingForFlow{\setpk}\;
  \waitAck{\subsetcli$($\repass$)$, \setpk}\;
  \label{algo-line:respondToClients-waitAck}
} \Else (\tcc*[f]{Let \subsetcli$($\repass$)$ know \repasss is waiting for registration.}) {
  \setPacketFieldValue{\pk, `waitingRegistration', true}\;
  \sendPkt{\pk}\;
}
\Return{0}\;

\end{algorithm}
\vspace{0.8cm}

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=.55]{imgs/tabela-recepcao-fluxo-11.pdf}
\end{center}
\vspace{-1cm}
\caption{Tabela de recepção de fluxos de dados após a Fase 1.}
\label{fig:tabela-recepcao-fluxo-11}
\end{figure}

\subsection{Fase 2: Próximas Requisições para Obter \setpk}

A Fase $2$ de conexão ocorre quando futuras requisições para obter o
fluxo de dados \setpks são originadas por qualquer nó \clis $\in$
\subsetcli$($\repassu{1}$)$. Considerando o exemplo anterior, citado na Fase 1,
se um nó \cliu{2} $\in$ \subsetcli$($\repassu{1}$)$ também solicitar \setpk, o
nó \repassu{1} simplesmente informará o canal multicast correspondente ao fluxo
de dados \setpk, como ilustra-se na Figura~\ref{fig:processo-conexao-2} (Passo
1 da Figura~\ref{fig:processo-conexao-2}). Para isto, o nó \repassu{1}
intercepta a requisição do nó \cliu{2}, consulta
a tabela de recepção de fluxos de dados e dessa vez constata a recepção do fluxo
de dados \setpk, criando o pacote do tipo \pac{GMTP-Request-Reply} (Passo 2).
Este procedimento ocorre no registro de participação, especificamente no trecho
de código definidos entre as
Linhas~\ref{algo-line:registerRelay-getP}-\ref{algo-line:registerRelay-returnChannel} do
Algoritmo~\ref{algo:registerRelay}. Em seguida, transmite-se o pacote do tipo
\pac{GMTP-Request-Reply} ao nó \cliu{2}, como descreve-se no trecho de código
entre as
Linhas~\ref{algo-line:respondToClients-getChannel}-\ref{algo-line:respondToClients-waitAck} do
Algoritmo~\ref{algo:respondToClients}, que então ``sintoniza'' seu socket para
o canal multicast informado por \repassu{1} (Passo 3). Tal procedimento se
repete para cada novo nó \clis $\in$ \subsetcli$($\repassu{1}$)$ interessado em
obter \setpk.

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=.6]{imgs/processo-conexao-2.pdf}
\end{center}
\vspace{-1cm}
\caption{Passos do processo de estabelecimento de conexão do \mudccps (Fase 2).}
\label{fig:processo-conexao-2}
\end{figure}

\subsection{Fase 3: Busca por Mais Parceiros \repassu{q} para Obter \setpk}
\label{subsec:phase3}


% /////////////////////////////////
%
%
% \subsection{Sobre o melhor caminho \setwayi}
% \label{subsec:melhorcaminho}
%
% LER ISSO DAKI E O QUE ESTÁ SENDO DESCRITO NESSA FASE 3. PENSAR NA IDÉIA DE QUANDO
% O NO REPASS PROCURAR POR MAIS PARCEIROS, USAR
% O CRITÉRIO COM CAMINHOS MAIS FOLGADOS (MAIORES TAXAS DE TRANSMISSÃO)
% %
% % \begin{algorithm}[H]
% % \label{algo:findPartnerIntersectPath}
% % \SetAlgoLined
% % \caption{handleRegisterParticipation(\repass: PeerRelay, \pks $=$
% % \pac{GMTP-Register})}
% % \tcc{\servs executes this algorithm to handle the request for register of
% % participation. It finds the first node \ways common to a known path \setwayis
% % and the path \setwayiu{\repassconst_\repassi}. \setwayis is already used for
% % transporting \setpks to node in $\delta($\way, \setwayi$)$, and
% % \setwayiu{\repassconst_\repassi} is the path composed by all nodes in between
% % \repasss and \serv. The packet \pks carries \setwayiu{\repassconst_\repassi} and
% % the \setpks name.}
% %
% % \SetKwFunction{Union}{Union}\SetKwFunction{makePkt}{makePkt}
% % \SetKwFunction{Union}{Union}\SetKwFunction{getPacketFieldValue}{getPacketFieldValue}
% % \SetKwFunction{Union}{Union}\SetKwFunction{recvPktRdt}{recvPktRdt}
% % \SetKwFunction{Union}{Union}\SetKwFunction{sendPktRdt}{sendPktRdt}
% % \SetKwFunction{Union}{Union}\SetKwFunction{length}{length}
% % \SetKwFunction{Union}{Union}\SetKwFunction{pathsContainingRelayByFlow}{pathsContainingRelayByFlow}
% % \SetKwFunction{Union}{Union}\SetKwFunction{GMTPRegisterReply}{GMTPRegisterReply}
% % \SetKwFunction{Union}{Union}\SetKwFunction{pathPriority}{pathPriority}
% %
% % \textit{\setpk} \attrib \getPacketFieldValue{\pk, `flow'}\tcc*[r]{Extracts \setpks in \pk}
% % \textit{\setwayiu{\repassconst_\repassi}} \attrib \invert{\getPacketFieldValue{\pk, `path'}}\;
% % \textit{\setwayiu{\setpkc}} \attrib \pathsContainingRelayByFlow{\repass, \setpk}\tcc*[r]{\setwayiu{\setpkc} $\subset$ \setway}
% % % \tcc*[r]{For a given flow and all the known paths \setways in this \serv, get a sub set of paths used to transmit \setpk}
% %
% % \setwayiu{selected} \attrib \setwayiu{\repassconst_\repassi}\;
% %
% % \ForEach{\setwayis $\in$ \setwayiu{\setpkc}}{
% %     \If() {\pathPriority{\setwayis > \setwayiu{selected}}} {
% %       \setwayiu{selected} \attrib \setwayi\;
% %     }
% % }
% %
% % \ForEach{\ways $\in$ \setwayiu{selected}} {
% %   \If(){\ways $\in$ \textit{\setwayiu{\repassconst_\repassi}}} {
% %     \tcc{The node \ways is common in \setwayis and in \textit{\setwayiu{\repassconst_\repassi}}.}
% %     \textit{done} \attrib \textit{true}\;
% %     break\;
% %   }
% % }
% %
% %     \If(){\textit{done}} {
% % %       \tcc{Create a \pac{GMTP-Response} and send it to \way. After receiving \textit{\pk}, \ways becomes a relay of the flow \setpk.}
% % %       \pks \attrib \makePkt{\pac{GMTP-Response}(1), \ways}\;
% %       \tcc{\servs stores \textit{\setwayiu{\repassconst_\repassi}} as a known path and replies to \repass, asking \ways to act as a relay for \setpk. \servs actives flag 'relay' of the \pac{GMTP-RegisterReply}.}
% %       \setwayiu{\setpkc}[\length{\setwayiu{\setpkc}}] \attrib \textit{\setwayiu{\repassconst_\repassi}}\;
% %       \Return{\GMTPRegisterReply{\way, relay=1}}\;
% % %       \sendPktRdt(\pk)\;
% % %       \exit{}\;
% %     }
% %
% % \tcc{\servs must register \textit{\setwayiu{\repassconst_\repassi}} as a known path and reply to \repasss by accepting its connection request, since no node \ways is intersecting \textit{\setwayiu{\repassconst_\repassi}}. In this case, \servs starts the transmission of \pks $\in$ \setpks to \repass.}
% % \setway[\length{\setway}] \attrib \textit{\setwayiu{\repassconst_\repassi}}\;
% % \Return{\GMTPRegisterReply{\repass, relay=0}}\;
% % % \pks \attrib \makePkt{\pac{GMTP-Response}(0), \repass}\;
% % % \sendPktRdt(\pk)\;
% %
% % \end{algorithm}
% % \vspace{0.8cm}
%
% De acordo com os procedimentos empregados de seleção de nós, é possível obter
% diferentes caminhos \setwayi, partindo-se de um nó \repasss para um nó \serv.
% Por este motivo, é importante definir, a partir de um conjunto de caminhos
% possíveis, qual é o melhor caminho a utilizar e ordená-los de acordo com a
% prioridade de uso. Com isto, é possível obter \setpks a partir de múltiplos
% \repasss e usar caminhos alternativos em caso de falha de algum caminho, por
% exemplo, por desconexão. No GMTP, utiliza-se os seguintes critérios para
% decidir entre um conjunto de caminhos \setway qual será o escolhido:
%
% \begin{enumerate}
%   \item Quanto mais o caminho \setwayis estiver próximo de ser um caminho
% \setwayif; \label{i:c-waycomp}
%   \item Menor número de nós \ways $\in$ \setwayi; \label{i:c-nnos}
%   \item Escolha aleatória de \setwayis entre os \setways conhecidos.
% \label{i:c-aleat}
% \end{enumerate}
%
% O critério~\ref{i:c-waycomp} é determinado através da verificação da condição
% $\mid$\setwayi$\mid$ $=$ $ttl($\repass$,$\setwayi$)$, onde \textit{ttl} é uma
% função que determina o número de saltos entre o nó \repasss até o nó \serv. Na
% prática, pode-se determinar tal condição comparando-se quantos nós existem no
% caminho \setwayis e o valor do campo TTL (\textit{Time-to-Live}), disponível no
% cabeçalho de qualquer pacote IP. Este critério é o primário porque quanto mais
% nós GMTP estiverem no caminho, maior será a possibilidade de interceptação
% para obter um fluxo de dados \setpk. O critério~\ref{i:c-nnos} é determinado
% pela contagem do número de \ways $\in$ \setwayi. O critério~\ref{i:c-aleat} é
% utilizado em caso de não determinação do melhor \setwayis até o critério
% anterior.
%
% Note que no GMTP é possível que um nó \repasss tenha simultaneamente mais de um
% nó parceiro \repassu{q}, porém não mais do que uma certa qualidade configurável
% devido ao fato de que os pacotes \pks dos fluxos \setpks serem transientes,
% portanto não faz sentido realizar muitas parcerias. No caso do GMTP, a
% quantidade máxima padrão de parcerias que um nós \repasss realiza é $5$, valor
% praticado em outros soluções similares para transmissão de fluxos de dados ao
% vivo baseados em arquitetura P2P.
%
%
%
% /////////////////////////////////


Na Fase $3$, o nó \repasss inicia um processo de aumentar suas parcerias a fim
de obter mais rapidamente os pacotes \pks $\in$ \setpks através de caminhos
\setwayis alternativos.
% , em caso de falha e/ou desconexões de algum nó parceiro
% \repassu{q}.
% Ao
% considerar os aspectos discutido na Seção~\ref{sec:descparc}, nota-se que na
% Fase $1$ e $2$ utiliza-se os modos de formação de parcerias intra \setways e por
% intersecção, porém ainda resta fazer uso do modo de formação de parceria por
% combinação de \setway
% (Figura~\ref{fig:esquema-abstrato-formacao-parceria-combinacao}). Na fase $3$ de
% conexão, o GMTP explora tal recurso.
Nesse contexto, seja um nó \repassu{3} que esteja recebendo \setpks originado
em um nó \serv. Para conseguir mais nós parceiros \repassu{q}, o nó \repassu{3}
envia uma requisição do tipo \pac{GMTP-RelayQuery} para \servs e obtém um
subconjunto de nós \repassu{q} candidatos a parceiro de \repassu{3}, como
ilustra-se na Figura~\ref{fig:conn-phase3-1}. O nó \servs constrói a
lista de nós parceiros e envia ao nó \serv, funcionando como um indexador
(\textit{tracker}) de nós parceiros \repassu{q}, pré-selecionando parcerios para
\repass. No caso do exemplo supracitado, essa pré-seleção ajuda o nó \repassu{3}
a escolher os melhores parcerios disponíveis, de acordo com os seguintes
critérios de prioridade:

\begin{enumerate}

  \item Maior capacidade de transmissão do caminho \setwayi. Define-se este
critério com base na taxa de transmissão disponível nos nós \ways $\in$
\setwayis com menor capacidade de transmissão em um determinado instante
\textit{t}. Na Seção~\ref{sec:ccgmtp}, discute-se os algoritmos de controle de
congestionamento do GMTP e o procedimento para determinar a taxa de
transmissão de um caminho \setwayi;
  \label{i:c-maiortranstx}

  \item Se for um caminho for \setwayif, determinado através da verificação da
condição $\mid$\setwayi$\mid$ $=$ $ttl($\repass$,$\setwayi$)$, onde \textit{ttl}
é uma função que determina o número de saltos entre o nó \repasss até o nó
\serv. Este critério é importante porque quanto mais nós GMTP estiverem no
caminho, maior será a possibilidade de interceptação para obter um fluxo de
dados \setpk;
  \label{i:c-waycomp}
%
%   \item Menor número de nós \ways $\in$ \setwayi;
%   \label{i:c-nnos}

  \item Escolha aleatória de \setwayis entre os caminhos \setways conhecidos.
  \label{i:c-aleat}

\end{enumerate}

Sendo assim, define-se a Fase $3$ do processo de estabelecimento de conexão do
GMTP em três passos:

\begin{enumerate}

  \item um nó \repasss envia periodicamente requisições do
tipo \pac{GMTP-RelayQuery} para o nó \servs a fim de descobrir melhores
parceiros e aumentar o número de parcerias. Por se tratar de fluxos de dados ao
vivo, não necessariamente quanto mais parcerios um nó \repasss tem, melhor será
a qualidade do fluxo de dados \setpk. Por isso, um nó \repasss sempre mantém uma
lista de candidatos a parcerios \repassu{q} fornecida pelo nó \serv, porém o nó
\repass não estabelece parcerias com todos eles. Em vez disso, executa-se
repetidamente as seguintes ações:

\begin{itemize}

  \item Um nó \repasss inicia uma nova parceria se a quantidade atual de
parcerias reduzir por desconexão de um nó parceiro \repassu{q} ou se o buffer de
recepção estiver com menos de $\frac{1}{3}$ de sua capacidade. O objetivo é
evitar o esvazeamento do buffer para o fluxo de dados \setpk, mantendo
continuamente o repasse de pacotes de dados \pks $\in$ \setpks aos nós \clis
$\in$ \subsetcli$($\repass$)$.

  \item A quantidade de parcerias em um determinado instante \textit{t} é
inversamente proporcional a quantidade de pacotes de dados \pks $\in$ \setpks
que chegam repetidos ao nó \repass. Nesse caso, se um mesmo pacote \pks chegar
repetidamente na mesma quantidade de parcerias estabelecidas, o nó \repasss
desconecta-se daquele nó parceiro \repassu{q} que enviou o pacote \pks que
chegou por último.

\end{itemize}

  \item Após obter a lista de candidatos a parceiros (Passo 1), o nó
\repassu{3} forma uma parceria com um dos candidatos da lista de possíveis
parceiros ao enviar requisições do tipo \pac{GMTP-Request} em direção a outro nó
\repassu{q} que já esteja recebendo um fluxo de dados \setpk. Como ilustra-se na
Figura~\ref{fig:conn-phase3-2}, este procedimento ocorre da seguinte forma: após
o passo anterior, o nó \repassu{3} envia uma requisição do tipo
\pac{GMTP-Request} para o nó \repassu{2} contendo uma chave de autorização
conhecida por ambos e informada pelo nó \serv. Caso a chave de autorização
esteja correta, o nó \repassu{2} deve enviar um resposta do tipo
\pac{GMTP-Response} ao nó \repassu{3} e então começar a repassar os pacotes
\pks $\in$ \setpk. O uso da chave de autorização é importante para evitar que um
nó \repasss se conecte a outro nó \repassu{q} sem que o nó \servs seja
notificado sobre isto. As chaves de autorização são geradas pelo nó \servs e
transmitidas como resposta no pacote do tipo \pac{GMTP-Register-Reply};

\end{enumerate}

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=0.9]{imgs/gmtp-conn-phase3-1.pdf}
\end{center}
\vspace{-1cm}
\caption{Fase 3 de conexão do GMTP (Passo 1).}
\label{fig:conn-phase3-1}
\end{figure}

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=0.9]{imgs/gmtp-conn-phase3-2.pdf}
\end{center}
\vspace{-1cm}
\caption{Fase 3 de conexão do GMTP (Passo 2).}
\label{fig:conn-phase3-2}
\end{figure}


% Como se considera uma arquitetura híbrida P2P/CDN, o nó \servs pode realizar uma
% função de balanceamento de carga, incluindo como resposta de uma requisição do
% tipo \pac{GMTP-RelayQuery} os outros nós \serv, levando-se em consideração,
% inclusive, todos os critérios estabelecidos na
% Seção~\ref{subsec:melhorcaminho}.

A periodicidade de requisições do tipo \pac{GMTP-RelayQuery} e a quantidade
máxima de parcerias efetivas são parâmetros controláveis pelo administrador do
nó \repass. Na implementação do GMTP utilizada neste trabalho, definiu-se o
tempo de 5 minutos para a periodicidade de requisições do tipo
\pac{GMTP-RelayQuery} e 5 para a quantidade de parcerias efetivas. Os
valores destes parâmetros são padrões em aplicações tradicionais de
distribuição de conteúdos multimídia ao vivo baseados em redes P2P.

Com a execução da Fase 3 do processo de conexão do GMTP, pode-se expandir a
quantidade de parcerias e essas informações são registradas na tabela de
recepção de fluxos de dados, tal como ilustra-se
Figura~\ref{fig:tabela-recepcao-fluxo}. Nesse exemplo, observa-se que um nó
\repasss está recebendo e repassando aos seus nós \clis $\in$
\subsetcli$($\repass$)$ quatro fluxos de dados diferentes, originados em quatro
nós \serv, porém recebendo fluxos de dados de diferentes nós parceiros
\repassu{q}. Por exemplo, dentre os fluxos de dados que o nó \repasss está
recebendo, um deles é o \setpks $=$
\textit{72c44591-7d82-427c-825f-722f015787c1}, cujos pacotes de dados \pks $\in$
\setpks são transmitidos por três nós \repassu{q} identificados pelos
endereços ip e porta \textit{182.111.88.21:49170}, \textit{90.39.135.46:62242} e
\textit{83.67.132.41:53434}. Para esse fluxo de dados \setpk, os pacotes de
dados \pks são repassados para os nós \clis $\in$ \subsetcli$($\repass$)$
através do canal multicast \textit{239.192.68.79:1900}.

\begin{figure}[htb!]
\begin{center}
\includegraphics[scale=.55]{imgs/tabela-recepcao-fluxo.pdf}
\end{center}
\vspace{-1cm}
\caption{Tabela de recepção de fluxos de dados após a Fase 3.}
\label{fig:tabela-recepcao-fluxo}
\end{figure}

% \subsection{Compartilhamento de \setpks entre \servs}
% \label{subsec:compartilhamento-de-p}
%
% Além do procedimento transparente à aplicação para se obter um fluxo de dados
% \setpk, como os nós \servs constituem uma rede CDN, estes podem negociar entre
% si o envio e a recepção de um fluxo de dados \setpks de acordo com as
% requisições submetidas aos nós \repass. Desta forma, se um nó \repasss enviar
% uma requisição para obter \setpks de um evento \events a um nó \servs e este não
% esteja recebendo tal fluxo, \servs poderá solicitá-lo a outros nós \servs da
% CDN que participa. A partir desse ponto, o nó \servs passará a servir o nó
% \repasss normalmente. Como no GMTP se faz uso indireto dessa função das redes
% CDNs, a qual já está consolidada, resolveu-se suprimir maiores detalhes a
% respeito deste assunto. Para maiores informações sobre a função de distribuição
% de conteúdos ao vivo entre os servidores de uma rede CDN, o leitor pode
% consultar as
% referências~\cite{Nygren:2010:ANP:1842733.1842736,1250586,Pathan2008}.
%
\vspace{0.5cm}

Desta forma, o processo de conexão do GMTP é fundamental para a efetiva
distribuição de mídias ao vivo, pois permite que as aplicações compartilhem
fluxos de dados entre si, mesmo que estas não tenham sido desenvolvidas pela
mesma equipe. Esta unificação ajuda no processo de distribuição do fluxo de
dados \setpk, pois, na prática, até mesmo uma aplicação \textit{standalone} e um
objeto de vídeo imbutido em uma página Web podem obter o mesmo fluxo de dados
sem que estas conheçam uma a outra. Consequentemente, reduz-se para 1 o número
de transmissões para um mesmo fluxo de dados \setpks originado em \servs
e destinados a uma mesma rede ou para um subconjuntos de redes adjacentes. Além
dessa diferença, a forma de conexão do GMTP supre uma antiga deficiência das
soluções tradicionais de transmissão multicast, pois as aplicações tinham que
se adaptar às configurações estáticas dos canais multicast definidos pelo
administrador de rede, e até os próprios administradores de rede tinham que
fazer tal configuração de forma manual, obrigatoriamente em todos os nós
roteadores de um determinado caminho. Isto é impraticável devido à
independência dos diferentes domínios administrativos.

Até o presente momento, não se conhece nenhuma solução que permita configuração
dinâmica de canais multicast aliado a formação de uma rede de sobreposição
constituída entre roteadores, com benefícios diretos para a aplicação e para a
rede, fazendo-se uso dos recursos computacionais e de rede de forma mais
apropriada, como será discutido no Capítulo~\ref{cap:analisedesemp}
(Resultados).

\subsection{Envio e Recebimento de \pks $\in$ \setpks em \net}
\label{subsec:trocdados}

Após o estabelecimento de conexão, os nós \repasss trocam dados entre si em modo
unicast a fim de distribuir os pacotes de dados \pks $\in$ \setpks do tipo
\pac{GMTP-Data} e \pac{GMTP-DataAck}. De forma similar, os nós \repasss
utilizam os mesmos tipos de pacotes para enviar \pks $\in$ \setpks para os nós
\cli, porém em modo multicast. Quando o \mudccps estiver em funcionamento em
um nó \servs ou em um \repass, o estado é o de \textit{transmitindo dados}, ao
passo que quando executado em um cliente o estado é o de \textit{recepção de
dados}. Para o transporte dos pacotes de dados \pks, um \servs deve transmitir
pacotes do tipo \pac{GMTP-Data} ou o \pac{GMTP-DataAck} em direção aos nós
\repasss de acordo com os registros de partipação. Nesta seção, detalha-se como
o GMTP executa os procedimentos de transmissão e recepção desses pacotes de
dados.

% Embora o
% protocolo \mudccps transmite dados sem garantia de entrega, a aplicação pode
% determinar que certos dados sejam transmitidos com garantia de entrega. Nestes
% casos, durante a transmissão de dados, um nó \mudccps utiliza-se do pacote do
% tipo \pac{GMTP-Data} para enviar dados, ao passo que utiliza-se pacote
% \pac{GMTP-Ack} para confirmar a recepção de pacotes, ou ainda, utiliza-se
% \pac{GMTP-DataAck} para enviar pacotes de dados e ao mesmo tempo confirmar a
% recepção de pacotes de dados vindos da direção oposta (\textit{piggyback}).

\subsubsection{Buffer de Envio e Recepção:}

A transmissão de um evento \events consiste no processo de disseminação
dos pacotes \pks $\in$ \setpks através dos nós interessados em obtê-lo. Para
isto, cada nó GMTP controla um buffer de envio e recepção definido por uma
estrutura de dados do tipo array circular (\textit{ring buffer}), onde cada
posição é utilizada para armazenar um pacote \pk, como ilustra-se na
Figura~\ref{fig:buffer-envio-recepcao-ring}. Ao receber \pk, um nó GMTP
armazena-o no buffer e posteriormente o entrega para a aplicação, que o
reproduz para o usuário final. Para o envio ou repasse de um pacote, o nó GMTP
consome os pacotes \pks do buffer e transmite para o(s) nó(s) interessado(s),
seja em modo unicast e/ou em modo multicast. Isto porque é possível que um nó
\repassu{1} repasse \pks para um outro nó \repassu{2} (unicast) ao mesmo tempo
que \repassu{1} pode repassar \setpks para seus nós \clis (multicast).

O buffer de envio e recepção do GMTP tem seu tamanho definido no processo de
estabelecimento de conexão, de acordo com o tipo da mídia sendo transmitido e
o nó \repasss pode determinar um limite máximo. Para isto, o administrador de
um nó \repasss pode definir esse limite máximo do buffer para qualquer fluxo de
dados \setpk, evitando-se ataques de negação de serviço (\textit{Denied of
Service}). Isto porque, no GMTP, uma aplicação passa a poder definir o
tamanho do buffer que cada nó \ways deverá alocar para repassar os pacote de
dados \pks de um fluxo de dados \setpk. Após definir o tamanho do buffer
para um fluxo de dados \setpk, tal tamanho permanece fixo durante todo o
ciclo de vida de uma conexão GMTP. Essa decisão é importante porque permite um
nó \servs alocar previamente o recurso necessário para o transporte de um
determinado fluxo de dados \setpk. O tamanho do buffer é especificado pelo nó
\servs e propagado para os demais nós em um caminho \setways no cabeçalho do
pacote do tipo \pac{GMTP-Register-Reply} ou \pac{GMTP-MediaDesc}.

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=1]{imgs/buffer-envio-recepcao-ring.pdf}
\end{center}
\vspace{-1cm}
\caption{Exemplo da estrutura do buffer de envio e recepção de um nó GMTP com
dois ponteiros, um para escrever e outro para ler pacotes \pk.}
\label{fig:buffer-envio-recepcao-ring}
\end{figure}

\subsubsection{Mapa de \textit{Buffer}:}

O mapa de buffer do GMTP descreve o estado atual do buffer de envio e recepção
de um nó GMTP. Como ilustrado na Figura~\ref{fig:mapa-buffer-envio-recepcao},
trata-se de uma estrutura de dados que determina se um pacote \pks está
ou não presente no buffer de um respectivo nó GMTP. O conteúdo de cada posição
é o número de sequência do pacote, que determina a ordem que um pacote foi
gerado e transmitido pelo nó \serv, tal como ocorre no protocolo TCP.

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=0.76]{imgs/mapa-buffer-envio-recepcao.pdf}
\end{center}
\vspace{-1cm}
\caption{Exemplo do mapa de buffer de um nó GMTP com tamanho de 17 \pk.}
\label{fig:mapa-buffer-envio-recepcao}
\end{figure}

O mapa de buffer é utilizado por um nó GMTP para sinalizar seu atual estado com
relação a um determinado fluxo de dados \setpk. Um nó GMTP pode enviar o mapa de
buffer completo, como ilustrado na Figura~\ref{fig:mapa-buffer-envio-recepcao},
ou o mapa de buffer apenas dos \pks presentes ou ausentes. Na prática,
um nó \repasss envia para um nó parceiro \repassu{q} o mapa de buffer dos \pks
presentes quando deseja indicar a sua atual disponibilidade; ao passo que envia
o mapa de buffer dos \pks ausentes quando desejar obtê-los. Para diferençar o
tipo de requisição, utiliza-se uma sinalização binária (\textit{flag}) chamada
\textit{request-type}, onde $0$ significa que o mapa de buffer contém pacotes
disponíveis e $1$, pacotes ausentes. Note que, quando um nó \repasss transmite
um mapa de buffer para um outro nó qualquer \repassu{q} caracteriza
automaticamente o uso do método \textit{pull}, em vez do método \textit{push},
que é o modo padrão do GMTP. Salienta-se que deve-se evita o método pull devido
à transitoriedade dos pacotes de dados \pks (transmissão de dados ao vivo) e um
nó \repasss deve apenas realiza tal procedimento após completar a Fase 3 do
processo de estabelecimento de conexão. Isto porque um nó \repasss pode nunca
receber a resposta para uma requisição do tipo pull.

Quando um nó \repasss percebe a falta de um ou mais pacotes \pk, este pode
solicitar a um ou mais nós \repasss os pacotes \pks ausentes e então
obtê-los usando o método \textit{pull}. Para isso, um nó \repasss enviar aos
seus nós parceiros \repassu{q} o mapa de buffer dos pacotes \pks ausentes e
aguarda as respostas sobre tal disponibilidade. Essa sinalização ocorre através
do uso do pacote do tipo \pac{GMTP-DataPull-Request}, que é preenchido com o mapa
de buffer dos pacotes ausentes e transmitido aos respectivos nós parceiros. Ao
receber esse tipo de requisição, um nó parceiro avalia seu conteúdo e responde
com o pacote do tipo \pac{GMTP-DataPull-Response}, o qual contém o mapa de buffer
dos pacotes disponíveis, seguido dos pacotes \pks do tipo \pac{GMTP-Data}. Note
que os pacotes do tipo \pac{GMTP-DataPullRequest} e \pac{GMTP-DataPull-Response}
são transmitidos com garantia de entrega

% , ou seja, caso sejam perdidos, o GMTP
% garante sua retransmissão. Para isto, o GMTP utiliza o mecanismo básico de
% envio e confirmação utilizando o pacote do tipo \pac{GMTP-DataAck} ou
% \pac{GMTP-DataAck}. No caso de falha na execução de uma requisição utilizando o
% método \textit{pull}, o nó GMTP pode reavaliar a necessidade de retransmitir o
% pedido, pois é possível que os \pks ausentes já tenham expirados e requisitá-los
% novamente não fará mais sentido.

Na prática, o mapa de buffer utilizado para sinalizar a presença ou ausência de
\pks é representado por faixas de acordo com o índice do buffer. Por exemplo,
para representar o mapa de buffer dos pacotes ausentes ilustrados na
Figura~\ref{fig:mapa-buffer-envio-recepcao}, o nó GMTP preenche o pacote do
tipo \pac{GMTP-DataPull-Request} com a sequencia \textit{2;6-10;12}. Ao receber
esta sequência, o nó parceiro \repassu{q} responde com o pacote do tipo
\pac{GMTP-DataPull-Response}, que contém o mapa de buffer de quais
pacotes serão enviados e começa a transmití-los.

% * RELATAR TAXA DE RECEPCAO	- NO RELATA QUAL A TAXA DE RECEPÇÃO
% (PREENCHIMENTO+ATUALIZAÇÃO DO BUFFER)
% * USA ESSA INFO PARA SELECIONAR OS MELHORES PARCEIROS (FILTRO APRIMORADO)

\subsubsection{Descarte de pacotes:}

O descarte de pacotes \pks ocorre sempre no nó \repasss e em duas situações:

\begin{enumerate}

 \item \textbf{Por transbordo do buffer:} o transbordo do buffer pode ocorrer
devido ao mecanismo de controle de congestionamento empregado no GMTP, que pode
reduzir a taxa de transmissão enquanto novos pacotes precisam ser alocados no
buffer. Sendo assim, deve-se descartar os primeiros pacotes \pks recebidos se o
buffer alcançou seu limite, mesmo que ainda não tenham sido repassados. Uma
otimização não explorada neste trabalho, mas que é possível de ser realizada, é
o descarte seletivo de pacotes, primeiro os que tenham menos impacto na
qualidade da mídia, por exemplo, pacotes de dados contendo quadros B
(codificação MPEG4, tipo 2). Isto não impede que o vídeo seja reproduzido, porém
com perda de qualidade, ao passo que se permite a transmissão dos pacotes de
dados \pks com a largura de banda de rede disponível;

 \item \textbf{Por duplicação:} ocorre quando o pacote \pks já foi recebido
anteriormente. Tal verificação é feita de acordo com o número de sequência
presente em cada pacote \pk. Note que essa contagem é importante e pode
determinar que um nó \repasss desconecte de um nó parceiro \repassu{q}, tal como
explicado na Seção~\ref{subsec:phase3}.

\end{enumerate}


\section{Controle de Congestionamento em \net}
\label{sec:ccgmtp}

Na GMTP, executa-se um algoritmo para controle de congestionamento híbrido,
cujo comportamento dependerá se o nó que o executa está transmitindo em modo
unicast ou em multicast. Como ilustra-se na Figura~\ref{fig:ucc-mcc-esquema},
na prática, trata-se de dois algoritmos para controle de congestionamento, um
que atua em transmissões unicast, chamado de \textit{\mudccps Unicast
Congestion Control} (GMTP-UCC) e outro que atual em transmissões multicast,
chamado de \textit{\mudccps Multicast Congestion Control} (GMTP-MCC). Nesta
seção, discute-se o funcionamento de cada um desses algoritmos.

\begin{figure}[htb!]
\begin{center}
\includegraphics[scale=.7]{imgs/ucc-mcc-esquema.pdf}
\end{center}
\vspace{-1cm}
\caption{Organização do algoritmo de controle de congestionamento no \mudccp.}
\label{fig:ucc-mcc-esquema}
\end{figure}

 Em modo de transmissão unicast, utilizado na
comunicação entre os nós \repass, define-se a taxa de transmissão de um nó
\mudccps através de uma versão modificada do protocolo RCP (Rate Control
Protocol)~\cite{Dukkipati:2008:RCP:1368746}. Já em modo de transmissão
multicast, executa-se um algoritmo baseado em relatórios (\textit{feedbacks})
transmitidos pelos nós clientes \rel, eleitos em cada rede e controlados por um
nó \repass, tal que \rels $\in$ \subsetcli$($\repass$)$.

\subsection{Controle de Congestionamento Unicast}
\label{subsec:mudccp-ucc}

O \mudccp-UCC funciona de forma similar ao protocolo RCP, porém com alguns
diferenciais a serem discutidos a seguir. O RCP é um protocolo para controle de
congestionamento assistido pela rede que tenta emular um Comutador
Compartilhado (\textit{Processor Sharing} -- PS), por exemplo, um
roteador~\cite{Dukkipati:2005:PSF:2103175.2103204}. Nesse contexto, entende-se
que se um roteador pudesse obter a informação exata sobre o número de fluxos de
entrada em um instante $t$, a taxa de transmissão ideal para cada fluxo de dados
seria $R_{ps}(t) = \frac{C}{N(t)}$, onde $C$ corresponde à capacidade do link e
$N(t)$ ao número de fluxos no instante $t$.

Partindo desse ponto, Nandita et. al\cite{Dukkipati:2008:RCP:1368746} argumenta
que para um roteador funcionar de forma equânime, este deve oferecer a
mesma taxa de transmissão para todos os fluxos transmitidos através dele,
mantendo-se o número de pacotes na fila de roteamento perto de zero, a fim de
evitar que apenas os fluxos que tem pacotes na fila de repasse compartilhem a
largura de banda disponível. Com base nisso, Nandita et.
al\cite{Dukkipati:2008:RCP:1368746} determinou a Equação~\ref{eq:cc-rcp-teoria},
onde $R(t)$ é a taxa de transmissão que deve ser oferecida para cada fluxo de
dados que passa pelo roteador. Pela Equação~\ref{eq:cc-rcp-teoria}, estima-se a
largura de banda disponível em um determinado canal, representada pela porção
$\alpha(C - y(t)) - \beta \frac{q(t)}{h_0}$ (mudança agregada) e a divide por
$N(t)$. Porém, como é impossível determinar o valor exato de $N(t)$, estima-se
$\hat{N}(t) = \frac{C}{R(t-T)}$ e para atualizar $R(t)$ com mais frequência do
que no tempo de um RTT, escala-se a mudança agregada por $\frac{T}{h_0}$,
resultando na Equação~\ref{eq:cc-rcp}, onde:

  \begin{equation}
  R(t) = R(t - h_0) + \frac{\alpha(C - y(t)) - \beta
\frac{q(t)}{h_0}}{\hat{N}(t)}
  \label{eq:cc-rcp-teoria}
  \end{equation}

  \begin{equation}
  R(t) = R(t -T) \left[1+\frac{\frac{T}{h_0}\left(\alpha(C - y(t)) -
\beta \frac{q(t)}{h_0}\right)}{C}\right]
  \label{eq:cc-rcp}
  \end{equation}

  \begin{itemize}

    \item $h_0$, é a média móvel dos valores de $RTT_{s}$, calculada através da
Equação~\ref{eq:calcrtt-rcp}, onde $\theta$ é o ganho e corresponde a $0.02$.
Note que quanto maior o valor de $\theta$, mais rápida será a convergência de
$h_0$ ao valor de $RTT_{s}$. $RTT_{s}$ é o tempo de ida e volta calculado na nó
transmissor.

      \begin{equation}
      h_0 = \theta \times RTT_{s} + (1 - \theta) \times h_0
      \label{eq:calcrtt-rcp}
      \end{equation}

    \item $H = min(RTT_{user}$, $h_0)$, sendo $RTT_{user}$ um tempo definido
pelo usuário (administrador do roteador), caso seja necessário atualizar $R(t)$
mais rápido do que o tempo de $h_0$;

    \item $R(t - T)$, é a última taxa de transmissão medida;

    \item $y(t)$, é a taxa de tráfego de entrada medida no intervalo entre a
última atualização da taxa de transmissão e $h_0$;

    \item $q(t)$, é o tamanho instantâneo da fila de repasse, em bytes. Note
que no GMTP esse valor é obtido pela soma de todos os pacotes \pks presentes em
todos os buffers de recepção e envio para cada fluxo de dados \setpk. Nesse
caso, um nó \repasss mantém um buffer geral e um buffer para cada fluxo de
dados \setpks que esteja repassando aos seus nós \clis $\in$
\subsetcli$($\repass$)$;

%     \item $\hat{N}(t)$, é uma estimativa do número de fluxos em um tempo $t$,
% por exemplo, o número de fluxos enviando pacotes de dados \pk;

    \item $\alpha$ e $\beta$, são parâmetros pré-definidos que determinam
a estabilidade e o desempenho;

    \item $C$, é a capacidade do link.

  \end{itemize}


No GMTP-UCC, o algoritmo para controle de congestionamento, adaptado do
RCP, funciona da seguinte forma (acompanhe os passos de acordo com a
Figura~\ref{fig:ccgmtp-interacao-1}):

\begin{figure}[htb!]
\begin{center}
\includegraphics[scale=0.75]{imgs/ccgmtp-interacao-1.pdf}
\end{center}
\vspace{-1cm}
\caption{Cada \repasss mantém uma única taxa de transmissão $R(t)$ que é
atribuída em todos os pacotes de dados \pks no cabeçalho de qualquer pacote
GMTP. A medida que o pacote passa através dos roteadores em um caminho \setwayi,
se a taxa atual $R(t)$ no roteador for menor do que $R_{p}$ informado no pacote
sendo processado, o roteador o sobrescreve com sua taxa atual $R(t)$. Quando o
pacote alcançar o nó \serv, este utiliza $R_{p}$ para transmitir o fluxo de
dados, pois trata-se da taxa de transmissão do roteador mais congestionado no
caminho \setwayi.}
\label{fig:ccgmtp-interacao-1}
\end{figure}

\begin{enumerate}[{\tab}1$^{\circ}$]

  \item Seja um caminho \setwayis, todo nó \ways mantém uma única taxa de
transmissão $R(t)$, que é oferecida para todos os fluxos de dados passando por
\ways em um certo instante $t$. Cada nó \ways atualiza $R(t)$
aproximadamente a cada RTT.
  \label{step:rcp-gmtp-0}

  \item Todo pacote GMTP carrega duas informações de controle no campo de
cabeçalho:
  \label{step:rcp-gmtp-1}
  \begin{itemize}

    \item \textit{taxa de transmissão proposta} ($R_{p}$): corresponde à taxa de
transmissão do roteador com menor capacidade de transmissão em um instante
\textit{t};

    \item \textit{RTT na fonte} ($RTT_{s}$): corresponde ao RTT
estimado entre quaisquer nós \transu{\transi},\transu{\transi+1} $\in$
\setwayi, ou seja, o RTT entre dois nós \transu{\transi} e \transu{\transi+1}
que processam o respectivo pacote \pks de um fluxo de dados \setpk, a fim de
repassar aos seus nós \clis $\in$ $($\subsetcli(\trans) $\cup$
\subsetcli(\transu{\transi+1})$)$. Apesar de uma mudança suscinta, este aspecto
diferencia o GMTP-UCC do RCP, a ser discutido em mais detalhes a seguir.

%     \item \textit{Diferença de RTT} (RTT$_{d}$): corresponde à diferença entre
% RTT$_{s}$ e o RTT medido entre dois nós \way. Por exemplo, seja um
% caminho \setwayis por onde o fluxo de dados \setpks é transmitido, com
% \waysu{1}=\space \servu{1}, \waysu{2}=\space \repassu{1}, \waysu{3}=\space
% \repassu{2} e \waysu{4}=\space \repassu{3}, tal que
% \wayu{1},\wayu{2},\wayu{3},\wayu{4} $\in$ \setwayi. Considere que o RTT entre
% \wayu{1} e \wayu{2} corresponda a um valor qualquer \textit{x}, o RTT entre
% \wayu{2} e \wayu{3} corresponda a um valor qualquer \textit{y} e o RTT entre
% \wayu{3} e \wayu{4} corresponda a um valor qualquer \textit{z}. Para esse caso,
% \wayu{1} deve especificar RTT$_{s}$ = \textit{x} e RTT$_{d}$ = 0, \wayu{2} deve
% especificar RTT$_{s}$ = \textit{x} e RTT$_{d}$ = \textit{y}; e \wayu{3} deve
% especificar RTT$_{s}$ =
% \textit{x+y} e RTT$_{d}$ = \textit{z}. Com isto, é possível que o nó
% \wayu{4} saiba qual é o RTT acumulado entre \wayu{1} até seu nó parceiro
% \wayu{3} (RTT$_{s}$) e também o RTT apenas entre \wayu{3} e \wayu{4}
% (RTT$_{d}$). Com essas informações expostas para cada nó \ways em um caminho
% \setway, qualquer nó \repasss poderá fazer uso de tais informações para decidir
% com quais nós devem fazer parcerias ou quais são seus melhores parceiros.

  \end{itemize}

  \item No início da transmissão de um fluxo de dados \setpk, o nó \way,
motivado por um ou mais nós \clis $\in$ \subsetcli$($\way$)$, transmite um
pacote \pks com o valor de $R_{p} = \infty$ em direção a \serv.
  \label{step:rcp-gmtp-2}

  \item Todo nó \ways $\in$ \setwayi, ao receber um pacote \pk, verifica se
$R(t) < R_{p}$ e, em caso afirmativo, então $R_{p} \leftarrow R(t)$, caso
contrário nenhuma modificação é realizada nesse campo. Nesse ínterim, se
\transmitqu{\way} $=$ $1$, \ways também executa as seguintes ações:
  \label{step:rcp-gmtp-3}

  \begin{enumerate}

    \item repassa \pks para seus nós \clis em modo multicast, como discutiu-se
na Seção~\ref{subsec:trocdados};

    \item utilizar $RTT_{s}$, presente no pacote \pk, para atualizar a média
móvel do RTT no intervalo de $h_0$ (Equação~\ref{eq:calcrtt-rcp}) e, em seguida,
atualiza $R(t)$;

    \item cria um pacote \pac{GMTP-Ack} contendo $R_{p}$ e o envia em direção a
\serv. Este procedimento permitirá que o nó \servs saiba em quais pontos o
caminho \setwayis está sendo segmentado. Este assunto será discutido em mais
detalhes a seguir.
    \label{item:gmtp-ucc-bottleneck-ack}

  \end{enumerate}

  \item O nó \transs deve usar $R_{p}$ como a nova taxa de transmissão para
enviar os próximos pacotes de dados \pks para seu nó parceiro
\transu{\transi+1}. Assim, $R_{p}$ é a menor taxa de transmissão oferecida ao
longo do sub-caminho \setwayias $\subset$ \setwayi, tal que \setwayias $=$
$\{$\trans, ..., \transu{\transi+1}$\}$. Note que esta regra automaticamente se
aplica também ao nó \serv, já que este é o último salto de um caminho \setwayi.

  \item Todo nó \repasss atualiza sua taxa de transmissão local $R(t)$ de acordo
com a Equação~\ref{eq:cc-rcp}, no intervalo de tempo correspondente a $H$.

\end{enumerate}

Sendo assim, no caso do GMTP-UCC, a ideia básica é a seguinte: para quaisquer
dois nós \transu{1},\transu{2} $\in$ \setwayi, a taxa de transmissão a ser
utilizada por \transu{1} e \transu{2} será definida pela menor taxa de
transmissão oferecida pelos nós \ways $\in$ \setwayis posicionados entre
\transu{1} e \transu{2}. Isto significa que o GMTP-UCC segmenta um caminho
\setwayis em vários sub-caminhos \setwayid. Com isto, se existir largura de
banda disponível entre \transu{1} e \transu{2}, ou seja, $C - y(t) > 0$, então o
GMTP-UCC compartilhará igualmente o canal entre todos os fluxos, inclusive para
o fluxo entre \transu{1} e \transu{2}. Caso contrário, ou seja, se $C - y(t) <
0$, considera-se o canal saturado e o GMTP-UCC reduzirá a taxa de transmissão
igualmente para todos os fluxos, inclusive para o fluxo entre \transu{1} e
\transu{2}. Por este motivo, o tempo $H$ é definido entre dois nós \transs e
\transu{\transi+1} contidos em um caminho \setwayi. A consequência dessa
estratégia de segmentar um caminho é muito importante e por esse motivo o
GMTP-UCC é relativamente diferente se comparado ao RCP.

% Especificamente, a largura de banda necessária para repassar todos
% os pacotes \pks $\in$ \setpks que estão na fila de roteamento no intervalo de um
% RTT corresponde à
% $\frac{q(t)}{h_0}$~\cite{Dukkipati:2005:PSF:2103175.2103204}.

% \subsubsection{Diferença entre o RCP e o GMTP-UCC}
%
% Como discutido, o RCP é um protocolo para controle de congestionamento
% fim-a-fim, % onde os sistemas finais de origem e destino se comunicam e trocam
% pac tes de ACK % para determinar a nova taxa de transmissão $R(t)$ que o nó
% transmissor deve  utilizar para transmitir um fluxo de dados \setpk. Porém, no
% caso do GMTP um nó % \repassu{1} tem como principal função repassar os pacotes
% de dados \pks $\in$ % \setpks do tipo \pac{GMTP-Data/DataAck} para seus nós
% parceiros \repass, em c so % de $\mid$\subsetcli$($\repassu{1})$\mid$ $>$ $0$
% para o fluxo de % dados setpk. Nesse interím, tais nós realizam ações para dar
% suporte ao % ecanismo de controle de congestionamento da rede, como por exemplo
% atualizar o % valor de $R_p$ e $RTT_s$. No RCP, o valor de $RTT_s$ é calculado
% pelo sistema  final de origem, mas no GMTP, quando um nó \repassu{1} forma uma
% parceria co % outros nós \repass, é como se \repassu{1} funcionasse como o nó de
% origem \se vs % e portanto também deveria atualizar o valor para $RTT_s$. Para
% isto, um nó % \repasss precisaria manter estado para cada fluxo de dados \setpk,
% o que % significa manter um temporizador para cada fluxo de dados \setpks %
% compart lhado. Do ponto de vista computacional, delegar tal responsabil dade %
% para um roteador seria uma atividade onerosa porque múltiplos fluxo de dados, %
% originados por diversas fontes \serv, podem passar por um roteador e facilment %
% este se tornaria um ponto de gargalo por ter que processar cada pacote, ca cular
% e atualizar o valor para $RTT_s$ para cada um deles.
%
% Diante desta questão, no GMTP-UCC, em vez de um nó \repasss manter o
% temporizador para cada fluxo de dados \setpk, os nós relatores \rels, tal
% que \rels $\in$ \subsetcli$($\repass) são responsáveis por tal atividade. Isto
% significa que um nó cliente \cli=\rel, localizado na rede de \repass,
% realizará a computação para obter o valor de $RTT_s$, bastando o nó \repasss
% notificar qual nó \rels será responsável por manter tal estado. Isto só é
% possível porque quando um nó \repasssu{1} se torna parceiro de outro nó
% \repassu{2}, a condição $\mid$\subsetcli$($\repassu{1})$\mid$ $>$ $0$ é
% satisfeita para um fluxo de dados \setpk.

\subsubsection{Segmentação de um caminho \setwayi:}

O RCP considera todo o caminho entre o nó transmissor e o nó receptor para
determinar o novo valor da taxa de transmissão do nó transmissor, especificado
em $R_{p}$. Porém, essa estratégia pode limitar alguns nós \clis a receberem os
pacotes de dados \pks $\in$ \setpks em uma taxa maior, quando disponível. Por
exemplo, observe o cenário ilustrado na Figura~\ref{fig:ccgmtp-interacao-2},
abstraindo-se os nós \clis $\in$ \subsetcli$($\way$)$. Nesse cenário, observa-se
um caminho \setwayis $=$ $\{$\transu{1}, \wayu{2}, \transu{3}, \wayu{4}$\}$.
Isto significa que existem nós \clis $\in$ $($\subsetcli(\transu{1}) $\cup$
\subsetcli(\transu{3})$)$ recebendo os pacotes de dados \pk. Ao utilizar apenas
o RCP, o nó \servs transmitirá pacotes de dados \pks a uma taxa de transmissão
de \ut{1}{Mb/s} tanto para os nós \clis $\in$ \subsetcli(\transu{1}) quanto para
os nós \clis $\in$ \subsetcli(\transu{3}). Ora, isso faz sentido apenas para os
nós \clis $\in$ \subsetcli(\transu{1}) e não para os nós \clis $\in$
\subsetcli(\transu{3}), visto que em \transu{3} o valor de $R(t)$ é igual a
\ut{4}{Mb/s} e o nó \wayu{4} não limita o uso dessa taxa de transmissão para os
nós \clis $\in$ \subsetcli(\transu{3}), uma vez que em \wayu{4} o valor de
$R(t)$ corresponde a \ut{8}{Mb/s}.

\begin{figure}[htb!]
\begin{center}
\includegraphics[scale=0.75]{imgs/ccgmtp-interacao-2.pdf}
\end{center}
\vspace{-1cm}
\caption{O RCP utiliza uma abordagem fim-a-fim para determinar a taxa de
transmissão, porém isto pode limitar alguns nós clientes a receberem os pacotes
de dados em uma taxa maior.}
\label{fig:ccgmtp-interacao-2}
\end{figure}

No caso do GMTP-UCC, esta limitação foi superada ao determinar que se
\transmitqu{\way} $=$ $1$, ou seja, \ways $=$ \transs $\in$ \settrans, então a
taxa de transmissão informada em $R_{p}$ será utilizada por \way, porém não
será considerada para determinar a taxa de transmissão do próximo nó
\transu{\transi+1}. Por isso, o GMTP-UCC segmenta o caminho \setwayis de acordo
com a menor taxa de transmissão entre dois nós \transs e \transu{\transi+1}.
Considerando o mesmo exemplo ilustrado na Figura~\ref{fig:ccgmtp-interacao-2},
mas adotando essa estratégia de segmentar o caminho \setwayi, tal cenário
corresponde ao ilustrado na Figura~\ref{fig:ccgmtp-interacao-3}. Note que no
sub-caminho \setwayidus{1} $=$ $\{$\transu{3}, \wayu{2}, \transu{1}$\}$ a
taxa de transmissão de \transu{3} em direção a \transu{1} será de \ut{1}{Mb/s},
ao passo que no sub-caminho \setwayidus{2} $=$ $\{$\servu{1}, \wayu{4},
\transu{3}$\}$ será de \ut{4}{Mb/s}. Sendo assim, os nós \clis $\in$
\subsetcli(\transu{1}) receberão o fluxo de dados \setpks em uma taxa de
\ut{1}{Mb/s}, ao passo que os nós \clis $\in$ \subsetcli(\transu{3}) receberam
a uma taxa de \ut{4}{Mb/s}.

\begin{figure}[htb!]
\begin{center}
\includegraphics[scale=0.75]{imgs/ccgmtp-interacao-3.pdf}
\end{center}
\vspace{-1cm}
\caption{O GMTP-UCC segmenta o caminho e dessa forma não limita a taxa de
transmissão de um fluxo de dados para certos nós capazes de receber em uma
taxa de transmissão maior.}
\label{fig:ccgmtp-interacao-3}
\end{figure}

\subsubsection{Ordenação dos melhores caminhos com base em $R(t)$:}

Na Seção~\ref{subsec:phase3}, discutiu-se a Fase 3 de conexão do GMTP, que
permite um nó \servs sugerir possíveis nós \repassu{q} como candidatos a
parceiros de um nó solicitante \repass. O primeiro critério para sugerir nós
parceiros \repassu{q} é priorizar aqueles que fazem parte de um caminho
\setwayis com maiores capacidade de transmissão. No GMTP isto é possível
porque os nós \servs conhecem a capacidade de transmissão de todo o caminho,
inclusive os pontos de congestionamento, obtidos pelo
Passo~\ref{item:gmtp-ucc-bottleneck-ack} do algoritmo GMTP-UCC. Sendo
assim, dependendo da posição de um nó solicitante \repasss em um caminho
\setwayi, o nó \servs determina os parceiros \repassu{q} e os sugere ao nó
\repasss através da intersecção de caminhos conhecidos, utilizando
como critério de ordenação as capacidades de transmissão dos caminhos
conhecidos \setway.

\subsubsection{Escolha do algoritmo RCP em detrimento ao TCP e ao XCP:}

A motivação para o RCP é identificar um algoritmo para controle de
congestionamento simples e prático para emular um PS independente da
característica do tráfego e das condições da rede. A abordagem adotada no RCP é
diferente se comparada ao TCP e ao XCP. No RCP, em vez de monitorar a mudança de
uma janela deslizante a cada tempo de RTT, busca-se determinar se existe uma
taxa de transmissão a qual o roteador pode oferecer para todos os fluxos de
modo a emular um PS, sem manter estado e nem filas por fluxo de dados, tampouco
computação por cada pacote no
roteador~\cite{Dukkipati:2005:PSF:2103175.2103204}. Tanto o RCP quanto o
XCP são os protocolos mais conhecidos do estado da arte que tentam emular um PS
e, por este motivo, suas equações de controle de congestionamento são similares.
Porém, o modo que o RCP e o XCP tentam convergir suas respectivas taxas de
transmissão $R_{rcp}(t)$ e $R_{xcp}(t)$ é bastante diferente, alocando-se tais
taxas para cada fluxo de dados a fim de emular a taxa de transmissão do PS,
definida por $R_{ps}(t)$. Dessa forma, foi fundamental decidir qual dos
dois protocolos seria mais adequado ao GMTP-UCC e, para tomar tal decisão,
estudou-se as diferenças entre tais protocolos, com base no que se apresenta a
seguir e detalhado em~\cite{Dukkipati:2005:PSF:2103175.2103204}.

Especificamente, a principal diferença entre o RCP e o XCP está no tipo de
informação enviada para um nó transmissor de um fluxo de dados para atualizar o
valor de $R_{rcp}(t)$ ou de $R_{xcp}(t)$. O XCP continuamente tenta convergir a
taxa de transmissão para um ponto de equilíbrio onde todos os transmissores
transmitirão pacotes de dados a uma taxa de transmissão $R_{xcp}(t)$, ao passo
que o RCP calcula uma única taxa de transmissão que deve ser utilizada por todos
os nós transmissores em um certo instante \textit{t}. Apesar dessa diferença
suscinta, deve-se entender minuciosamente o que isto significa.

No caso do XCP, o protocolo aumenta ou diminui a janela de congestionamento de
um fluxo de dados de acordo com o tamanho atual da sua janela de
congestionamento. Isto significa que o XCP reduz gradativamente os tamanhos da
janela de congestionamento dos fluxos com $R_{xcp}(t)$ maior do que o
$R_{ps}(t)$ estimado, aumentando-se gradativamente o tamanho das janelas de
congestionamento dos fluxos com $R_{xcp}(t)$ menor do que $R_{ps}(t)$ estimado.
Porém, o tamanho da janela de congestionamento é sempre menor para os fluxos
iniciados mais recente. Assim, em qualquer momento, os fluxos XCP podem ter
diferentes tamanhos de janela de congestionamento e de RTTs, portanto diferentes
taxas de transmissão $R_{xcp}(t)$, resultando em valores para $R_{xcp}(t)$ não
equânimes para todos os fluxos de dados. Por exemplo, nos gráficos da
Figura~\ref{fig:xcp-vs-tcp-vs-ps}, compara-se o TCP e o XCP com um PS ideal com
base em uma rede simulada, com taxa de entrada de pacotes de dados de um fluxo
definida em \textit{Poisson} e tamanhos dos fluxos em distribuição
\textit{Pareto} com média de 30 pacotes (1000 \ut{bytes}{pacote}),
\textit{shape} igual a $1.4$, capacidade do link igual a \ut{2.4}{Gbps} e RTT
igual a \ut{100}{ms}, com carga ofertada igual a $0.9$. No gráfico esquerdo,
ilustra-se o tempo médio de duração (quanto tempo o respectivo protocolo gasta
para completar o fluxo) em função do tamanho do fluxo. No gráfico direito,
ilustra-se o número de fluxos ativos em função do tempo. Os valores de PS foram
calculados a partir de expressões analíticas~\cite{Wolff1989} e mostram que os
fluxos poderiam ser finalizados uma ordem de magnitude mais rápida do que o TCP.

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=0.29]{imgs/xcp-vs-tcp-vs-ps.png}
\end{center}
\vspace{-1cm}
\caption{No gráfico esquerdo, ilustra-se o tempo médio de duração (quanto tempo
leva para completar) de um fluxo versus o tamanho do fluxo utilizando o TCP e o
XCP. No gráfico direito, ilustra-se o número de fluxos ativos versus o tempo.
Ambos os gráficos são resultados de simulações com chegada de fluxo em Poisson e
tamanhos do fluxo em distribuição Pareto com média de 30 pacotes (1000
\ut{bytes}{pacote}), shape igual a $1.4$, capacidade do link igual a
\ut{2.4}{Gbps} e RTT igual a \ut{100}{ms}, com carga ofertada igual a $0.9$. Os
valores de PS foram calculados a partir de expressões analíticas. Extraído
de~\cite{Dukkipati:2005:PSF:2103175.2103204}.}
\label{fig:xcp-vs-tcp-vs-ps}
\end{figure}

Com base nos gráficos da Figura~\ref{fig:xcp-vs-tcp-vs-ps}, observa-se que os
fluxos TCP demoram para finalizar porque consome-se múltiplos RTTs na fase de
partida lenta para encontrar uma taxa de transmissão equânime, além do
mais, muitas vezes o fluxo acaba antes que tal taxa seja encontrada. Em seguida,
quando o fluxo TCP entra no modo de prevenção de congestionamento, o TCP
adapta-se lentamente devido ao método de aumento aditivo, o que aumenta o tempo
de finalização do fluxo. Além disso, o TCP deliberadamente preenche o buffer dos
roteadores saturados de modo a ajustar a taxa de transmissão com base nos
descartes de pacotes, mas buffers adicionais resulta em aumento no tempo
(atraso) para entregar um pacote de dados, impactando no tempo total de duração
de um fluxo. Já o XCP funciona melhor em redes com altos produtos largura de
banda--atraso. Os roteadores disponibilizam para as fontes transmissoras
relatórios sobre as mudanças da janela de congestionamento, enviados em
múltiplos RTTs, que funcionam a contento quando todos os fluxos são de longa
duração. Por isso, em um ambiente dinâmico, o XCP pode aumentar a duração de
cada fluxo em relação ao PS ideal, resultando em mais fluxos de dados em
trânsito na rede em qualquer instante, principalmente os fluxos de curta
duração.

Já no RCP, todos os fluxos (novos e antigos) recebem a mesma taxa de transmissão
$R_{rcp}(t)$ baseada no estado atual do nó \repasss com menor largura de banda
disponível em um certo instante $t$. Isto permite que um fluxo de dados de
curta duração termine o mais rápido possível ao passo que os fluxos de dados
mais longos não influenciam diretamente no compartilhamento equânime do PS, sem
permitir que parte da largura de banda disponível fique ociosa por muito tempo.
Este procedimento ocorre em um intervalo de tempo definido por $H$ (vide
Equação~\ref{eq:cc-rcp}).

Como observa-se no gráfico da Figura~\ref{fig:rcp-vs-xcp-vs-tcp}, a estratégia
do RCP de compartilhar uma única taxa de transmissão para qualquer fluxo com
base no estado atual do roteador saturado, produz um resultado satisfatório no
que diz respeito a melhor utilizar o canal de transmissão (seja quando em altos
níveis de utilização quanto de ociosidade). Com base no gráfico, percebe-se
que em comparação ao XCP e a outras soluções tradicionais como o TCP, o RCP
emula melhor um PS e por isso acompanha o tempo médio de finalização de um fluxo
de dados à medida que se aumenta o tamanho do fluxo de dados. Note que, para o
cenário descrito, o XCP teve um desempenho pior se comparado, inclusive, ao TCP.

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=0.33]{imgs/rcp-vs-xcp-vs-tcp.png}
\end{center}
\vspace{-1cm}
\caption{Tempo médio, em segundos, de finalização de um fluxo de dados, ao
utilizar os protocolos XCP, TCP e RCP como resultados de simulações com taxa de
entrada de dados em Poisson e tamanhos do fluxo em distribuição Pareto com média
de 25 pacotes (1000 \ut{bytes}{pacote}), shape igual a $1.2$, capacidade do link
igual a \ut{2.4}{Gbps} e RTT igual a \ut{100}{ms}, com carga ofertada igual a
$0.9$. Os valores de PS foram calculados a partir de expressões analíticas.
Extraído de~\cite{Dukkipati:2005:PSF:2103175.2103204}.}
%  Os fluxos foram
% injetados na rede com base na distribuição pareto, com E[L] = \ut{25}{pacotes} e
% shape = 1.2.
\label{fig:rcp-vs-xcp-vs-tcp}
\end{figure}

O XCP é computacionalmente mais complexo do que o RCP, uma vez que o
XCP define diferentes valores de \textit{feedback} para cada fluxo, envolvendo
operações matemáticas (multiplicação e soma) para cada pacote, o que torna o XCP
mais lento que o RCP. Pela estratégia de mudança no tamanho da janela de
congestionamento, o XCP pode leva múltiplos RTTs para a maioria dos fluxos
alcançarem a taxa de transmissão equânime entre eles, mas que mudam com o passar
do tempo à medida que novos fluxos são injetados na rede e outros são
finalizados, devido à natureza dinâmica das redes. No caso do RCP, essa
complexidade é menor e há uma redução significativa na convergência entre a
taxa de transmissão praticada $R_{rcp}(t)$ e a taxa estimada do PS
($R_{ps}(t)$). Isto porque mantém-se uma única taxa de transmissão para todos
os fluxos, não envolvendo qualquer computação adicional por pacote \pks que
passa por \repass. Além disso, para determinar $R_{rcp}(t)$, utiliza-se apenas o
tamanho da fila e a taxa agregada de entrada, sem necessitar manter estado por
fluxo de dados e operações matemáticas por pacote de dados.

Desta forma, os aspectos que determinam o funcionamento do RCP são fundamentais
quando se trata de transmissão de conteúdos multimídia ao vivo, aliado às outras
estratégias adotadas no GMTP. O RCP define uma taxa de transmissão equânime para
todos os fluxos, sua reação é rápida às mudanças circunstanciais na rede, tanto
para uma super-utilização de um canal quanto para a sua sub-utilização. Como o
RCP escala naturalmente com relação à capacidade de transmissão do canal e ao
RTT, o seu desempenho é invariante com relação ao tamanho de um fluxo, portanto
não importa qual tipo de fluxo as aplicações geram (se de curta ou de longa
duração; independente de qualquer protocolo de transporte). Com isto, permite-se
que fluxos de dados GMTP/RCP e TCP/RCP coexistam na Internet de forma equânime,
aliado às funções do GMTP de distribuição de conteúdo assistida pela rede,
evitando-se sobrecarga nos nós \serv.

% ~\cite{4460574}. O artigo está na area de trabalho
% http://ieeexplore.ieee.org/xpl/login.jsp?tp=&arnumber=4460574&url=http%3A%2F%2Fi
% eeexplore.ieee.org%2Fiel5%2F90%2F4359146%2F04460574.pdf%3Farnumber%3D4460574

% Achieving efficient and fair bandwidth allocation while minimizing packet loss
% and bottleneck queue in high bandwidth-delay product networks has long been a
% daunting challenge. Existing end-to-end congestion control (e.g., TCP) and
% traditional congestion notification schemes (e.g., TCP+AQM/ECN) have significant
% limitations in achieving this goal. While the XCP protocol addresses this
% challenge, it requires multiple bits to encode the congestion-related
% information exchanged between routers and end-hosts. Unfortunately, there is no
% space in the IP header for these bits, and solving this problem involves a
% non-trivial and time-consuming standardization process. In this paper, we design
% and implement a simple, low-complexity protocol, called variable-structure
% congestion control protocol (VCP), that leverages only the existing two ECN bits
% for network congestion feedback, and yet achieves comparable performance to XCP,
% i.e., high utilization, negligible packet loss rate, low persistent queue
% length, and reasonable fairness. On the downside, VCP converges significantly
% slower to a fair allocation than XCP. We evaluate the performance of VCP using
% extensive ns2 simulations over a wide range of network scenarios and find that
% it significantly outperforms many recently-proposed TCP variants, such as HSTCP,
% FAST, CUBIC, etc. To gain insight into the behavior of VCP, we analyze a
% simplified fluid model and prove its global stability for the case of a single
% bottleneck shared by synchronous flows with identical round-trip times.



%
% =====>> PAREI AQUI. LER O ARQUIVO http://yuba.stanford.edu/rcp/RCP-IWQoS.pdf,
% SEÇÃO 2.2
%
% Rate Control Protocol (RCP) is a congestion control algorithm designed for fast
% download times (i.e. aka user response times, or flow-completion times). Whereas
% other modifications to TCP (e.g. STCP, Fast TCP, XCP) are designed to work for
% specialized applications that use long-lived flows (scientific applications and
% supercomputer centers), RCP is designed for the typical flows of typical users
% in the Internet today. For example, a mid-size flow in the Internet today
% contains 1000 packets and TCP typically makes them last 10x longer than need-be
% (XCP is even worse). RCP makes flows finish close to the minimum possible,
% leading to a perceptible improvement for web users, distributed computing, and
% distributed file-systems. We believe RCP is the only congestion control
% algorithm to do this.
% The main properties of RCP are:
%
% Typical Internet flows will see 10 times faster download times than TCP and 30
% times faster than XCP. Winners are the greater than 90% of sessions that never
% leave slow-start today.
% Efficiently uses high bandwidth-delay product networks such as the long haul
% optical links
% Provably stable network independent of link-capacities, round-trip times and
% number of flows
% Flows are easy to police, to ensure they adhere to congestion control (not
% generally possible with other schemes)
% Network operators can give preference (or weighted preference) to some
% flows/aggregates.
% RCP has two components: (1) End-host congestion control layer that sits between
% IP and TCP/UDP. During introduction, the end-host could adapt by testing for RCP
% at each end and along the path, falling back to TCP if need-be. (2) Each router
% maintains a single fair-share rate per link. Each packet carries the rate of the
% bottleneck link. For each packet, the router compares the two values. If the
% router's fair-share rate is smaller, it overwrites the value in the packet. This
% way, the source learns the fair-share rate of bottleneck link. It is simple,
% requires a very minor change to switches/routers and requires no per-flow
% state.

% \subsubsection{Considerações do GMTP-UCC em caminhos \setwayisfs e \setwayif}

% \subsubsection{Integração do GMTP-UCC com o ConEx}
%
% COMPARAR O GMTP AO TCP NO QUE DIZ RESPEITO COMO AS INFORMAÇÕES SÃO EXPOSTAS VIA
% CONEX.
%
% ========== REVER ===========
%
% No GMTP, os nós \repasss transmitem os vetores de ACKs para o seus nós \repasss
% parceiros e não para o nó \servs que origina o fluxo de dados \setpk. Esta é
% uma diferença considerável se o GMTP-UCC for comparado a qualquer variante do
% protocolo TCP, onde um sistema final transmite os pacotes de ACK para o sistema
% oposto e vice-versa. O ponto é o seguinte: sejam todos os caminhos \setwayis tal
% que um nó \repasss= \ways $\in$ \setwayi. No GMTP, um nó \ways enviará o vetor
% de ACKs apenas para seus nós parceiros \waysu{\wayi-1}. Essa estratégia é
% fundamental para uma transmissão de um fluxo de dados ao vivo que leva em
% consideração uma arquitetura P2P e o uso de um mecanismo para controle de
% congestionamento. Quando um nó \ways expõe o seu vetor de ACK apenas para seus
% nós parceiros \waysu{wayi-1}, permite-se uma regulação da taxa de transmissão
% específica apenas entre eles. Isto significa que o GMTP-UCC realiza controle
% de congestionamento regulando a taxa de transmissão entre dois nós \repass
% visinhos a fim de controlar apenas aquelas que estão envolvidos em um
% congestionamento. Com isto, evita-se o aumento ou a redução da taxa de
% transmissão de um fluxo \setpks para todo um caminho \setway, que ocorreria com
% o uso de algoritmos de congestionamento fim-a-fim, como os adotados no TCP.
% Consequentemente, o GMTP-UCC não sobrecarrega a rede com uma taxa de
% transmissão acima do esperado e também não sub-utiliza a rede com uma taxa de
% transmissão inferior a que a rede pode suportar.
%
% ============================
%
% Uma das funcionalidades do
% TCP é computar os pacotes que alcançam o sistema de destino, uma vez que se
% trata de um protocolo com suporte a garantia de entrega cujo mecanismo funciona
% com base na retransmissão de cada pacote perdido. No caso de protocolos como
% o \mudccp, a computação dos pacotes recebidos e perdidos pelo nó receptor é
% realizada pelo algoritmo de controle de congestionamento. No \mudccp-UCC,
% utiliza-se um mecanismo de vetores de ACKs, computado pelo nó receptor e
% transmitido para o nó transmissor, que então são repassados para o algoritmo
% Cubic a fim de definir a próxima taxa de transmissão. Os vetores de ACKs contém
% informações sobre pacotes perdidos ou pacotes marcados com ECN. Para maiores
% detalhes de como funciona o mecanismo de vetores de ACKs, o leitor pode
% consultar a RFC4341~\cite{RFC4341}.
%
%
% O ConEx é um protocolo que permite um nó remetente informar à rede sobre o
% congestionamento experimentado por pacotes anteriormente transmitindo em uma
% determinada transmissão de dados. No GMTP, especificamente no módulo
% GMTP-Inter, discutido na Seção~\ref{subsec:gmtp-intra-inter}, incorporou-se o
% ConEx para permitir que um nó \repasss possa obter as informações de
% congestionamento experimentada pelos seus nós \repasss parceiros. Com tais
% informações expostas aos nós \repass, é possível utilizá-las para realizar
% gerenciamento de tráfego, por exemplo.

% \subsubsection{Justificativa de uso do TCP-Cubic no GMTP}
%
% Por se tratar de um algoritmo já consolidado, decidiu-se omitir explicações
% detalhadas do funcionamento do algoritmo Cubic no \mudccp. Embora não será
% apresentada uma explicação detalhada do algoritmo TCP Cubic, considera-se de
% suma importância justificar os motivos que levaram a escolha do TCP Cubic para
% transmissões unicast no \mudccp.
%
% O primeiro motivo está relacionado com os diversos resultados de pesquisas
% anteriores, incluindo uma série de resultados obtidos no contexto deste
% trabalho. Nos últimos anos diversas pesquisas científicas constataram a eficácia
% do TCP Cubic em termos da sua equidade para com outros fluxos TCP e, ao
% mesmo tempo, para com fluxos de dados TCP transmitidos utilizando outras
% variantes do TCP, como o TCP Vegas~\cite{Low:2002:UTV:506147.506152}, TCP
% HSTCP~\cite{RFC3649} e o recém lançado TCP Compound~\cite{4146841,5472999},
% utilizado na versão do sistema operacional Windows Vista em diante. O TCP Cubic
% não degrada os fluxos de dados transmitidos utilizando estas variantes do TCP e
% também não é degradado quando em disputa com fluxos de dados não-controlados,
% como os transmitidos utilizando o protocolo UDP.
%
% O segundo motivo é que o TCP Cubic tem sido utilizado pela maioria dos sistemas
% em execução na Internet da atualidade, uma vez que este é o algoritmo para
% controle de congestionamento utilizado por padrão para o sistema operacional
% Linux. Diante disto, desenvolver um protocolo cujo mecanismo para controle de
% congestionamento seja compatível com a maioria dos fluxos de dados é uma decisão
% primordial para o correto funcionamento e aproveitamento dos recursos de rede,
% em especial na Internet.

\subsection{Controle de Congestionamento Multicast}
\label{subsec:mudccp-mcc}

Da mesma forma que no \mudccp-UCC, o objetivo principal do \mudccp-MCC é
determinar uma taxa de transmissão equânime entre os fluxos de dados
transmitidos pelo GMTP e por outros protocolos, como o TCP, porém
em modo de transmissão multicast. No caso GMTP-MCC, trata-se de um algoritmo
responsável pelo controle de congestionamento em uma rede local constituída por
\net$_{local}$ = \repasss $\cup$ \subsetcli(\repass). Na prática, os nós da rede
\net$_{local}$ formam um grupo multicast para a transmissão e recepção de um ou
mais fluxos de dados \setpk, onde o nó \repasss sempre será o transmissor e os
nós \clis $\in$ \subsetcli(\repass) os receptores. A estratégia é que o
valor a ser utilizado pelo GMTP-MCC para a taxa de transmissão de fluxo de dados
\setpks seja tão próximo ao valor da taxa de transmissão que o TCP usaria
se este fosse utilizado para transmitir \setpk, tornando-se o GMTP-MCC um
algoritmo \textit{TCP-Friendly}. Um fluxo de dados é considerado
\textit{TCP-Friendly} quando este não degrada a taxa de transmissão de um fluxo
de dados TCP mais do que outro fluxo TCP degradaria se começasse a ser
transmitido na rede.

O \mudccp-MCC foi inspirado em um protocolo publicado pela IETF chamado
\textit{TCP-friendly Rate Control protocol (TFRC)} (RFC 3448~\cite{RFC3448}). O
TFRC é um mecanismo para controle de congestionamento de fluxos unicast que
tenta prevê a taxa de transmissão de um fluxo TCP e utilizá-la em protocolos
diferentes do TCP~\cite{CONG:Floyd00:TFRC:art}. Trata-se de uma abordagem
diferente da utilizada em algoritmos baseados em janela deslizante e que
utilizam pacotes de confirmação para determinar a taxa de transmissão de uma
conexão, como acontece no TCP. No TFRC, o receptor envia para o transmissor
relatórios sobre as perdas observadas e, com base nesse relatório, o transmissor
calcula a nova taxa de transmissão. O TFRC é categorizado com um protocolo
de controle de congestionamento baseado em uma equação matemática
(\textit{Equation Based Congestion Control}) e algoritmos desse tipo são
adotados em diversos protocolos, como no CCIDs 3 e 4 do
DCCP~\cite{RFC4341,RFC4342}. Em resumo, o algoritmo TFRC funciona da seguinte
forma:

\begin{enumerate}[{\tab}1$^{\circ}$]
 \item o receptor mede a taxa de perda de pacotes e a envia para o
nó transmissor;
 \item o nó transmissor usa esse relatório para medir o RTT até o
receptor;
 \item o nó transmissor utiliza a Equação~\ref{eq:trfcmudccp} para determinar
qual será a sua próxima taxa de transmissão em função do relatório de perdas e o
RTT obtidos;
 \item o nó transmissor ajusta sua taxa de transmissão para o valor
calculado no passo anterior.
\end{enumerate}

\begin{equation}
R(s,p) = \frac{s}{RTT \times \left(\sqrt{\frac{2 \times p}{3}} + \left(12 \times
\sqrt{\frac{3 \times p}{8}}\right) \times p \times (1 + 32 \times p^2)\right)}
\label{eq:trfcmudccp}
\end{equation}

\vspace{0.5cm}

Na Equação~\ref{eq:trfcmudccp}~\cite{Padhye98model}, $R(s,p)$ é a taxa de
transmissão medida em bytes/segundo definida em função de \textit{s}, que é o
tamanho do pacote medido em bytes e $p$, que corresponde a taxa de perda de
pacotes observado pelo nó receptor; $RTT$ é o tempo de ida-volta entre o nó
transmissor e o receptor, medido em segundos.

Apesar de ser uma estratégia interessante e funcionar em conexões unicast, em
transmissões multicast o algoritmo descrito anteriormente não é eficiente. O
algoritmo é limitado devido a um problema conhecido por \textit{explosão de
retorno} (\textit{feedback implosion}). Esse problema ocorre quando há muitos
receptores enviando relatórios de perdas para o mesmo transmissor, o que resulta
em uma inundação de relatórios, os quais o transmissor é incapaz de processar em
tempo hábil.

Nesse contexto, para evitar o problema da \textit{explosão de retorno},
determinou-se que apenas alguns nós \clis são obrigados a enviar tais
relatórios ao nó \repass. Estes nós são chamados de nós relatores e
representados por \rel. No GMTP-MCC, a versão original do TFRC foi alterada e
funciona da segunte forma:

\begin{enumerate}[{\tab}1$^{\circ}$]

  \item O nó \repasss executa um algoritmo de eleição de nós relatores \rels
$\in$ \subsetcli(\repass). Na Seção~\ref{subsec:electrelsreps}, descreve-se o
procedimento para eleger os nós \rel.

  \item Os nós \rels calculam a taxa de transmissão utilizando a
Equação~\ref{eq:trfcmudccp}, em vez do transmissor realizar este cálculo,
como na versão original do TFRC;
  \label{step:gmtp-mcc2}

  \item Os nós \rels determinam a taxa de eventos de perda, e não todos os
receptores do grupo multicast. Para calcular o evento de perda $p$, utiliza-se
o mesmo procedimento feito pelo TFRC, onde um intervalo de perda é determinado
por consecutivas perdas de pacotes, desde do primeiro pacote perdido até o
último pacote perdido, seguido de um pacote recebido com
sucesso~\cite{RFC3448,Padhye98model};

  \item O RTT é calculado entre o nó \rels e o nó \repass, com o temporizador
controlado pelos nós \rels e não pelo nó \repass. Isto evita que o nó \repasss
tenha que manter estado de temporizador para cada fluxo de dados \setpks
transmitido para os nós \clis $\in$ \subsetcli(\repass). Para determinar o valor
do parâmetro RTT e calcular a taxa de transmissão através da
Equação~\ref{eq:trfcmudccp}, o GMTP-MCC utiliza a
Equação~\ref{eq:calcrtt-rcp}, que também é utilizada no GMTP-UCC, porém com
$\theta = 0.25$, valor igual ao utilizado no TCP e no DCCP;

  \item A taxa de transmissão a ser utilizada pelo nó \repasss é a média
aritmética de todas as taxas enviadas pelos nós \rel;

  \item Repete-se todos os passos a partir do passo~\ref{step:gmtp-mcc2} a cada
intervalo igual ao RTT ou quando um intervalo de perda $p$ é determinado.

\end{enumerate}

Teoricamente, o GMTP-MCC seria um protocolo \textit{TCP-Friendly} se $R(s,p)$
fosse o valor máximo entre as taxas de transmissão relatadas pelos nós \rel.
Porém, optou-se por utilizar a média aritimética dos valores relatados pelos
nós \rels porque, na prática, diversos fatores podem alterar o estado da rede no
instante da transmissão usando o valor máximo da taxa de transmissão reportada
pelos nós \rel. Com esta decisão, define-se uma margem de segurança
evitando-se que o GMTP-MCC alcance o limite superior para o valor da taxa de
transmissão de um fluxo transmitido com TCP. Além disso, a média aritimética
suaviza os valores subsequentes para a taxa de transmissão a ser utilizada pelo
nó \repass.

Um aspecto importante na medição do RTT está relacionado com o início de uma
conexão GMTP, pois não se sabe o valor para inicial para RTT até o final do
processo de estabelecimento de uma conexão. Nesse caso, deve-se utilizar um
valor consideravelmente alto para evitar taxas de transmissões maiores do
que a rede tem capacidade de suportar. No GMTP, utiliza-se o valor inicial de
RTT igual a \ut{64}{ms}, que é o mesmo adotado no TCP. Quando um nó \clis envia
um pedido de conexão utilizando o pacote do tipo \pac{GMTP-Request}, o mesmo
deve realizar a sua primeira medição do valor de RTT, iniciando-se o marcador de
tempo para o cálculo do RTT quando enviar o primeiro \pac{GMTP-Request} e
parando-o quando receber o pacote do tipo \pac{GMTP-Response}. Em seguida,
deve-se acionar o mecanismo de cálculo da taxa de transmissão através da
Equação~\ref{eq:trfcmudccp}, caso o respectivo nó \clis seja eleito um
nó relator.

% No caso do \mudccp-MCC, cada nó \rels
% agrega as perdas de pacotes que ocorrem dentro de um evento de perda, definido
% por uma ou mais perdas de pacotes no espaço de tempo de um RTT. Para o cálculo
% de $p$, utiliza-se a média dos tamanhos dos intervalos de perda, calculada
% através da média ponderada dos $m$ mais recentes intervalos de perdas $l_k,
% \dots, l_{k-m+1}$ seguindo a Equação~\ref{eq:losseventmean}. O conjunto de todos
% os intervalos de perda é chamado de \textit{histórico de perdas}.
%
% \begin{equation}
% l_{avg} = \frac{\sum_{i=0}^{m} w_i \times l_{k-i}}{\sum_{i=0}^{m} w_i}
% \label{eq:losseventmean}
% \end{equation}
%
% Os pesos $w_i$ são escolhidos de tal forma que os intervalos de perdas mais
% recentes recebem pesos mais altos, decrescendo-os gradualmente até $1$
% para os intervalos de perdas mais antigos. Por exemplo, para $8$ intervalos de
% perda $m$, pode-se utilizar os pesos $w = [5, 5, 5, 5, 4, 3, 2, 1]$. Ao
% utilizar-se da média ponderada para o cálculo da média dos tamanhos dos
% intervalos de perda, obtem-se mudanças mais suaves para o valor de $l_{avg}$ à
% medida que os tamanhos dos intervalos de perdas se tornam mais antigos. Para
% grandes valores de $m$, obtem-se mudanças mais suaves para $p$ ao longo do
% tempo, porém isto também reduz a capacidade de resposta e portanto a equidade do
% protocolo. No TFRC, recomenda-se utilizar valores de $m$ entre $8$ e $32$ e por
% este motivo no \mudccps é considerada esta recomendação. A
% Equação~\ref{eq:losseventmean} é definida na RFC 3448~\cite{RFC3448} e foi
% mantida no \mudccp. O protocolo DCCP também utiliza essa mesma abordagem no
% algoritmo de controle de congestionamento CCID-3~\cite{RFC4342}.
%
% Uma vez definido como determina-se a média dos tamanhos dos intervalos de
% perda, a taxa dos eventos de perda $p$ é definido pelo inverso de $l_{avg}$,
% definido na Equação~\ref{eq:losseventrate}. Como um intervalo de perda é
% definido em função do número de pacotes entre de eventos de perdas consecutidos,
% o mais recente evento de perda não pode influenciar na taxa do evento de perda,
% por isto utilizou a função \textit{max} no denominador da
% Equação~\ref{eq:losseventrate}.
%
% \begin{equation}
% p = \frac{1}{max(l_{avg}(k), l_{avg}(k-1))}
% \label{eq:losseventrate}
% \end{equation}
%
%
% Uma outra observação com relação ao ajuste da nova taxa de transmissão de $s_i$
% está relacionado ao fato de um nó $\hat{r}_i$ se desconectar ou perder
% repentinamente sua conexão. Caso isto aconteça com algum nó $\hat{r}_x$, seu
% valor $T_{\hat{r}_x}$ deverá ser desconsiderado no cálculo da nova taxa de
% transmissão $T_{s_{i}}$. Existem duas formas que um relay $s_i$ pode perceber a
% desconexão de um ou mais nós $\hat{r}_i$. A primeira forma é quando um nó
% $\hat{r}_x$ envia explicitamente um pedido de desconexão para $s_i$,
% tal processo é discutido na Seção~\ref{subsec:mudccp-desconexao}, ao passo que a
% segunda forma é quando um contador de tempo de manutenção de conexão, mantido
% pelo relay $s_i$ se expira, tal processo é discutido na
% Seção~\ref{subsec:electrelsreps}. Com esta medida, evita-se utilizar um taxa de
% transmissão $T_{s_{i}}$ incorreta, portanto não correr o risco de utilizar uma
% taxa de transmissão não condizente com o estado atual da rede.
%
% \subsection{Taxa de Eventos de Perda $p$}
% \label{subsec:mcclossevent}


% Para mais discussões acerca de como funciona o mecanismo para medição dos
% intervalos de perda, consulte a referência~\cite{CONG:Floyd00:TFRC:art}.

% Um aspecto importante no cálculo do valor de $p$ é determinar o seu valor
% inicial.

% \subsection{Cálculo do RTT}
% \label{subsec:mccrtt}
%
% O cálculo do RTT realizado no \mudccp-MCC é feito apenas pelos nós
% reporters e funciona da seguinte forma. Um nó $\hat{r}_i$ transmite ao seu
% respectivo relay $\hat{s}_i$ um pacote de controle e inicia um marcador de
% tempo. Ao receber uma resposta do nó relay $\hat{s}_i$, o nó reporter
% $\hat{r}_i$ pára o marcador de tempo e utiliza este tempo chamado de
% $RTT_{instant}$ para calcular o valor do próximo $RTT$ de acordo com a
% Equação~\ref{eq:calcrtt}.
%
% \begin{equation}
% RTT = \beta \times RTT_{instant} + (1 - \beta) \times RTT
% \label{eq:calcrtt}
% \end{equation}
%
% Note que no \mudccp-MCC não se utiliza o valor de $RTT$ instantâneo
% ($RTT_{instant}$) como o valor do $RTT$, mas sim utiliza-se de um mecanismo
% para suavizar as mudanças do $RTT$ ao longo do ciclo de vida de uma conexão.
% Desta forma, procura-se evitar que valores absurdos de $RTT_{instant}$ -- muito
% baixos ou muito altos com relação aos valores medidos anteriormente --
% influenciem demasiadamente na taxa de transmissão $T_{\hat{s}_i}$.
%
% O mecanismo mencionado anteriormente para suavizar as medições do valor de
% $RTT$ é chamado de Médias Móveis Exponencialmente Ponderadas ou
% \textit{Exponentially Weighted Moving Average} (EWMA). O EWMA foi primeiramente
% utilizado para índices financeiros de medição de risco, onde a série de retornos
% diários com $n$ observações é ponderada por um fator de decaimento. As
% observações mais recentes no tempo são ponderadas com um peso maior que as
% observações mais antigas. O peso de uma observação decai exponencialmente com
% $n$. Em seguida, utilizou-se EWMA em medições de tempo do $RTT$ em protocolos
% como o TCP. Como trata-se de uma estratégia conhecida para medição de RTT, no
% \mudccp-MCC manteve-se o mesmo mecanismo, principalmente por já ter sido
% exaustivamente testado e utilizado. Tanto no TCP quanto no caso do \mudccp,
% utiliza-se $\beta = 0.25$ para o cálculo do valor de $RTT$ através da
% Equação~\ref{eq:calcrtt}~\cite{kurose2006}.

% Porém, diferentemente do mecanismo de medição de $RTT$ no TCP e no TFRC, os nós
% reporters $\hat{r}_i$ são os responsáveis pela medição do $RTT$ e não o nó
% transmissor. Um aspecto importante na medição do RTT está relacionado com o
% início de uma conexão \mudccp, pois não se sabe o valor para $RTT_{instant}$
% até o final do processo de estabelecimento de uma conexão. Nesse caso, deve-se
% utilizar um valor consideravelmente alto para evitar taxas de transmissões
% $T_{\hat{s}_i}$ muito maiores do que a rede tem capacidade de suportar. No
% \mudccp, utiliza-se o valor inicial de $RTT_{instant}$ igual a \ut{150}{ms}.
% Quando um nó $\hat{r}_i$ enviar um pedido de conexão utilizando o pacote do tipo
% \mudccp-Request, o mesmo deve realizar a sua primeira medição do valor de
% $RTT_{instant}$, iniciando-se o marcador de tempo para o cálculo do RTT quando
% enviar o primeiro \mudccp-Request e parando-o quando receber o pacote do tipo
% \mudccp-Response. Em seguida, deve-se acionar o mecanismo de cálculo de
% $T_{\hat{r}_i}$, caso o respectivo nó $\hat{r}_i$ seja eleito como reporter.

% \subsubsection{Confirmação de recepção de \pk}
%
% O GMTP realiza confirmação de recepção de pacotes \pks para avaliar a
% capacidade de entrega e realizar controle de congestionamento.
%
% Nesse contexto, o GMTP é um protocolo orientado a mensagem, como o UDP e o DCCP,
% e não a cadeia de bytes, como é o caso do TCP. Dessa forma, a unidade básica de
% transporte no GMTP é um segmento completo e não cada byte individualmente. O
% tamanho de um segmento varia de acordo com o MTU (\textit{Maximum Transport
% Unit}) da rede, que em geral tem tamanho de \ut{1500}{bytes}, contando com o
% espaço ocupado pelo cabeçalho.
%
% Vetor de ACK \pac{GMTP-DataAck}

\section{Autenticidade de \setpk}
\label{sec:seguranca}

Em uma solução baseada em um modelo de serviço P2P, é possível que nós
mal-intencionados \repasss poluam o sistema com conteúdos que não foram
gerados pelo nó servidor.
%  (Figura~\ref{fig:bucket-brigade-principle-4}).
%
% \begin{figure}[ht]
% \begin{center}
% \includegraphics[natwidth=797,natheight=213,scale=.74]{imgs/bucket-brigade-principle-4.png}
% \end{center}
% \vspace{-0.8cm}
% \caption{Um nó \repasss mal-intencionados podem poluir o sistema com conteúdos
% que não foram gerados pelo nó \serv.}
% \label{fig:bucket-brigade-principle-4}
% \end{figure}
Para evitar esse tipo de ataque, executa-se um procedimento para verificar a
autenticidade de um fluxo de dados \setpk. Para isto, os próprios nós \ways
$\in$ \setwayis verificam se o conteúdo de um pacotes de dados \pks $\in$
\setpks foi alterado por algum nó \ways anterior durante o procedimento de
repasse. Apenas após comprovar a autenticidade de um pacote \pk, o nó \ways
repassa tal pacote de dados \pks para o próximo nó \wayu{\wayconst+1},
transmitindo-os também para seus nós \clis $\in$ \subsetcli$($\way$)$, se houver
demanda. Este procedimento evita que todos os nós \clis que receberem o fluxo de
dados \setpks tenham que verificar a autenticidade dos pacotes \pk, evitando-se
que a rede repasse conteúdo multimídia errados, consequentemente não consumindo
recursos computacionais desnecessários.

Na prática, o ideal seria que todos nós \ways verificassem a autenticidade de
cada pacote \pk, porém, tal ação pode onerar os recursos computacionais de cada
nó \ways e aumentar o tempo de entrega de \pks aos nós
\clis $\in$ \subsetcli$($\way$)$. Isto porque os nós \ways também processam cada
pacote de dados \pks para decidir sobre seu repasse e para executar os
algoritmos de controle de congestionamento, como discutiu-se nas
Seções~\ref{sec:connformnet}, \ref{sec:asptransrecep} e~\ref{sec:ccgmtp}.

Para reduzir a sobrecarga de verificação de autenticidade de um fluxo de dados
\setpks em cada nós \way, definiu-se duas regras, uma para decidir quais
nós devem realizar a verificação de autenticidade (Regra 1) e a outra para
determinar a quantidade de pacotes que se deve realizar tal procedimento
(Regra 2). Tais regras são definidas a seguir.

\begin{enumerate}

  \item apenas os nós \way, tal que \transmitqu{\way} = 1 devem realizar o
procedimento de verificação de autenticidade do fluxo de dados \setpk; e

  \item os nós \way, definidos pela Regra 1, não devem verificar todos os
pacotes \pks $\in$ \setpk, mas apenas uma quantidade $pc(t)$ de pacotes de dados
\pks $\in$ \setpk, em um instante $t$. Nesse caso, define-se
$pc(t)$, apresentada na Equação~\ref{eq:qtpxcheck}, em função de:

  \begin{itemize}

    \item $bs(t, \setpkc)$, o número de pacotes \pks $\in$ \setpks presentes no
buffer de repasse de \ways em um instante $t$;

    \item $\frac{1}{\mid \setwayc^{\lhd}_{\setwayii} \mid -1}$, a probabilidade
de um nó \repasss $\in$ \setwayids ter alterado o conteúdo de um ou mais \pks
presente(s) no buffer de repasse de \way, onde \setwayids $=$
\invert{$\delta(\wayconst_{\wayi+1}$, \setwayi$)$} e \setwayis é o caminho
através do qual se transmite os pacotes de dados \pks $\in$ \setpk;

  \end{itemize}

\end{enumerate}

\begin{equation}
pc(t) = \floor*{bs(t, \setpkc) \times \left(1 - \frac{1}{\mid
\setwayc^{\lhd}_{\setwayii} \mid -1}\right)}
\label{eq:qtpxcheck}
\end{equation}

\vspace{0.5cm}

Sendo assim, quanto mais distante um nó \ways estiver do nó \serv, mais pacotes
\pks $\in$ \setpks devem ser verificados. Antes de entender o procedimento para
verificar a autenticidade de um pacote \pks $\in$ \setpk, deve-se entender como
o nó \servs deve gerar os referidos pacotes de dados para que seja possível
verificar sua autenticidade. Este procedimento é explicado a seguir.

\subsection{Transmissão e Assinatura de Autenticidade de \pks $\in$ \setpk}
\label{subsec:gerar-pacote-assinado}

Quando o nó \servs gerar cada pacote de dados \pks $\in$ \setpk, este deve
gerar uma assinatura digital dos dados da aplicação a serem transportados. Em
seguida, o nó \servs deve incluir a assinatura digital gerada no cabeçalho do
pacote de dados \pk, no campo assinatura (\textit{signature}). Para assinar
digitalmente o conteúdo da aplicação, utiliza-se o método de criptografia
assimétrica RSA, onde $K^{-}_{\servconst_{\servi}}$ e
$K^{+}_{\servconst_{\servi}}$ representam a chave privada e a chave pública de
\serv, respectivamente. No Trecho de Código~\ref{algo:digitalSignPacket},
apresenta-se o procedimento de assinatura de um pacote \pks $\in$ \setpks
adotado no GMTP, utilizando-se a mesma técnica apresentada
na Seção~\ref{sec:crypthashdigitalsign}.

\vspace{0.5cm}

\begin{algorithm}[H]
\label{algo:digitalSignPacket}
\caption{digitalSignPacket(\pk: \pac{GMTP-Data})}

\SetAlgoLined
\tcc{\servs executes this algorithm to digital sign the packet content using
its private key $K^{-}_{\servconst_{\servi}}$ and a pre-defined hash function,
such as the well-know md5 or sha1 function. \servs get the value of data field,
which is the content that application wants to transport and generates a
signature by encrypt the hash of the data using the \servs private key. After,
put the generated signature in the signature field of the packet \pk. The
signature field will be used later by a note \repasss to verify the packet \pks
authenticity executing the Algorithm~\ref{algo:verifyPacketAuthenticity}.}

\SetKwFunction{Union}{Union}\SetKwFunction{getPacketFieldValue}{getPacketFieldValue}
\SetKwFunction{Union}{Union}\SetKwFunction{setPacketFieldValue}{setPacketFieldValue}
\SetKwFunction{Union}{Union}\SetKwFunction{hash}{hash}
\SetKwFunction{Union}{Union}\SetKwFunction{encrypt}{encrypt}

\textit{data} \attrib \getPacketFieldValue{\pk, `data'}\;
\textit{hashValue} \attrib \hash{\textit{data}}\;
\textit{signature} \attrib \encrypt{$K^{-}_{\servconst_{\servi}}$,
\textit{hashValue}}\;
\setPacketFieldValue{\pk, `signature', \textit{signature}}\;
\Return{\pk}\;

\end{algorithm}
\vspace{0.8cm}

\subsection{Verificação de Autenticidade de \pks $\in$ \setpk}
\label{subsec:verifyPacketAuthenticity}

Após definir as regras para verificação de autenticidade do fluxo de dados
\setpk e a quantidade de pacotes $pc(t)$ que um nó \ways deve verificar, nesta
seção discute-se como ocorre o procedimento de verificação de autenticidade de
um ou mais pacotes de dados \pks $\in$ \setpk.

Dada a quantidade $pc(t)$ de pacotes que \ways deve verificar suas respectivas
autenticidades, o nó \ways escolhe aleatoriamente (distribuição uniforme) os
pacotes \pks disponíveis no buffer de recepção, gerando um conjunto \setpk'
$\subset$ \setpk. Uma vez definido \setpk', \ways executa o procedimento de
verificação de autenticidade que funciona a seguinte forma. Para cada pacote
\pks $\in$ \setpk', extrai-se a assinatura do pacote \pk, gerada pelo nó \serv,
como explicado na Seção~\ref{subsec:gerar-pacote-assinado}. Em seguida,
extrai-se o campo de dados para que se possa verificar sua autenticidade. Para
isto, gera-se o valor de \textit{hash} do campo de dados e compara-se com o
valor de \textit{hash} gerado pelo nó \servs no momento da transmissão do
pacote \pk. Note que o valor de \textit{hash} gerado pelo nó \servs é obtido
através de processo de decriptar a assinatura do pacote de dados \pks utilizando
a chave pública do nó \serv. Assim, se o valor de \textit{hash} gerado com base
no conteúdo transportado no pacote \pks for igual ao valor de \textit{hash}
disponível na assinatura do pacote, conclui-se que o pacote \pks não foi
alterado por nenhum nó \ways $\in$ \setwayids $=$
\invert{$\delta(\wayconst_{\wayi+1}$, \setwayi$)$}. Se o pacote de dados \pks
não foi alterado, marca-o como aprovado para ser repassado, caso contrário,
marca-o como desaprovado e deve ser descartado. No Trecho de
Código~\ref{algo:verifyPacketAuthenticity}, apresenta-se o procedimento de
verificação de autenticidade de um pacote \pks $\in$ \setpk.

\vspace{0.5cm}

\begin{algorithm}[H]
\label{algo:verifyPacketAuthenticity}
\caption{verifyPacketAuthenticity(\setpk': \textbf{array of} \pac{GMTP-Data})}

\SetAlgoLined
\tcc{\ways executes this Algorithm to check if the content of a subset of
packets \setpk' $\subset$ \setpks was modified. It marks each \pks $\in$ \setpk'
to be relayed or discarded. \ways uses the \servs public key to decrypt the \pks
signature and compares it to the hash value of the \pks content. It marks \pks
to be relayed if \pks content was not modified, otherwise it marks \pks to be
discarded, because \pks was modified by a node in \setwayids $=$
\invert{$\delta(\wayconst_{\wayi+1}$, \setwayi$)$}.}

\SetKwFunction{Union}{Union}\SetKwFunction{getPacketFieldValue}{getPacketFieldValue}
\SetKwFunction{Union}{Union}\SetKwFunction{GMTPResponse}{GMTPResponse}
\SetKwFunction{Union}{Union}\SetKwFunction{hash}{hash}
\SetKwFunction{Union}{Union}\SetKwFunction{decrypt}{decrypt}
\SetKwFunction{Union}{Union}\SetKwFunction{destroy}{destroy}

verifiedPackets \attrib \textbf{array of} boolean;

\ForEach{\pks $\in$ \setpk} {
  \textit{signature} \attrib \getPacketFieldValue{\pk, `signature'}\;
  \textit{data} \attrib \getPacketFieldValue{\pk, `data'}\;
  \textit{verifiedPackets[$x$]} \attrib $($\hash{\textit{data}} =
\decrypt{$K^{+}_{\servconst_{\servi}}$, \textit{signature}}$)$\;
}
\Return{\textit{verifiedPackets}}\;

\end{algorithm}
\vspace{0.8cm}


\subsection{Habilitar / Desabilitar a Validação de Pacotes \pks $\in$ \setpk}

A função de verificação de autenticidade de um fluxo de dados \setpks do GMTP é
opcional e desabilitada por padrão. Isto porque um sistema de transmissão, em
execução na camada de aplicação, pode ou não desejar tal função. Por isso,
considera-se que apenas o nó \servs tem o controle de habilitar tal
funcionalidade, e este procedimento requer sinalizar os nós \ways para que
estes executem o procedimento de verificação de autenticidade descrito
na Seção~\ref{subsec:verifyPacketAuthenticity}. Para isto, o nó \servs ativa
a opção assinado (\textit{signed}), disponível no pacote de dados
\pac{GMTP-Register-Reply}, sinalizando que todos os pacotes de dados \pks
$\in$ \setpks conterá a assinatura da porção de dados sendo transportados
naquele pacote de dados, podendo ser verificado pelos nós \ways $\in$
\setwayi, desde que \transmitqu{\way} $=$ 1.

Note que quando um nó \clis $\in$ \subsetcli$($\repass$)$ solicitar um fluxo
de dados \setpk, em resposta a tal pedido, o nó \repasss retornará um pacote do
tipo \pac{GMTP-Request-Notify}. No cabeçalho desse pacote, o nó \repasss deve
também ativar a opção assinado (\textit{signed}) para que o nó \clis seja
notificado e entenda que seu nó \repasss realizará a verificação de
autenticidade do fluxo de dados \setpks da forma descrita anteriormente na
Seção~\ref{subsec:verifyPacketAuthenticity}. Este procedimento permitirá que a
aplicação em execução no nó \clis possa informar ao usuário final que tal
funcionalidade está habilitada, por exemplo.

Além disso, como parâmetros de configuração, o usuário administrador do nó
\repasss pode habilitar ou desabilitar a opção de verificação de autenticidade
dos fluxos de dados \setpk, mesmo que o nó \servs possibilite tal verificação,
como descrito anteriormente. Por fornecer essa função de verificação da porção
de dados transportado em um pacote, no GMTP não realiza-se checagem de erro por
soma de verificação (checksum), tradicionalmente utilizado em protocolos como
TCP, UDP, DCCP e SCTP.

\subsection{Obtenção da Chave Pública $K^{+}_{\servconst_{\servi}}$ de \serv}
\label{subsec:obterchavepublica}

Um nó \repasss obtem a chave pública $K^{+}_{\servconst_{\servi}}$ de \servs
através do certificado digital disponível na URI especificada no parâmetro
\textit{f} da descrição da mídia, como ilustrou-se no Trecho de
Código~\ref{algo:sdp-mediadesc}, Linha~\ref{line:sdp-mediadesc:f}, da
Seção~\ref{subsubsec:desc-conteudo}. Isto ocorre após o nó \repasss receber o
pacote \pac{GMTP-Register-Reply}, que confirma o registro de participação ou a
conexão para obter um fluxo de dados \setpk, como apresentou-se no Trecho de
Código~\ref{algo:registerRelay}, Linha~\ref{algo-line:respondToClients1},
Seção~\ref{subsec:registro-participacao}.

Após obter o referido certificado digital do nó \serv, o nó \repasss pode
realizar \textit{cache} do certificado, que pode ser utilizado quando os
próximos nós \clis realizarem outras requisições ao nó \serv, evitando
ter que obtê-lo a todo instante. De forma alternativa, o usuário administrador
do nó \repasss pode obter o arquivo de certificação digital do nó \repasss e
informá-lo, por meio de \textit{upload} nas configurações do nó \repass. Deve
ser opcional também para o usuário administrador do nó \repasss escolher se tal
nó deve ou não realizar \textit{cache} dos certificados digitais dos nós \serv.

%
% Para evitar esta situação, empregou-se no GMTP um mecanismo para validação do
% conteúdo de \pks antes que o mesmo seja transmitido para os nós \clis $\in$
% \subsetcli(\repass). Esta função é opcional no GMTP e funciona da forma
% apresentada a seguir.
%
% \begin{enumerate}
%  \item
% \end{enumerate}


\section{Outras Considerações}
\label{sec:outros-aspectos}

Nesta seção, apresentam-se brevemente outras funcionalidades do GMTP, tais como
os canais de comunicação, o procedimento de desconexão e falha de um nó
repassador, adaptação de fluxo,
eleição de nós relatores.

% =========
%
%
% \subsection{Modos de Transmissão:}
% \label{subsec:tiposconexao}
%
% \begin{itemize}
%
%   \item \textbf{\textit{Unicast}:} ocorre em toda comunicação entre dois nós
% \textit{Repassadores GMTP}, com a interpretação do conceito definido por
% \textit{unicast} em sua forma tradicional no contexto de redes de
% computadores.
%
%   \item \textbf{\textit{Multi-unicast}:} é a combinação de dois ou mais
% fluxos de dados \textit{unicast}.
%
% \item \textbf{\textit{Multicast}:} ocorre em toda comunicação entre um nó
% \textit{Repassador GMTP} e seus respectivos \textit{Clientes GMTP}, com a
% interpretação do conceito definido por \textit{multicast} em sua forma
% tradicional no contexto de redes de computadores.
%
% \end{itemize}
%
% O modo \textit{multicast} sempre é utilizado para a transmissão dos datagramas
% correspondentes ao fluxo de dados multimídia. É mandatório que o modo
% \textit{multicast} seja utilizado para transmissões entre um nó
% \textit{Repassador GMTP} e seus \textit{Clientes GMTP} diretos. O modo
% \textit{unicast} é utilizado para que \textit{Clientes GMTP} estabeleçam uma
% conexão com um \textit{Servidor GMTP} ou um \textit{Repassador GMTP} e passe a
% distribuir o conteúdo de dados multimídia em sua rede local.
%
% =========



\subsection{Canais de Comunicação}
\label{subsec:canaiscommudccp}

No GMTP, utilizam-se três canais de comunicação para executar suas
funcionalidades, o canal de controle, o de transmissão unicast e o de
transmissão multicast. A seguir, definem-se tais conceitos.

% (Figura~\ref{fig:canais-comunicacao}).
%
% \begin{figure}[ht]
% \begin{center}
% \includegraphics[scale=.86]{imgs/canais-comunicacao.pdf}
% \end{center}
% \vspace{-1cm}
% \caption{Canais de Comunicação do \mudccp.}
% \label{fig:canais-comunicacao}
% \end{figure}

\subsubsection{Canal de Controle}

Quando um nó repassador iniciar uma instância do protocolo \mudccp, este deve
criar um socket multicast no endereço IP 238.255.255.250 e na porta $1900$, em
toda interface de rede local, ou seja, nas interfaces por onde se permite
acesso aos nós clientes. Através desse socket, um nó GMTP é capaz de enviar e
receber pacotes de controle utilizados para negociar as funções de transmissão
de um determinado fluxo de dados de mídia ao vivo. Por exemplo, utiliza-se este
canal para permitir que um nó cliente envie pedidos de conexão e descubrir quais
fluxos de dados já estão sendo recebidos e qual canal multicast cada um deles
está disponível.

A decisão do uso do endereço IP multicast \textit{238.255.255.250} foi baseada
na RFCs 2365~\cite{RFC2365}, que define o escopo administrativo do uso dos
endereços multicast entre 239.0.0.0 e 239.255.255.255. O endereço
\textit{238.255.255.250} é definido no escopo de uso global e sua alocação deve
ser confirmada pela IANA antes do uso massivo do GMTP na Internet.

\subsubsection{Canal de Transmissão Unicast}

O canal de controle e recepção unicast é criado por todos os nós repassadores ao
iniciar uma instância do protocolo GMTP. Na prática, trata-se de um socket que
os nós repassadores formam as devidas parcerias para transmitir os fluxos de
dados uns para os outros e, posteriormente, serem disseminados em
modo multicast pelos respectivos nós repassadores aos seus clientes.

Do ponto de vista de roteamento, todo nó repassador deve avaliar os datagramas
GMTP e realizar as ações apropriadas, definidas nas próximas seções deste
capítulo. Por exemplo, no processo de estabelecimento de conexão, a ser
detalhado na Seção~\ref{subsec:conexao-requisicao}, ao processar um pacote GMTP
transmitido por um nó cliente, o nó repassador deve verificar se o pacote é do
tipo \pac{GMTP-Request} e, em caso positivo, deve-se retornar um pacote do tipo
\pac{GMTP-Response} ao nó cliente, se o fluxo de dados de interesse do nó
cliente especificado no pacote \pac{GMTP-Request} já estiver sendo recebido por
tal nó repassador.

% \subsubsection{Canal de Controle Unicast}
%
% Tal canal de controle é criado apenas entre os nós repassadores e relatores
% para troca de informações implementar as funcionalidades do protocolo, tais
% como
% procedimentos de estabelecimento de conexão, descoberta de nós e notificações
% de
% desconexões, eleição de nós relatores e envio e recebimento de relatórios para
% controle de congestionamento.

\subsubsection{Canal de Repasse Multicast}

O canal de repasse multicast é utilizado por um nó repassador para encaminhar
datagramas vindos de um servidor ou de outro repassador para a rede local. Na
prática, esse canal de repasse é um socket multicast criado pelo nó repassador
para transmitir os datagramas para todos os seus clientes com interesse em
reproduzir um fluxo de dados de um evento ao vivo.

O \textit{socket de repasse multicast} deve ser criado quando um nó repassador
começa a receber um determinado fluxo de dados correspondente a um evento de
interesse de pelo menos um dos seus clientes. Na prática, quando isto acontece,
o repassador deve criar um socket multicast em um endereço IP e número de porta
escolhida aleatoriamente na faixa de endereços IP de escopo local
239.192.0.0/14, definida na RFC 2365~\cite{RFC2365}. Como se trata de uma
faixa de endereçamento IP multicast de domínio local, não se faz necessário
registrar o uso desses endereços. Isto significa que para todo fluxo de dado de
um evento ao vivo, deve-se alocar um endereço IP e uma porta. No caso do esquema
de endereçamento IPv4, será possível definir a transmissão de exatos
17.179.607.040 (dezessete bilhões, cento e setenta e nove milhões, seiscentos e
sete mil e quarenta) diferentes fluxos de dados em uma rede local, o que é mais
do que suficiente e escalável por vários séculos.


% \subsubsection{Canal de Recepção de Dados:}
%
% O canal de recepção de dados é um socket multicast criado por um
% cliente para receber um fluxo de dados transmitindo por um nó repassador em
% algum endereço IP da faixa 239.192.0.0/14. Alternativamente, um canal de
% recepção de dados será um socket unicast quando existir apenas um
% cliente em uma rede interessado por um fluxo de dados, utilizando-se o
% endereço da sua própria interface de rede local. O endereço IP e o
% número de porta que o cliente deve se conectar é determinado pelo nó
% repassador
% no momento da conexão.

% \subsection{Diagrama de Estados do GMTP}
%
% TBD

% \section{Fluxograma de Estados do \mudccp}
%
% Após o processo de estabelecimento de conexão do \mudccp, o protocolo entra no
% estado de transmissão de dados, se o nó for um servidor ou um relay, ao passo
% que o protocolo entra no estado de recepção de dados, se o nó for um cliente.
%
% Um servidor ou um relay começa a transmitir os dados após o processo de
% estabelecimento de conexão e até quando o fluxo de dados no servidor se
% encerrar ou quando o relay não desejar mais receber o fluxo de dados.
%
% =========


\subsection{Procedimentos para Desconexão de nós \cli, \rels e \repass}
\label{subsec:desconexao}

% \begin{figure}[ht]
% \begin{center}
% \includegraphics[natwidth=797,natheight=173,scale=.73]{imgs/bucket-brigade-principle-3.png}
% \end{center}
% \vspace{-0.8cm}
% \caption{Um usuário pode desconectar e é preciso um mecanismo de tolerância à
% desconexão.}
% \label{fig:bucket-brigade-principle-3}
% \end{figure}
%
% \vspace{0.5cm}

O processo de finalização de uma conexão \mudccps ocorre com algumas
diferenças se comparado com outros protocolos orientados à conexão. Para
sinalizar uma desconexão, um nó \clis transmite um pacote do tipo
\pac{GMTP-Close} pelo canal de controle, contendo o nome do fluxo que deseja
se desconectar. Ao receber este tipo de pacote, o nó \repasss transmite ao nó
\clis um pacote do tipo \pac{GMTP-Reset}, sinalizando que está ciente do
fechamento da conexão. Nesse interim, os nós desalocam recursos relacionados à
respectiva conexão. Este procedimento é suficiente para o pedido de finalização
de uma conexão de um cliente \mudccp, porém para finalizar uma conexão de um nó
\rels e \repasss outros procedimentos são necessários.

\subsubsection{Desconexão de um nó \rel}

Como apresentado na Seção~\ref{subsec:mudccp-mcc}, um nó \rels é responsável
por relatar ao nó \repasss as condições de recepção de pacotes \pks $\in$
\setpks em uma transmissão multicast e assim determinar a taxa de transmissão
que deve ser utilizada para repassar o referido fluxo de dados. Sem os nós
\rel, tal procedimento não seria possível. Sendo assim, deve-se realizar um
procedimento para eleger um novo nó \rels quando um nó com tal responsabilidade
solicite desconexão. Os candidados a se tornar nó \rels são os nós \clis já
recebendo o fluxo de dados \setpk, sendo que o nó \rels em procedimento de
desconexão deve esperar que o procedimento de nova eleição seja concluído. Nesse
interim, o nó \rels em processo de desconexão deve continuar enviando pacotes
do tipo \pac{GMTP-Ack} para o nó \repass.

\subsubsection{Desconexão de um nó \repass}

Um nó \repasss realiza o procedimento de desconexão não por intervenção da
aplicação, mas sim quando \subsetcli(\repass) $=$ $0$ para um determinado
fluxo de dados \setpk, ou quando o nó \serv explicitamente sinaliza a
desconexão. Neste caso, pode ocorrer uma situação crítica para todos
os nós parceiros \repassu{q} de \repass, pois teoricamente estes não poderão
mais receber os pacotes de dados \pks $\in$ \setpk. Para evitar um período de
instabilidade na recepção de \setpks por parte dos nós parceiros de \repass,
define-se um parâmetro chamado de período de carência para novas parcerias
(\textit{grace period for new partnerships}). Trata-se de um parâmetro
que determina o tempo que um nó \repass, em processo de desconexão, continuará
repassando o fluxo de dados \setpks para seus parceiros \repassu{q}.

O valor para o \textit{período de carência para novas parcerias} é transmitido
para os nós parceiros \repassu{q} de \repass, que por sua vez deve iniciar o
procedimento de realizar outras parcerias a fim de continuar recebendo o fluxo
de dados \setpks (Fase 3 do procedimento de conexão do GMTP). Opcionalmente, um
nó \repasss pode aceitar receber de seus nós parceiros \repassu{q}, o valor
para o período de carência, desde que não ultrapasse um limite máximo definido
pelo administrador de \repass.

% \subsubsection{Falha de um nó \repass}
%
% \begin{figure}[ht]
% \begin{center}
% \includegraphics[scale=.5]{imgs/esquema-abstrato-formacao-parceria-intra-falha.pdf}
% \end{center}
% \vspace{-0.8cm}
% \caption{Cenário de falha do nó \repassu{6} em um caminho \setwayiu{1}, seguida
% de constituição de um novo caminho \setwayiu{3} formado pelo procedimento de
% formação de parceria intra \setwayi.}
% \label{fig:esquema-abstrato-formacao-parceria-intra-falha}
% \end{figure}
%
% Além da desconexão explícita de um nó \repass, uma ação específica deve ser
% realizada se um nó \ways $\in$ \setwayis circunstancialmente falhar. Para tratar
% estes casos, definiu-se que o nó \repasss pode formar parcerias com os próprios
% nós \repasss $\in$ \setwayid, tal que \setwayid\space $=$
% \invert{$\delta($\wayu{\wayi+1}, \setwayi$)$}, através
% de uma outra rota de rede que também alcance o nó \servs -- isto pode acontecer
% devido à execução de algoritmos de roteamento dinâmico \textit{Intra-AS
% (Autonomous Systems)}, por exemplo, o OSPF, e \textit{Inter-AS}, por exemplo, o
% BGP~\cite{kurose2006}.
%
% Para entender o comportamento do GMTP em caso de falha de um nó \repass,
% observe a Figura~\ref{fig:esquema-abstrato-formacao-parceria-intra-falha}. Se o
% nó \repassu{6} falhar e o nó \repassu{14} também estiver repassando \setpk, uma
% nova parceria é formada transparentemente entre o nó \repassu{7} e o nó
% \repassu{14}. Isto porque o nó \repassu{14} interceptará os pacotes de controle
% de \textit{keep-aline} que o nó \repassu{7} está transmitindo para o nó \serv.
% Mas, pode acontecer o caso de que \transmitru{14} $ = 0$ e \transmitru{13} $ =
% 0$ para o fluxo de dados \setpk, portanto o pedido de conexão enviado pelo nó
% \repassu{9} alcançará o nó \servu{1} como antes. Isto resultará na constituição
% de um novo caminho \setwayiu{3} $=$ \setwayidu{1} $\cup$ \setwayidu{2}, tal que
% \setwayidu{1} $=$ \invert{$\delta($\repassu{6}, \setwayiu{1}$)$} e \setwayidu{2}
% $=$ $\delta($\invert{\setwayiu{2}}, \repassu{15}$)$. Isto fará com que todo o
% caminho \setwayiu{3} repasse o fluxo de dados \setpk. Como consequência,
% aumenta-se a possibilidade de parcerias futuras com nós \repasss cujo pedido de
% conexão para obter \setpks seja roteado pelo caminho \setwayiu{3}. Para este
% caso, criou-se o procedimento de formação de parceria por intersecção de
% caminhos \setwayi, detalhado mais adiante.
%
% Na Seção~\ref{subsec:desconexao}, apresenta-se uma discussão geral sobre o
% comportamento do GMTP em outros casos de desconexões. O procedimento de formação
% de parceria intra \setwayi, apresentado nesta seção, está intimamente
% relacionado com o processo de estabelecimento de conexão do GMTP, detalhado mais
% adiante na Seção~\ref{subsec:conexao-requisicao}.


\subsection{Eleição de nós \rel}
\label{subsec:electrelsreps}

Para um fluxo de dados \setpk, o primeiro nó \rels será o nó \clis que iniciar a
primeira conexão para obter o referido fluxo. Os seguintes nós \rels serão os
próximos nós \clis que se conectar para receber o fluxo de dados \setpk, até
atingir um parâmetro que determinará a quantidade máxima de nós \rels por fluxo
de dados \setpk. Tal parâmetro pode ser determinado pelo administrador do nó
\repass. Por padrão, utiliza-se $\frac{1}{6}$ dos nós \clis $\in$
\subsetcli$($\repass$)$ como sendo nós relatores para a transmissão de um fluxo
de dados \setpk.

Sendo assim, à medida que um nó \repasss recebe pacotes do tipo
\pac{GMTP-Request}, no pacote de resposta \pac{GMTP-Response}, o nó
\repasss ativa um indicador sinalizando que o referido nó \clis em processo de
conexão deverá se comportar como um nó \rel, passando a enviar relatórios
da taxa de transmissão calculada, como discutiu-se na
Seção~\ref{subsec:mudccp-mcc}.

% Note que este modo de transmissão deve
% ser implementado com garantia de entrega, ou seja, com a confirmação de recepção
% de pacotes e retransmissão caso este tipo de pacote seja perdido. Assim, um nó
% \repasss poderá ter controle sobre a quantidade de nós \rels e receber
% relatórios apenas dos nós \rels $\in$ \setrel.

Uma outra situação que se faz necessária a eleição de nós \rels é no
procedimento de desconexão, como explicado na Seção~\ref{subsec:desconexao}.
Para esse caso, quando o nó \repasss receber o pacote do tipo
\pac{GMTP-Close}, este deve verificar se o referido nó \clis é um nó \rel. Em
caso afirmativo, o nó \repasss deve transmitir para um dos nós \clis que
também recebe o referido fluxo de dados \setpks (se houver), um pacote do tipo
\pac{GMTP-Elect-Request} e aguardar por um \pac{GMTP-Elect-Response}. Este procedimento
deve ocorrer com garantia de entrega.






% Ao \mudccps foi incorporado um mecanismo de tolerância a desconexão que
% funciona de modo a evitar que os nós clientes deixem de receber dados da
% transmissão em questão, caso um nó relay desconecte repentinamente sem conseguir
% transmitir um pacote do tipo \mudccp-ElectAck, tal como explicado na
% Seção~\ref{subsec:mudccp-desconexao}. Considere $T$ uma variável corresponde a
% $4$ vezes o valor do tempo do RTT. Um nó relay deve transmitir no canal de
% controle um pacote do tipo \mudccp-AdvConn a cada instante de $T$, anunciando
% aos demais nós da rede que está ativo e operando corretamente. Caso um nó relay
% secundário não receba o pacote do tipo \mudccp-AdvConn durante o período de
% tempo $T$, assume-se que o relay atual foi desconectado por algum motivo
% desconhecido e o relay secundário que não recebeu o pacote do tipo
% \mudccp-AdvConn deverá transmitir um pacote do tipo \mudccp-ElectAck. Na
% prática, o nó relay secundário torna-se um nó relay primário do o grupo de
% clientes, incluindo os nós reporters, conectados ao relay que foi desconectado.
% Neste caso, o novo nó relay deve iniciar um novo processo de estabelecimento de
% conexão. Após o estabelecimento dessa conexão, como descritos na
% Seção~\ref{sec:conexaomudccp}, o novo nó relay deve criar o canal de repasse e
% começa a repassar os dados da transmissão multimídia.


% \subsection{Adaptação de Fluxo de Dados}
% \label{subsec:adapt-flow}
%
% \begin{figure}[ht]
% \begin{center}
% \includegraphics[natwidth=794,natheight=170,scale=.73]{imgs/bucket-brigade-principle-2.png}
% \end{center}
% \vspace{-0.8cm}
% \caption{Uma aplicação pode não ter recurso suficiente, adaptações devem ser realizadas.}
% \label{fig:bucket-brigade-principle-2}
% \end{figure}
%
%
% Uma funcionalidade peculiar do \mudccps é sua capacidade de permitir a
% realização de adaptação de fluxos multimídia de forma distribuída. A maioria
% das soluções para transmissão de dados multimídia, além de realizar controle
% de congestionamento no nível de aplicação, realizam adaptação de fluxo
% multimídia na fonte geradora dos dados. Em diversas soluções
% existentes, os autores consideram a transmissão de fluxos de dados multimídia
% adaptados e transmitidos em diferentes canais, sendo que em cada canal
% transmite-se os fluxos multimídia em uma determinada qualidade. Dependendo da
% qualidade desejada pelo nó receptor, o sistema cliente solicita a transmissão em
% um determinado canal. O problema dessa abordagem é que o nó transmissor,
% necessariamente deve transmitir os dados em múltiplos canais, o que aumenta a
% complexidade da aplicação e a quantidade de fluxos de dados sendo transmitidos a
% partir do servidor.
%
% No \mudccp, é possível realizar a adaptação de fluxo de dados de forma
% distribuída, na prática, em cada relay. Por exemplo, considere duas redes
% adjacentes, rede 1 e rede 2. Considere que existe um nó relay na rede 1 e entre
% a rede 1 e o nó transmissor a largura de banda de transmissão disponível seja de
% \ut{100}{Mbps}. Caso a largura de banda disponível na rede 2 seja de no
% máximo \ut{10}{Mbps}, um nó receptor na rede 2 teria que solicitar um fluxo
% multimídia em um canal diferente, considerando as soluções que adotam a
% estratégia de adaptação de fluxo com o uso de múltiplos canais de transmissão.
% No caso do \mudccps é possível que um nó na rede 2 obtenha o fluxo multimídia
% através do relay presente na rede 1, com o relay da rede 1 adaptando o fluxo
% multimídia de acordo com a capacidade do canal de transmissão disponível para a
% rede 2. Desta forma, pode-se diminuir o tráfego na rede do nó transmissor e
% ainda permitir que nós em redes com largura de banda limitada consigam obter o
% fluxo multimídia adaptado (caso mais comum para clientes residenciais).
%
%
%
%
%
%
%
%
%
%
% Com essa estratégia, fica óbvio que quanto mais requisições de
% \textit{pull} por uma parte da mídia, mais urgente é o seu conteúdo para
% reprodução. Muitas requisições via \textit{pulling} é um sinal que a rede não
% está sendo capaz de entregar \pks tão rápido quanto o suficiente para permitir
% a reprodução sem que haja interrupções. Essa informação pode ser utilizada para
% adaptar o fluxo de dados \setpk, reduzindo-se sua qualidade e consequentemente
% exigindo menos da rede.
%
%
%
%
%

% \section{Implemetação e Implantação}
% \label{sec:impl}
%
% PROVER API PARA SETAR AS INFOS DO SDP
%
% O \mudccp\space não necessita explicitamente da instalação de um nó na rede para
% encaminhar o conteúdo de uma rede externa para uma rede interna
% (\textit{proxy}). Além disso, o \mudccp\space mantém a \textit{interface} de
% programação com a camada de aplicação inalterada, apenas adicionando uma
% extensão na API padrão de socket BSD para preservar a compatibilidade
% com as aplicações multimídia existentes e, ao mesmo tempo, permitir que as
% aplicações façam uso dos novos recursos do \mudccp. Esta decisão pode ajudar em
% uma rápida adoção do GMTP nas aplicações multimídia, permitindo-se simples
% alterações das aplicações existentes e, ao mesmo tempo, a efetiva padronização
% da forma como algumas funcionalidades hoje em dia são implementadas.


% \section{Benefícios, Aplicabilidade e Justificativas}
% \label{sec:benef}


%\subsection{Seleção de Parceiros e de \textit{Chunks}}

% \subsection{Balanceamento de Carga}
%
% Um outro aspecto interessante do protocolo \mudccps é sua capacidade em
% permitir divisão de carga entre nós relays. Como os nós relays recebem e
% repassam os fluxos de dados oriundos de um servidor, obtem-se natualmente uma
% solução de distribuição de conteúdo multimídia sem sobrecarregar a fonte
% geradora de dados (geralmente o servidor). Porém, mesmo considerando o
% mecanismo atualmente empregado no \mudccps para divisão de carga entre nós
% relays, atualmente estuda-se um mecanismo complementar de balanceamento de
% carga a fim de evitar que os nós relays entre em colapso de congestionamento
% devido ao grande número de clientes conectados a um determinado nó relay.
%
% Considerando isso, está em estudo no contexto do protocolo \mudccps um
% mecanismo
% de balanceamento de carga que quando um nó relay possui muitas conexões de
% clientes permite-se que outro nó cliente seja... PROBLEMA: UM RELAY POR REDE!


% \subsection{Outra Estratégia para Descoberta de Nós Relays}
% \label{sec:arcdescorels}
%
% Um aspecto primordial do \mudccps é a capacidade de obter fluxos de
% dados multimídia através de nós relays, os quais repassam esses dados vindo de
% uma fonte geradora. No processo de conexão, esses nós relays são encontrados,
% aceitam conexões de clientes e repassam dados da aplicação como se fossem o
% nó servidor. Um gargalo no procedimento padrão adotado no \mudccps é que pode-se
% demorar até que um cliente \mudccps encontre um nó relay e comece a receber o
% fluxo de dados desejado devido ao mecanismo de busca por profundidade por nós
% relays utilizando transmissões multicast, utilizando-se valores incrementais
% para o campo de TTL presente no cabeçalho IP.
%
% Diante disso, está em estudo no contexto desse trabalho um mecanismo alternativo
% para permitir que um nó cliente encontre um nó relay mais rapidamente. Este
% mecanismo consiste em permitir que um nó cliente solicite diretamente ao nó
% servidor a lista de nós relays conectados a ele, ou seja, a lista dos nós
% relays de primeiro nível (Figura~\ref{fig:cenario-global-detailed}).
%
% O mecanismo de busca por nós relays permitirá que o cliente consulte, ao longo
% dos níveis dos nós relays, aquele nó relay que mais se adequa aos requisitos da
% aplicação, principalmente com relação ao atraso observado desde do servidor até
% um determinado relay. Um nó cliente que desejar solicitar esse tipo de
% requisição, utiliza o pacote do tipo \mudccp-RelayQuery e transmite o pedido de
% consulta ao nó servidor, o qual responde ao cliente com a lista dos nós relays
% de primeiro nível utilizando o pacote do tipo \mudccp-RelayReply. Com isto, é
% possível encontrar um melhor relay cujo atraso não ultrapasse um determinado
% limiar de tempo definido pela aplicação, o que não necessariamente será o nó
% relay mais próximo geograficamente do nó cliente.



% , dentre
% outros referenciados em~\cite{REF, REF, REF, REF, REF}.

% discutir aqui sobre o que o protocolo trás de bom para as aplicações
%
% - cloud computing
%
% - transmissão de casa
%
% - vod
%
% - youtube/copa america
%
% - twitcam

% \section{Outros Aspectos Importantes do \mudccp}
%
% \subsubsection{Uso do Campo \textit{Offset} de Dados}
%
% \subsubsection{Uso do Campo \textit{CCVal} de Dados}
%
% \subsubsection{Soma de Verificação e Validação de Pacotes}
%
% \subsection{Compatibilidade com outras recomendação da IETF}
%
% - NAT - http://www.brynosaurus.com/pub/net/p2pnat/
% - 4340
% - GERAÇÃO DO NÚMERO DE SEQUÊNCIA
% - RFC2365
% - RFC4086
% - RFC2119
% - TFMCC 4654
% - 5166
% - TFRC 3448

%\section{Considerações sobre redes de distribuição de conteúdo}

%\section{Considerações sobre a escolha do DCCP como base para o \mudccp}

% \section{Considerações sobre implementação}

\section{Sumário do Capítulo}

Neste capítulo, apresentou-se os fundamentos do \textit{Global Media
Transmission Protocol} (\mudccp), um protocolo de transporte e rede baseado em
uma arquitetura híbrida P2P/CDN para distribuição de fluxos de dados multimídia
ao vivo. Tal arquitetura é caracterizadas por um conjunto de nós servidores que
obtém o conteúdo multimídia da fonte geradora e o transmite para muitos nós
receptores (\mys). O GMTP foi proposto para operar principalmente na Internet,
permitindo a transmissão de pacotes de dados com suporte a controle de
congestionamento sem garantia de entrega, tudo ocorrendo de forma transparente
para a aplicação. O GMTP opera na camada de transporte e rede da pilha de
protocolos GMTP, realizando transmissão em modo multicast ou de múltiplos fluxos
unicast compartilhados entre os nós participantes da transmissão. Neste segundo
caso, tal ação ocorre através de uma rede de favores constituída dinamicamente
entre os roteadores da rede, evitando a relação de uma conexão por cliente ao nó
servidor.

Ao contrário de todos os outro protocolos de transporte e das soluções de
aplicação para redes P2P, o foco de definição do GMTP foi reduzir
responsabilidade dos nós clientes e aumentar a responsabilidade dos roteadores
de rede no processo para distribuição de um determinado conteúdo multimídia.
Este foco teve como principal motivação a proposta das Redes Centradas no
Conteúdo (CCN), onde o roteador passa a ter um papel com maior participação no
processo de entrega de um conteúdo para os nós interessados. Com vistas nos
aspectos da CCN, o GMTP oferece um mecanismo de conexão separado em duas fases,
quando se decide a forma como um determinado nó cliente obterá o conteúdo de
interesse, contando com o suporte dos roteadores nesse processo. Nesse interim,
uma grande peculiridade do GMTP é a função que os nós roteadores
passam a ter de realizar parcerias entre si a fim de obter um determinado
conteúdo multimídia de interesse, identificado por um nome, como especificado
pela teoria das redes centradas no conteúdo.

Diversas estratégias adotadas no GMTP e apresentadas neste capítulo discutidas
são diferenciais que permitem a disseminação mais rapidamente de um determinado
fluxo de dados originado em um nó servidor. Incorporou-se um mecanismo de
\textit{registro de participação} que, após um nó repassador se registrar em um
nó servidor, permite-se que os servidores determinem quais são os candidatos a
parceiros de um nó repassador, o que ocorre periodicamente. A vantagem é que,
\textit{a priori}, permite-se que os nós repassadores avaliem seus parceiros sem
necessariamente um nó estar recebendo um fluxo de dados de um determinado
evento. Com isto, um nó repassador pode repassar um fluxo de dados para um outro
nó repassador sem que o primeiro tenha interesse no referido fluxo, mas devido
ao seu posicionamento na rede e sua capacidade computacional e de vazão, pode
melhorar o processo de disseminação de um determinado fluxo de dados. Além
disso, como se trata de uma rede de favores e os dados são trocados de forma
distribuída, ou seja, nem sempre com a participação de um nó servidor, pode-se
empregar um mecanismo para validação dos dados transmitidos pelo servidor,
evitando-se ataques de poluição, por exemplo.

No GMTP, os responsáveis por formar as parcerias P2P são os nós repassadores e
não mais os nós clientes, como em soluções tradicionais de distribuição de
conteúdo P2P. Como consequência, melhora-se o desempenho das transmissões de
conteúdos multimídia ao vivo, pois o GMTP não é influenciado por fatores que
impactam negativamente no funcionamento da rede P2P, tais como a capacidade de
processamento, armazenamento (memória), mobilidade e dinâmica de
conexão/desconexão (\textit{churn}) dos nós clientes. Esses dois últimos
fatores são mais críticos se comparados aos demais, principalmente com a
popularização dos dispositivos móveis e usar esse tipo de cliente para
compartilhar seus recursos em uma rede P2P não é apropriado.

Um aspecto importante do GMTP são seus dois algoritmos para controle de
congestionamento de fluxos de dados sem garantia de entrega, o \mudccp-UCC e o
\mudccp-MCC. No primeiro, a ser aplicado na transmissão de fluxos de dados
unicast entre os nós roteadores, emprega-se uma solução para controle de
congestionamento assistido pela rede, onde oferta-se para cada fluxo de dados
uma taxa de transmissão igual para todos os fluxos passando por todos os
roteadores de um caminho. Nesse caso, a taxa de transmissão é determinada de
acordo com a capacidade de transmissão do menor roteador em uma determinada
rota. Já no segundo algorimo, a ser aplicado em fluxos de dados multicast,
utiliza-se um algoritmo de controle de congestionamento baseado na equação TFRC
(\textit{TCP Friend Rate Control}), fazendo-se uso de nós especiais chamados de
relatores para determinar a próxima taxa de transmissão que o roteador deverá
utilizar para distribuir o conteúdo multimídia para os nós clientes diretamente
conectados a ele.

Por fim, discutiu-se sobre outras funcionalidades do protocolo \mudccp, tais
como seu mecanismo para finalização de conexão dos tipos de nós do GMTP, eleição
de nós relatores e considerações sobre segurança. No próximo capítulo,
apresentam-se os resultados e discussões acerca do uso do protocolo GMTP para a
distribuição de conteúdos multimídia ao vivo.