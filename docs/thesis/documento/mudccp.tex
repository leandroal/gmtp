\chapter{Global Media Transmission Protocol (\mudccp)}
\label{cap:mudccp}

O \textit{Global Media Transmission Protocol} (\mudccp) é um protocolo de rede
que atual nas camadas de transporte e de rede (\textit{crossing-layer})
projetado para operar na Internet, a ser utilizado em sistemas de distribuição
de fluxos dados multimídia ao vivo. Trata-se de um protocolo baseado em uma
arquitetura híbrida P2P/CDN, onde os dados de um ou mais sistemas são
transmitidos através de uma rede de favores P2P, onde os nós cooperam entre si a
fim de obterem um conteúdo multimídia de interesse ao mesmo tempo que ocorrem
interações entre os servidores de uma ou mais redes CDNs, os quais atuam como
super nós para a rede P2P, auxiliando-os no envio e recebimento dos fluxos de
dados de eventos ao vivo. À medida que recebe um determinado fluxo de dados de
um evento ao vivo, os nós cliente reproduzem tal conteúdo para o usuário final,
através de um processo em execução na camada de aplicação, ao passo que o
roteador de sua rede realiza parcerias com outros roteadores os quais possuem
nós clientes também interessados no mesmo conteúdo a fim de reproduzi-lo aos
seus usuários finais.

As trocas de dados entre nós GMTP ocorrem por meio do envio e recebimento de
pequenas partes do conteúdo de uma mídia, que são transmitidas por diferentes
nós da rede, constituindo um fluxos de datagramas IP. Estes fluxos são
transmitidos em modo \textit{multicast} ou em múltiplos fluxos \textit{unicast}
compartilhados (multi-unicast), realizando-se controle de congestionamento sem
garantia de entrega. A escolha do modo de transmissão utilizado para disseminar
um determinado conteúdo ocorre automaticamente, ou seja, sem a influência da
aplicação que, simplesmente ``sintoniza'' sua conexão em um determinado canal
definido pelo roteador, correspondete ao fluxo de dados de interesse do usuário
final. Tal abstração para a camada de aplicação ocorre de modo que os processos
em execução utilizam o GMTP através de uma API compatível com as especificações
de socket BSD e POSIX.

Por conseguinte, o GMTP permite o estabelecimento de conexões entre diversas
aplicações, executadas de forma distribuída em cada sistema final, tornando-as
compatíveis entre si, uma vez que o protocolo desacopla a forma como os dados
são transportados da forma como estes são exibidos ao usuário final, emulando
os sistemas tradicionais de TV e rádio. Assim, promove-ve a integração do GMTP
em aplicações já existentes, consideradas futuras adoções, ao tempo que
permite-se a utilização dos novos recursos introduzidos no protocolo,
evitando-se a complexidade de construção dos sistemas de transmissão de fluxos
de dados de eventos ao vivo.

Nas próximas seções deste capítulo, detalha-se o funcionamento do GMTP,
conforme a seguinte organização:

\begin{itemize}

\item Na Seção~\ref{sec:visaogeral}, apresenta-se uma visão geral do protocolo,
como cenário de atuação, arquitetura, canais de comunicação e tipos de nós e
pacotes.

\item Na Seção~\ref{sec:defsrests}, formaliza-se as definições e restrições do
protocolo, que serão utilizadas nas seções subsequentes.

\item Na Seção~\ref{sec:connformnet}, descreve-se o processo de
constituição da rede de favores, bem como aspectos de conexão multi-ponto
através da introdução de um novo conceito de sockets P2P. Detalham-se os
aspectos inerantes à constituição de uma rede P2P, tais como o registro de
participação de um nó e o processo de seleção de nós parceiros.

\item Na Seção~\ref{sec:asptransrecep}, discute-se sobre os aspectos de
transmissão e recepção de fluxos de dados, com os algoritmos utilizados para
compartilhar um fluxos de dados e as estratégias de disponibilização e
obtenção das partes de uma mídia.

\item Na Seção~\ref{sec:ccgmtp}, apresentam-se detalhes de funcionamento dos
algoritmos de controle de congestionamento utilizados no GMTP.

\item Na Seção~\ref{sec:seguranca}, discute-se sobre os aspectos relacionados a
validação de autenticidade de um fluxo de dados transmitido através do GMTP.

\item E, por fim, na Seção~\ref{sec:outros-aspectos}, apresentam-se outros
aspectos relacionados ao GMTP, tais como finalização de conexão, tolerância à
desconexão e eleição de nós relatores.

% e
% integração com outros protocolos de rede.
%
% \item Na Seção~\ref{sec:impl}, discute-se brevemente sobre aspectos de
% implementação e implantação do GMTP.
%
% \item E, por fim, na Seção~\ref{sec:benef}, apresenta-se um resumo sobre os
% benefícios e as justificativas de decisões de projeto do protocolo GMTP.

\end{itemize}

\section{Visão Geral do GMTP}
\label{sec:visaogeral}

O GMTP é composto por dois módulos chamados de \textit{GMTP Intra} e
\textit{GMTP Inter}, que operam na camada de transporte e de rede,
respectivamente. O \textit{GMTP Intra} fornece serviços às aplicações de rede a
fim de abstrair a complexidade na execução de tarefas comuns a qualquer
sistema, tais como conexão multi-ponto, multiplexação/demultiplexação de
segmentos IP e controle de congestionamento. O \textit{GMTP Inter} é
responsável por constituir uma rede de sobreposição P2P composta por roteadores,
os quais funcionam como pontes de acesso aos servidores de uma rede CDN.
Sendo assim, para viabilizar a disseminação de conteúdos multimídia, emprega-se
o Princípio da Cooperação de Brigadas de Incêndio (\textit{Fire Bucket Brigade
Principle}), onde cada nó roteador de um caminho constituído entre o servidor
que transmite a mídia e o cliente interessado em obtê-la, pode replicar o
conteúdo sendo roteado para os clientes conectados diretamente a ele e assim
sucessivamente, análogo a ilustração da
Figura~\ref{fig:bucket-brigade-principle-1}. No caso do GMTP, é como se cada
roteador fosse responsável por apagar os focos de incêndio próximos a ele, ou
melhor, atender a demanda dos clientes diretamente conectados a ele, ao passo
que ajuda os outros a fazer o mesmo.

\vspace{0.2cm}

\begin{figure}[ht]
\begin{center}
\includegraphics[natwidth=706,natheight=152,scale=.71]{imgs/bucket-brigade-principle-1.png}
\end{center}
\vspace{-0.8cm}
\caption{Analogia do Princípio da Cooperação de Brigadas utilizado no \mudccps
para distribuição de conteúdos multimídia ao vivo.}
\label{fig:bucket-brigade-principle-1}
\end{figure}

Na Figura~\ref{fig:cenario-global}, observa-se o cenário global de atuação do
protocolo \mudccp, onde ilustram-se os nós \textit{Clientes GMTP} interessados
em obter o conteúdo de um determinado evento ao vivo. Neste caso,
observa-se também um \textit{Servidor GMTP}, que está conectado a uma rede CDN e
atua como fonte geradora de dados. Na prática, os nós \textit{Clientes GMTP} são
aplicações de rede capazes de iniciar uma sessão GMTP, que transmitem, recebem
e reproduzem dados multimídia de um determinado evento. Os nós \textit{Clientes
GMTP} estão conectados a um nó \textit{Repassador GMTP}, que é executado em um
roteador de rede e, junto com outros nós \textit{Repassadores GMTP},
efetivamente constituem a rede de sobreposição P2P. Os \textit{Repassadores
GMTP} também podem se conecta a um ou mais \textit{Servidores GMTP}.
Os \textit{Servidores GMTP} são as fontes de conteúdos multimídia, obtidos
através de três formas: i) diretamente a partir de uma unidade geradora
de conteúdo (filmadora e/ou microfone); ii) a partir de um \textit{Cliente
GMTP}; e/ou iii) a partir de outro \textit{Servidor GMTP} (troca de dados entre
os servidores da CDN). Os \textit{Servidores GMTP} recebem sinalizações de
controle contendo requisições dos nós \textit{Repassadores GMTP}, que ao
receberem uma resposta correspondente a sua requisição, atendem a demanda de um
ou mais nós \textit{Clientes GMTP}.

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=.65]{imgs/cenario-global.pdf}
\end{center}
\vspace{-1cm}
\caption{Cenário global de atuação do \mudccp.}
\label{fig:cenario-global}
\end{figure}

Quando um nó \textit{Cliente GMTP} deseja reproduzir um determinado evento,
este envia uma requisição destinada ao nó \textit{Servidor GMTP} que está
transmitindo o conteúdo de interesse, como atualmente acontece em qualquer
conexão na Internet. A diferença é que um pedido de conexão é interceptado por
algum nó \textit{Repassador GMTP} durante o trajeto do pedido de conexão até o
nó \textit{Servidor GMTP}, que então determina os melhores parceiros para
atendê-la. Em geral, isto ocorre já no roteador de borda do \textit{Cliente
GMTP}, que funciona como nó \textit{Repassador GMTP} de origem. Caso o nó
\textit{Repassador GMTP} não encontre nenhum nó parceiro capaz repassar a mídia
de interesse, este encaminha tal requisição ao nó \textit{Servidor GMTP} que
transmite a mídia correspondente. Em todo caso, sempre o nó \textit{Repassador
GMTP} de origem assumirá o controle da requisição do \textit{Cliente GMTP},
habilitando-se como candidato a parceiro para outros nós \textit{Repassadores
GMTP}, quando motivados por requisições originadas pelos seus \textit{Clientes
GMTP}.

O posicionamento dos nós \textit{Repassadores GMTP} e suas habilidades permitem
a redução do número de fluxos de dados correspondente a um mesmo evento. Além
disso, permite-se uma maior escalabilidade do número de nós \textit{Clientes
GMTP} interessado em receber um mesmo fluxo de dados. Por este mesmo motivo, o
protocolo GMTP é flexível para permitir que um nó \textit{Repassador GMTP} atue
somente encaminhando conteúdos multimídias entre duas ou mais redes
distintas, mesmo que este não esteja conectado a nenhum nó \textit{Cliente
GMTP} interessado por tal conteúdo. Desta forma, maximiza-se o uso de canais de
transmissão ociosos, em particular das redes residenciais, as quais seus
usuários muitas vezes estão ausentes e portanto sem fazer uso dos recursos
disponíveis, não necessitando, inclusive, manter um determinado computador da
sua rede interna ativo (ligado), como é obrigatório em todas as outras soluções
similares e baseadas em arquitetura P2P.

Pelo princípio da cooperação de brigadas empregado no GMTP, as requisições
de conexão podem ser originados não apenas por nós \textit{Clientes GMTP} para
seu respectivo nó \textit{Repassador GMTP}, mas também as requisições podem
ocorrer entre nós \textit{Repassadores GMTP} que, motivados pelos interesses
dos seus nós \textit{Clientes GMTP}, podem formar parcerias entre si. Isto
significa que um nó \textit{Repassador GMTP} pode agir como se fosse um nó
\textit{Servidor GMTP}, respondendo às requisições originadas por seus nós
\textit{Clientes GMTP} ou de outros nós \textit{Repassadores GMTP}, como se a
requisição estivesse alcançado o \textit{Servidor GMTP} que oficialmente
transmite o conteúdo, o que ocorre de forma transparente para a aplicação.

Na Figura~\ref{fig:cenario-global-detailed}, observam-se detalhes do cenário
supracitado, introduzindo-se o conceito de um grupo especial de nós chamados de
nós \textit{Relatores GMTP}. Estes nós são responsáveis por enviar relatórios
periódicos sobre o estado da transmissão ao seu nó \textit{Repassador GMTP}, que
os utiliza para regular a taxa de transmissão de um ou mais fluxos de dados,
impedindo-se que a rede entre em colapso de congestionamento.

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=.85]{imgs/cenario-global-detailed.pdf}
\end{center}
\vspace{-1cm}
\caption[Rede de sobreposição construída pelo \mudccp]{Rede de sobreposição
construída dinamicamente pelo \mudccps com
a presença de nós repassadores e relatores.}
\label{fig:cenario-global-detailed}
\end{figure}

\subsection{Terminologias e Convenções}

Nesta seção, apresentam-se algumas definições, terminologias e convenções
utilizadas no restante deste documento, de acordo com a
Figura~\ref{fig:protocolo-tipos-nos}.

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=.6]{imgs/protocolo-tipos-nos.pdf}
\end{center}
\vspace{-1cm}
\caption{Tipos de Nós e modos de conexões do GMTP.}
\label{fig:protocolo-tipos-nos}
\end{figure}

\subsubsection{Tipos de Nós:}
\label{subsec:tiposnos}

\begin{itemize}

  \item \textbf{Nó GMTP ou Processador GMTP:} qualquer processador de rede que
implementa o protocolo GMTP. É um sistema computacional que implementa parte ou
todo do protocolo GMTP, sendo capaz de interpretar os cabeçalhos dos pacotes
definidos pelo GMTP e realizar ações pré-definidas. Não há restrições de qual
tipo de processador de rede pode implementar qual(is) parte(s) do GMTP.

  \item \textbf{Cliente GMTP:} é um \textit{nó GMTP} capaz de reproduzir e
gerar conteúdos multimídia ao vivo. Em geral, um \textit{Cliente GMTP} é um
sistema final que executa um processo a nível de sistema operacional,
representando uma aplicação manipulada pelo usuário final. A maioria dos
\textit{Clientes GMTP} funciona apenas de forma passiva, recebendo o fluxo de
dados de um conteúdo multimídia e entregando para um processo em execução,
contribuindo na execução do algoritmo de controle de congestionamento.

  \item \textbf{Servidor GMTP:} é um \textit{nó GMTP} capaz de capturar um
evento ao vivo e gerar conteúdos digitais de áudio e vídeo ou ainda, receber de
um \textit{Cliente GMTP} tais conteúdos. Em geral, um \textit{Servidor GMTP} é
um sistema final que participa de uma rede CDN.

  \item \textbf{Repassador GMTP:} é um \textit{Nó GMTP} com habilidades de
repassar os fluxos de dados originados de um ou mais \textit{Servidores GMTP}
ou de um outro nó \textit{Repassador GMTP}.

  \item \textbf{Relator GMTP:} é um \textit{Cliente GMTP} com habilidades de
enviar relatórios periódicos ao repassador sobre o estado da transmissão.

\end{itemize}

\subsubsection{Modos de Transmissão:}
\label{subsec:tiposconexao}

\begin{itemize}

  \item \textbf{\textit{Unicast}:} toda comunicação que ocorre entre dois nós
\textit{Repassadores GMTP}, com a interpretação do conceito definido por
\textit{unicast} em sua forma tradicional no contexto de redes de
computadores.

  \item \textbf{\textit{Multi-unicast}:} é um conjunto formado por dois ou mais
canais de transmissão \textit{unicast}.

\item \textbf{\textit{Multicast}:} toda comunicação que ocorre entre um nó
\textit{Repassador GMTP} e seus respectivos \textit{Clientes GMTP}, com a
interpretação do conceito definido por \textit{multicast} em sua forma
tradicional no contexto de redes de computadores.

\end{itemize}

O modo \textit{multicast} sempre é utilizado para a transmissão dos datagramas
correspondentes ao fluxo de dados multimídia, porém quando este modo não é
suportado pela rede, executa-se o modo \textit{multi-unicast} do protocolo. É
mandatório que o modo \textit{multicast} seja utilizado para transmissões entre
um nó \textit{Repassador GMTP} e seus \textit{Clientes GMTP} diretos. O modo
\textit{unicast} é utilizado para que \textit{Clientes GMTP} estabeleçam uma
conexão com um \textit{Servidor GMTP} ou um \textit{Repassador GMTP} e passe a
distribuir o conteúdo de dados multimídia em sua rede local.

Deste ponto em diante, os termos \textit{Nó GMTP}, \textit{Cliente GMTP},
\textit{Servidor GMTP}, \textit{Repassador GMTP} e \textit{Relator GMTP}
serão utilizados em sua forma simplificada, ou seja, \textit{nó},
\textit{cliente}, \textit{servidor}, \textit{repassador} e \textit{relator},
respectivamente. Além disso, estes termos não serão mais formatados em itálico,
bem como os termos \textit{socket}, \textit{unicast}, \textit{multi-unicast} e
\textit{multicast}. Ademais, quando o termo \textit{transmissão} ou
\textit{transmissão de um evento} for mencionado, denotar-se-á a transmissão de
um fluxo de datagramas IP correspondente a um evento ao vivo, utilizando-se o
protocolo GMTP.

Embora alguns autores considerem os termos \aspas{repasse} e \aspas{roteamento}
como conceitos distintos, neste trabalho ambos os termos são considerados
sinônimos e devem ser interpretados como a capacidade que um nó \mudccps tem de
receber dados em uma interface de rede de entrada e encaminhar estes dados
através de uma interface de rede de saída, permitindo-se que uma mesma interface
de rede seja utilizada como entrada e saída ao mesmo tempo.

As palavras \aspas{deve}, \aspas{não deve}, \aspas{requerido}, \aspas{pode},
\aspas{não pode}, \aspas{recomendado} e \aspas{opcional}, incluindo suas
variações morfológicas, devem ser interpretadas como descrito na RFC
2119~\cite{RFC2119}, em inglês.

\subsection{Arquitetura}

Na Figura~\ref{fig:arq_geral_gmtp}, ilustra-se a arquitetura geral do GMTP.

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=.8]{imgs/protocolo-arquitetura.pdf}
\end{center}
\vspace{-1cm}
\caption{Arquitetura do Protocolo \mudccp.}
\label{fig:arq_geral_gmtp}
\end{figure}

\subsection{GMTP Intra e GMTP Inter}
\label{subsec:gmtp-intra-inter}

De acordo com a arquitetura apresentada na seção anterior, define-se:

\begin{itemize}

 \item \textbf{GMTP Intra:} parte do protocolo GMTP executada na camada de
transporte da pilha de protocolos TCP/IP, corresponde ao módulo interno de uma
rede, composta por nós clientes e relatores, disponibilizado no sistema
operacional e utilizado pela aplicação através de uma API de socket GMTP. Um
socket GMTP é a representação de uma instância do protocolo GMTP em execução,
sendo responsável por gerenciar todas as atividades de comunicação da aplicação
correspondente ao meio externo (outros processos GMTP). No contexto de uma
conexão, o GMTP Intra mantém diversas variáveis de estado que representam uma
instância e executa algoritmos para gerenciamento de conexão (estabelecimento e
desconexão) e eleição de nós parceiros, determinação do formato e preenchimento
dos parâmetros que definem uma determinada mídia digital, permitindo que a
aplicação defina os valores de tais parâmetros e ou obtenham acesso aos valores
dos mesmos, controle de congestionamento e multiplexação e demultiplexação de
datagramas IP. O GMTP não faz verificação de conteúdo por mecanismo de soma de
verificação.

 \item \textbf{GMTP Inter:} parte do protocolo GMTP executada na camada de
rede da pilha de protocolos TCP/IP e corresponde ao módulo externo de uma rede,
composta por vários nós repassadores que cooperam entre si. É executado por um
roteador de rede e aceita conexões oriundas de um nó cliente ou de um nó
repassador. No contexto de uma conexão, o GMTP Inter mantém variáveis de estado
relacionadas às funções de sua responsabilidade, tais como estabelecimento de
conexão com nós servidores ou repassadores, seleção de nós repassadores
parceiros, eleição de nós relatores, controle de congestionamento assistido pela
rede e controle de compartilhamento de fluxos multimídia.

No GMTP Inter, permite-se a configuração de parâmetros iniciais de configuração
da rede de favores e da integração com servidores de uma ou mais CDN, como
ilustrado na Figura~\ref{fig:tela-gmtp-inter}. Nesse caso, o usuário
administrador de um nó repassador pode definir os seguintes parâmetros:

\begin{itemize}

  \item registro de participação em uma ou mais redes redes CDN;

  \item largura de banda (\textit{download} e \textit{upload}) que deseja
compartilhar;

  \item o período (faixa de dias e horários) que o roteador funcionará como nó
repassador;

  \item quantidade máxima de parcerias que podem ser realizadas;

  \item quantidade máxima de fluxos de dados que podem ser compartilhados;

  \item parâmetros avançados relacionados aos algoritmos de controle de
congestionamento;

  \item download automático ou não do certificado digital de um nó servidor; e

  \item realização de cache ou não dos certificados digitais obtidos.

\end{itemize}


\begin{figure}[ht]
\begin{center}
\includegraphics[natwidth=664,natheight=340,scale=.5]{imgs/tela-gmtp-inter.png}
\end{center}
\vspace{-1cm}
\caption{Tela da ferramenta de administração do OpenWRT~\cite{REF} com suporte
ao GMTP. Nessa tela, permitir que o administrador do roteador configure
registros de participação em uma ou mais redes CDN.}
\label{fig:tela-gmtp-inter}
\end{figure}

\end{itemize}

\subsection{Principais funções}

\begin{itemize}

  \item Registro de participação de um nó repassador em um nó servidor. Isto
permite o suporte à pré-seleção de nós parceiros filtrados por métricas que
influenciam na qualidade de experiência do usuário ao assistir um
evento ao vivo, como atraso fim-a-fim.

  \item Acesso a uma transmissão através de um processo de conexão em três-vias
(\textit{3WHS}), com a requisição de conexão transmitida ao servidor e podendo
ser interceptada por um nó repassador em seu trajeto ao servidor, com suporte
automático de detecção e uso dos modos de transmissão suportados pelo nó
repassador.

  \item Descoberta de nós parceiros entre redes distintas e negociação de
parcerias, com suporte a formação de parcerias baseadas em métricas que
influenciam na qualidade de experiência do usuário.

  \item Envio e recebimento de fluxos de dados compartilhados entre nós
da mesma rede através de multicast e uso de fluxos unicast entre redes
distintas, porém sem a relação de uma conexão por cliente e assim evitando o
fenômeno da tragédia dos bens comuns, discutido na Seção~\ref{sec:problematica}.

  \item Suporte a algoritmos de controle de congestionamento assistidos pela
rede e de fluxos multicast. Troca de relatórios periódicos entre os nós
repassadores sobre a transmissão.

  \item Eleição de nós relatores com suporte a tolerância a desconexões de nós,
com notificação e reeleição de novos nós.

  \item Possibilidade de permitir que os nós clientes verifiquem a autenticidade
das partes de uma mídia, por meio do uso de certificado digital determinado no
nó servidor para impedir ataques de poluição.

\end{itemize}

\subsection{Canais de Comunicação}
\label{subsec:canaiscommudccp}

No GMTP, utilizam-se três canais de comunicação para executar suas
funcionalidades, o canal de controle, o de transmissão unicast e o de
transmissão multicast. A seguir, definem-se tais conceitos.

% (Figura~\ref{fig:canais-comunicacao}).
%
% \begin{figure}[ht]
% \begin{center}
% \includegraphics[scale=.86]{imgs/canais-comunicacao.pdf}
% \end{center}
% \vspace{-1cm}
% \caption{Canais de Comunicação do \mudccp.}
% \label{fig:canais-comunicacao}
% \end{figure}

\subsubsection{Canal de Controle}

Quando um nó repassador iniciar uma instância do protocolo \mudccp, este deve
criar um socket multicast no endereço IP 238.255.255.250 e na porta $1900$, em
toda interface de rede local, ou seja, nas interfaces por onde se fornece
acesso aos nós clientes. Através desse socket, um nó GMTP é capaz de enviar e
receber pacotes de controle utilizados para negociar as funções de transmissão
de um determinado fluxo de dados de mídia ao vivo. Por exemplo, utiliza-se este
canal para permitir que um nó cliente envie pedidos de conexão e descubrir quais
fluxos de dados já estão sendo recebidos e qual canal multicast cada um deles
está disponível.

A decisão do uso do endereço IP multicast \textit{238.255.255.250} foi baseada
na RFCs 2365~\cite{RFC2365}, que define o escopo administrativo do uso dos
endereços multicast entre 239.0.0.0 e 239.255.255.255. O endereço
\textit{238.255.255.250} é definido no escopo de uso global e sua alocação deve
ser confirmada pela \textit{Internet Assigned Numbers Authority} --
IANA\footnote{IANA: http://www.iana.org/} antes do uso massivo do GMTP na
Internet.

\subsubsection{Canal de Transmissão Unicast}

O canal de controle e recepção unicast é criado por todos os nós repassadores ao
iniciar uma instância do protocolo GMTP. Na prática, trata-se de um socket que
os nós repassadores formam as devidas parcerias para transmitir os fluxos de
dados uns para os outros e posteriormente serem disseminados em
modo multicast pelos respectivos nós repassadores aos seus clientes.

Do ponto de vista de roteamento, todo nó repassador deve avaliar os datagramas
GMTP e realizar as ações apropriadas, definidas nas próximas seções deste
capítulo. Por exemplo, no processo de estabelecimento de conexão, a ser
detalhado na Seção~\ref{subsec:conexao-requisicao}, ao processar um pacote GMTP
transmitido por um nó cliente, o nó repassador deve verificar se o pacote é do
tipo \pac{GMTP-Request} e, em caso positivo, deve-se retornar um pacote do tipo
\pac{GMTP-Response} ao nó cliente, se o fluxo de dados de interesse do nó
cliente especificado no pacote \pac{GMTP-Request} já estiver sendo recebido por
tal nó repassador.



% \subsubsection{Canal de Controle Unicast}
%
% Tal canal de controle é criado apenas entre os nós repassadores e relatores
% para troca de informações implementar as funcionalidades do protocolo, tais como
% procedimentos de estabelecimento de conexão, descoberta de nós e notificações de
% desconexões, eleição de nós relatores e envio e recebimento de relatórios para
% controle de congestionamento.

\subsubsection{Canal de Repasse Multicast}

Além do canal de controle, define-se no protocolo \mudccps um canal de repasse
utilizado por um nó repassador para encaminhar datagramas vindos de um servidor
ou de outro repassador para a rede local. Esse canal de repasse, na prática, é
um socket multicast criado pelo nó repassador para transmitir os datagramas para
todos os seus clientes com interesse em reproduzir o mesmo fluxo de dados de um
evento ao vivo.

O \textit{socket de repasse multicast} deve ser criado quando um nó repassador
passa a obter um determinado fluxo de dados correspondente a um determinado
evento de interesse de pelo menos um dos seus clientes. Na prática, quando
isto acontece, o repassador deve criar um socket multicast em um
endereço IP e número de porta escolhida aleatoriamente para repassar os dados
vindos do servidor ou de outro repassador para dentro de sua rede. A
faixa de endereços IP multicast que o nó repassador deve utilizar para criar seu
socket de repasse para um determinado fluxo de dados é a de escopo local
239.192.0.0/14, definida na RFC 2365~\cite{RFC2365}. Como é uma faixa de
endereços IP multicast de domínio local, não se faz necessário registrar o uso
desses endereços. Isto significa que para todo fluxo de dados de um evento ao
vivo, deve-se alocar um endereço IP e uma porta. No caso do esquema de
endereçamento IPv4, com isto, será possível definir a transmissão de
exatamente de 17.179.607.040 (dezessete bilhões, cento e setenta e nove
milhões, seiscentos e sete mil e quarenta) diferentes fluxos de dados em uma
rede local, o que é mais do que suficiente e escalável por vários séculos.

% \subsubsection{Canal de Recepção de Dados:}
%
% O canal de recepção de dados é um socket multicast criado por um
% cliente para receber um fluxo de dados transmitindo por um nó repassador em
% algum endereço IP da faixa 239.192.0.0/14. Alternativamente, um canal de
% recepção de dados será um socket unicast quando existir apenas um
% cliente em uma rede interessado por um fluxo de dados, utilizando-se o
% endereço da sua própria interface de rede local. O endereço IP e o
% número de porta que o cliente deve se conectar é determinado pelo nó repassador
% no momento da conexão.

% \subsection{Diagrama de Estados do GMTP}
%
% TBD

% \section{Fluxograma de Estados do \mudccp}
%
% Após o processo de estabelecimento de conexão do \mudccp, o protocolo entra no
% estado de transmissão de dados, se o nó for um servidor ou um relay, ao passo
% que o protocolo entra no estado de recepção de dados, se o nó for um cliente.
%
% Um servidor ou um relay começa a transmitir os dados após o processo de
% estabelecimento de conexão e até quando o fluxo de dados no servidor se
% encerrar ou quando o relay não desejar mais receber o fluxo de dados.

\subsection{Tipos de Pacotes}
\label{subsec:tipodepacotesmudccp}

Toda comunicação entre dois ou mais nós GMTP ocorre através da troca de
datagramas IP, que carregam sinalizações de controle e/ou dados da aplicação.
Para isso, faz-se necessário registrar o uso de um código para o campo
\textit{Protocolo} do cabeçalho de um datagrama IP à IANA. Com a
padronização do protocolo \mudccps e a publicação da sua RFC, provavelmente
será utilizado o código 100, como já está definido no documento \textit{Protocol
Numbers}\footnote{O código 100 foi utilizado no passado por um outro protocolo
de mesma sigla, mas foi descontinuado e se tornou obsoleto. O uso de tal
identificador está sendo negociado junto a IETF e a IANA
\murl{http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml}}
da IANA.

No cabeçalho dos pacotes \mudccp, existe um campo denominado \emph{tipo do
pacote} com tamanho de \ut{4}{bits}, que são descritos a seguir. Este campo
determina qual tipo de informação está contida em um determinado pacote \mudccps
e, ao processá-lo, o nó \mudccps deve executar uma determinada ação.

\begin{enumerate}
\setcounter{enumi}{-1}

  \item \textit{GMTP-Request:} Cliente envia requisição para obter um fluxo
de dados multimídia dado um nome do fluxo de interesse;

  \item \textit{GMTP-RequestNotify:} Repassador notifica um cliente que um
fluxo de dados está prestes a ser transmitido ou já está sendo transmitido em um
determinado canal de repasse multicast. Campo de dados contém a descrição da
mídia a ser reproduzida;

  \item \textit{GMTP-Response:} Repassador confirma o estabelecimento de uma
parceria com outro nó repassador, dado um determinado fluxo de dados;

  \item \textit{GMTP-Register:} Repassador registra participação no servidor
para funcionar como distribuidor de um ou mais fluxos de dados;

  \item \textit{GMTP-Register-Reply:} Servidor responde ao repassador sobre seu
pedido de registro de participação;

  \item \textit{GMTP-RelayQuery:} Repassador pode solicitar ao servidor uma
lista de possíveis nós repassadores parceiros;

  \item \textit{GMTP-Data:} Qualquer nó utiliza para transmitir dados da
aplicação;

  \item \textit{GMTP-Ack:} Qualquer nó utiliza para confirmar a recepção de
um determinado pacote, seja pacotes previamente contendo dados ou não;

  \item \textit{GMTP-DataAck:} Combinação dos pacotes GMTP-Data e GMTP-Ack
(\textit{PiggyBack});

  \item \textit{GMTP-MediaDesc:} Servidor transmite esse pacote para
descrever informações sobre a mídia sendo transmitida em uma
determinada transmissão;

  \item \pac{GMTP-DataPull-Request:} Repassador envia um pedido para obter o
mapa de buffer atual de um outro repassador parceiros;

  \item \pac{GMTP-DataPull-Response:} Resposta ao pedido para obtenção de um
mapa de buffer;

  \item \pac{GMTP-Elect-Request:} Repassador envia para um cliente o pedido
para tal cliente atuar como nó relator;

  \item \pac{GMTP-Elect-Response:} Cliente envia para o repassador uma
confirmação de que pode atuar como relator;

  \item \pac{Reservado:} Reservado para uso futuro e ignorado pelos nós que
o processa;

  \item \pac{Reservado:} Reservado para uso futuro e ignorado pelos nós que
o processa;

  \item \pac{GMTP-Close:} Servidor, repassador ou cliente solicita o término
de uma conexão;

  \item \pac{GMTP-Reset:} Determina, incondicionalmente, a finalização de
uma conexão.

\end{enumerate}

Nas próximas seções, descreve-se todas as possíveis ações do GMTP e os tipos de
pacotes envolvidos na comunicação entre os seus nós. No
Apêndice~\ref{app:mudccp-tecnica}, apresenta-se detalhes acerca do uso dos
tipos de pacotes do GMTP, sendo seu teor bastante técnico e portanto dedicado
aos leitores interessados em sua implementação.

% \begin{table}[ht]
%         \caption{Tipos de Pacotes do protocolo \mudccp.}
%         \label{tab:tipospacotemudccp}
%     \begin{center}
% 	\vspace{-0.8cm}
%         \begin{tabular}{|p{1.0cm}|p{1.5cm}|p{1.5cm}|}
%             \hline
%
% \multicolumn{1}{|>{\columncolor[rgb]{0.05,0.2,0.43}}c}{\textcolor{white}{\textbf
% {\#}}} &
% \multicolumn{1}{|>{\columncolor[rgb]{0.05,0.2,0.43}}c|}{\textcolor{white}{
% \textbf{Tipo}}} &
% \multicolumn{1}{>{\columncolor[rgb]{0.05,0.2,0.43}}c|}{\textcolor{white}{\textbf
% {Descrição}}}
% 	    \\
% 	    \hline
% 	    \hline
%             \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c}{\textbf{0}}
% & \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c|}{Request} &
% \multicolumn{1}{>{\columncolor[rgb]{0.66,0.7,0.759}}l|}{Requisição de um fluxo
% de dados multimídia a partir do seu nome}
% 	    \\
%
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c}{\textbf{1}} &
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c|}{RequestNotify} &
% \multicolumn{1}{>{\columncolor[rgb]{0.913,0.929,0.957}}l|}{Notificar um nó
% cliente que um fluxo de dados está pronto para ser transmitido.}
% 	    \\
%
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c}{\textbf{1}} &
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c|}{Response} &
% \multicolumn{1}{>{\columncolor[rgb]{0.913,0.929,0.957}}l|}{Resposta ao pedido de
% estabelecimento de conexão multicast}
% 	    \\
%             \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c}{\textbf{2}}
% & \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c|}{Data} &
% \multicolumn{1}{>{\columncolor[rgb]{0.66,0.7,0.759}}l|}{Contém dados da
% aplicação}
% 	    \\
%
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c}{\textbf{3}} &
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c|}{Ack} &
% \multicolumn{1}{>{\columncolor[rgb]{0.913,0.929,0.957}}l|}{Confirmação de
% recebimento de pacote}
% 	    \\
%
%             \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c}{\textbf{4}}
% & \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c|}{DataAck} &
% \multicolumn{1}{>{\columncolor[rgb]{0.66,0.7,0.759}}l|}{Dados da aplicação e
% confirmação de recepção}
% 	    \\
%
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c}{\textbf{5}} &
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c|}{Elect} &
% \multicolumn{1}{>{\columncolor[rgb]{0.913,0.929,0.957}}l|}{Inicia o processo de
% eleição de um nó em relay ou reporter}
% 	    \\
%
% \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c}{\textbf{6}}
% & \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c|}{ElectReply} &
% \multicolumn{1}{>{\columncolor[rgb]{0.66,0.7,0.759}}l|}{Sinaliza o interesse de
% um nó em se transformar em relay ou reporter}
% 	    \\
%
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c}{\textbf{7}} &
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c|}{ElectAck} &
% \multicolumn{1}{>{\columncolor[rgb]{0.913,0.929,0.957}}l|}{Confirmação do nó
% eleito para relay ou reporter}
% 	    \\
%
% \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c}{\textbf{8}}
% & \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c|}{RelayQuery} &
% \multicolumn{1}{>{\columncolor[rgb]{0.66,0.7,0.759}}l|}{Transmitido por um nó
% para consultar a lista de relays}
% 	    \\
%
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c}{\textbf{9}} &
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c|}{RelayReply} &
% \multicolumn{1}{>{\columncolor[rgb]{0.913,0.929,0.957}}l|}{Resposta ao pedido
% de consulta da lista de relays}
% 	    \\
%
% \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c}{\textbf{10}}
% & \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c|}{AdvConn} &
% \multicolumn{1}{>{\columncolor[rgb]{0.66,0.7,0.759}}l|}{Utilizado por um nó
% relay ou reporter para anunciar que está ativo na rede}
% 	    \\
%
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c}{\textbf{11}} &
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c|}{Reservado} &
% \multicolumn{1}{>{\columncolor[rgb]{0.913,0.929,0.957}}l|}{Uso futuro e ignorado
% pelo receptor}
% 	    \\
%
% \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c}{\textbf{12}} &
% \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c|}{Reservado} &
% \multicolumn{1}{>{\columncolor[rgb]{0.66,0.7,0.759}}l|}{Uso futuro e ignorado
% pelo receptor}
% 	    \\
%
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c}{\textbf{13}} &
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c|}{CloseReq} &
% \multicolumn{1}{>{\columncolor[rgb]{0.913,0.929,0.957}}l|}{Servidor ou
% Relay solicita término de conexão sem TIMEWAIT}
% 	    \\
%
%             \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c}{\textbf{14}}
% & \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c|}{Close} &
% \multicolumn{1}{>{\columncolor[rgb]{0.66,0.7,0.759}}l|}{Servidor/Cliente/Relay
% solicita término da conexão}
% 	    \\
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c}{\textbf{15}} &
% \multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c|}{Reset} &
% \multicolumn{1}{>{\columncolor[rgb]{0.913,0.929,0.957}}l|}{Determina,
% incondicionalmente, o final da conexão}
% 	    \\
%             \hline
%         \end{tabular}
%     \end{center}
% % 	\scriptsize
% % 	$^1$ O tipo de pacote \textbf{\mudccp-Reset} é utilizado com este
% % propósito, porém utiliza-se também para outros motivos: para sinalizar número
% % de
% % porta incorreto; comportamento inapropriado de opções; desconexão prevista de
% % um
% % \mdrel\space etc.
% \end{table}

% \normalsize


% ver: http://peerstreamer.org

% Anotações após defesa:
%  - Ler o survey: http://www.aicit.org/jcit/ppl/%20JCIT_MAY_30.pdf
%  - Simuladores mais robustos: SimGrid [23], OPSS [26, 27], ChunkSim [29], 3LS
% [30], OPNET [30] (não sei se vai ser bom!)
%  -

\section{Definições, Relações e Restrições do GMTP}
\label{sec:defsrests}

Nesta seção, descrevem-se as definições, relações e restrições do protocolo
GMTP. Para isto, faz-se uso de fundamentos de algebra booleana, lógica
proposicional, teoria de conjuntos e teoria dos
grafos~\cite{Jonathan2003,Seroul2000,Courant1996,Devlin1979}.

\newcommand{\transmission}{\Large$\tau$\normalsize\normalfont}
\newcommand{\transmissions}{\transmission\space}
\newcommand{\event}{\Large$\varepsilon$\normalsize\normalfont}
\newcommand{\events}{\event\space}

\newcommand{\setservrepass}{$Z$}
\newcommand{\setservrepasss}{\setservrepass\space}

\newcommand{\settranc}{T}
\newcommand{\transconst}{t}
\newcommand{\settrans}{$\settranc$}
\newcommand{\settranss}{\settrans\space}
\newcommand{\transi}{u}
\newcommand{\transu}[1]{$\transconst_{#1}$}
\newcommand{\transssu}[1]{\transu{#1}\space}
\newcommand{\trans}{\transu{\transi}}
\newcommand{\transs}{\trans\space}

\newcommand{\setrepassc}{R}
\newcommand{\repassconst}{r}
\newcommand{\setrepass}{$\setrepassc$}
\newcommand{\setrepasss}{\setrepass\space}
\newcommand{\repassi}{d}
\newcommand{\repassu}[1]{$\repassconst_{#1}$}
\newcommand{\repasssu}[1]{\repassu{#1}\space}
\newcommand{\repass}{\repassu{\repassi}}
\newcommand{\repasss}{\repass\space}

\newcommand{\setclic}{C}
\newcommand{\cliconst}{c}
\newcommand{\setcli}{$\setclic$}
\newcommand{\setclis}{\setcli\space}
\newcommand{\subsetclii}{i}
\newcommand{\subsetcli}{\setcli$_{\subsetclii}$}
\newcommand{\subsetclis}{\subsetcli\space}
\newcommand{\cliu}[1]{$\cliconst_{#1}$}
\newcommand{\clisu}[1]{\cliu{#1}\space}
\newcommand{\clii}{f}
\newcommand{\cli}{\cliu{\clii}}
\newcommand{\clis}{\cli\space}

\newcommand{\setservc}{S}
\newcommand{\servconst}{s}
\newcommand{\setserv}{$\setservc$}
\newcommand{\setservs}{\setserv\space}
\newcommand{\servi}{a}
\newcommand{\servu}[1]{$\servconst_{#1}$}
\newcommand{\servsu}[1]{\servu{#1}\space}
\newcommand{\serv}{\servu{\servi}}
\newcommand{\servs}{\serv\space}

\newcommand{\setrelc}{L}
\newcommand{\relconst}{l}
\newcommand{\setrel}{$\setrelc$}
\newcommand{\setrels}{\setrel\space}
\newcommand{\subsetrel}{\setrel$_{\theta}$}
\newcommand{\subsetrels}{\setrel$_{\theta}$\space}
\newcommand{\reli}{w}
\newcommand{\rel}{$\relconst_{\reli}$}
\newcommand{\rels}{$\relconst_{\reli}$\space}
\newcommand{\relu}[1]{$\relconst_{#1}$}
\newcommand{\relsu}[1]{$\relconst_{#1}$\space}

\newcommand{\semifullsymb}{\circ}
\newcommand{\fullsymb}{\bullet}
\newcommand{\setwayc}{W}
\newcommand{\setway}{$\setwayc$}
\newcommand{\setways}{\setway\space}
\newcommand{\setwayii}{v}
\newcommand{\setwayiu}[1]{$\setwayc_{#1}$}
\newcommand{\setwayius}[1]{\setwayiu{#1}\space}
\newcommand{\setwayi}{\setwayiu{\setwayii}}
\newcommand{\setwayis}{\setwayius{\setwayii}}

\newcommand{\setwayifu}[1]{$\setwayc^{\fullsymb}_{#1}$}
\newcommand{\setwayifus}[1]{\setwayifu{#1}\space}
\newcommand{\setwayif}{\setwayifu{\setwayii}}
\newcommand{\setwayifs}{\setwayifus{\setwayii}}

\newcommand{\setwayisfu}[1]{$\setwayc^{\semifullsymb}_{#1}$}
\newcommand{\setwayisfus}[1]{\setwayisfu{#1}\space}
\newcommand{\setwayisf}{\setwayisfu{\setwayii}}
\newcommand{\setwayisfs}{\setwayisfus{\setwayii}}

\newcommand{\setwayidu}[1]{$\setwayc^{\lhd}_{#1}$}
\newcommand{\setwayidus}[1]{\setwayidu{#1}\space}
\newcommand{\setwayid}{\setwayidu{\setwayii}}
\newcommand{\setwayids}{\setwayidus{\setwayii}}

\newcommand{\setwayidfu}[1]{$\setwayc^{\lhd\fullsymb}_{#1}$}
\newcommand{\setwayidfus}[1]{\setwayidfu{#1}\space}
\newcommand{\setwayidf}[1]{\setwayidfu{\setwayii}}
\newcommand{\setwayidfs}[1]{\setwayidfus{\setwayii}}

\newcommand{\setwayidsfu}[1]{$\setwayc^{\lhd\semifullsymb}_{#1}$}
\newcommand{\setwayidsfus}[1]{\setwayidsfu{#1}\space}
\newcommand{\setwayidsf}[1]{\setwayidsfu{\setwayii}}
\newcommand{\setwayidsfs}[1]{\setwayidsfus{\setwayii}}

\newcommand{\wayconst}{w}
\newcommand{\wayi}{m}
\newcommand{\wayu}[1]{$\wayconst_{#1}$}
\newcommand{\waysu}[1]{\wayu{#1}\space}
\newcommand{\way}{\wayu{\wayi}}
\newcommand{\ways}{\way\space}

\newcommand{\setpkc}{P}
\newcommand{\pkconst}{p}
\newcommand{\pkalli}{h}
\newcommand{\setpk}{$\setpkc$}
\newcommand{\setpks}{\setpk\space}
\newcommand{\setpkf}{$\setpkc^{\fullsymb}$}
\newcommand{\setpkfs}{\setpkf\space}
\newcommand{\setpkallc}{\mathbb{\setpkc}}
\newcommand{\setpkall}{$\setpkallc$}
\newcommand{\setpkalls}{\setpkall\space}
\newcommand{\subsetpkall}{\setpkall$_{\theta}$}
\newcommand{\subsetpkalls}{\subsetpkall\space}
\newcommand{\subpkf}{\Large$\rho$\normalsize}
\newcommand{\subpkfs}{\subpkf\space}
\newcommand{\subsetpk}{$\setpkc^\lhd$}
\newcommand{\subsetpks}{\subsetpk\space}
\newcommand{\subsetpkf}{$\setpkc^{\lhd\fullsymb}$}
\newcommand{\subsetpkfs}{\subsetpkf\space}
\newcommand{\pki}{x}
\newcommand{\pku}[1]{$\pkconst_{#1}$}
\newcommand{\pksu}[1]{\pku{#1}\space}
\newcommand{\pk}{\pku{\pki}}
\newcommand{\pks}{\pk\space}

\newcommand{\setnetrc}{B}
\newcommand{\setnetr}{$\setnetrc$}
\newcommand{\setnetrs}{\setnetr\space}
\newcommand{\netrconst}{b}
\newcommand{\netri}{e}
\newcommand{\netru}[1]{$\netrconst_{#1}$}
\newcommand{\netrsu}[1]{\netru{#1}\space}
\newcommand{\netr}{\netru{\netri}}
\newcommand{\netrs}{\netr\space}

\newcommand{\net}{$\eta$}
\newcommand{\nets}{\net\space}

\newcommand{\powerset}[1]{$2^{#1}$}
\newcommand{\powersets}[1]{\powerset\space}
\newcommand{\transmit}{$\varphi($\serv$,$ \setpk$)$}
\newcommand{\transmits}{\transmit\space}
\newcommand{\transmitr}{$\varphi($\repass$,$ \setpk$)$}
\newcommand{\transmitrs}{\transmitr\space}
\newcommand{\transmitru}[1]{$\varphi($\repassu{#1}$,$ \setpk$)$}
\newcommand{\transmitrus}[1]{\transmitru{#1}\space}
\newcommand{\transmitqu}[1]{$\varphi($#1$,$ \setpk$)$}
\newcommand{\transmitqus}[1]{\transmitqu{#1}\space}
\newcommand{\invert}[1]{$\sim$$($#1$)$}

\begin{enumerate}

  \item Seja o conjunto finito dos nós repassadores, definido por
\setrepasss $ = \{\repassconst_1, \repassconst_2, \repassconst_3,
\ldots, $ \repass$\}$, tal que $\repassi \in \mathbb{N}$.

  \item Seja o conjunto finito dos roteadores de uma rede de computadores,
definido por \setnetrs $ = \{\netrconst_1, \netrconst_2,
\netrconst_3, \ldots, $ \netr$\}$, tal que $\netri \in \mathbb{N}$. Existe uma
relação \setrepasss $\rightarrow$ \setnetrs que determina a sobreposição
dos nós repassadores \repasss $\in$ \setrepasss sob os roteadores em \setnetrs
(\textit{rede de sobreposição}).

  \item Seja o conjunto finito dos nós servidores, definido por \setservs $ =
\{\servconst_1, \servconst_2, \servconst_3, \ldots, $ \serv$\}$, tal que $\servi
\in \mathbb{N}$.

  \item Seja o conjunto finito dos nós clientes, definido por \setclis $ =
\{\cliconst_1, \cliconst_2, \cliconst_3, \ldots, $ \cli$\}$, tal que $\clii \in
\mathbb{N}$.

  \item Seja o conjunto \textit{totalmente ordenado (toset)} dos pacotes de
dados gerados pelos nós \servs $\in$ \setservs durante a transmissão de um
evento ao vivo \event, definido por $($\setpkall$,\prec) = \{\pkconst_1,
\pkconst_2, \pkconst_3, \ldots, $\pku{\pkalli}$\}$, onde $\pkalli \in
\mathbb{N}$. Note que o símbolo $\prec$ é utilizado para representar
precedência entre dois elementos diferentes.

  \item Seja um grafo determinado pelo conjunto de vértices \setservrepass, que
podem estar interligados entre si por um conjunto de diferentes arestas,
chamadas de caminhos \setway, por onde se transmite o fluxo de dados \setpk,
definido por $\eta = G($\setservrepass$,$ \setway$)$, tal que:

    \begin{enumerate}

      \item \setservrepasss $=$ \setservs $\cup$ \setrepass;

      \item Sejam as relações e restrições estabelecidas entre os diferentes
tipos de nós de uma transmissão de um evento ao vivo \event, definida por
\transmission $= \{$\setservrepass, \setpk, \subsetcli$\}$, tal que:

      \begin{enumerate}

	  \item Seja \setpk, o conjunto \textit{parcialmente ordenado
(\textit{poset})} dos pacotes de dados \pks transmitidos por um nó \servs ou
repassados por um nó \repass, também chamado de fluxo de pacotes de dados ou
apenas fluxo de dados, definido por $($\setpk$,\prec) =
\{\pkconst_{1},\pkconst_{2}, \pkconst_{3},
\ldots, $\pku{x}$\}$, tal que $x \in \mathbb{N}$. Trata-se de um \textit{poset}
porque o GMTP não garante entrega de \pk;

	  \item Seja \subsetcli, uma função que denota os nós \clis relacionados
a um nó \repass, de modo que nenhum nó \clis $\in$ \setclis pode estar
relacionado com dois ou mais nós, definida por \subsetclis $:$ \repasss
$\rightarrow$ \powerset{\setclic}, $\forall$\repass,\repassu{\repassi+1} $\in$
\setrepass, \subsetcli$($\repass$)$ $\cap$ \subsetcli$($\repassu{\repassi+1}$)$
= $\{\emptyset\}$;
	  \label{item:funcao-subsetcli}

% , de modo que:
%   \begin{itemize}
%     % se disser que P \subset P_{total} já é suficiente pra ser um P*?
%     \item Um fluxo de dados \setpks é dito \textit{fluxo completo},
% representado por \setpkf, se e somente se \setpks $\leftrightarrow$
% $\exists$\subsetpkalls (relação bijetora), tal que \subsetpkalls $\in$
% \powerset{\setpkallc} e \subsetpkalls $\neq \{\emptyset\}$. Ou seja, um
% \textit{fluxo completo} \setpkfs é um conjunto \textit{toset} e portanto
% não apresenta lacunas;
%
%     \item \subpkfs $: ($\pk$, $\setpk$) \rightarrow ($\subsetpk$, \prec) =
% \{$\pk, \pku{\pki+1}, \pku{\pki+2}, \pku{\pki+3}, $\ldots\}$, tal que
% \subsetpks $\subset$ \setpk, uma função \subpkf$($\pk$, $\setpk$)$ que define
% um sub-fluxo de pacotes de dados \setpks a partir de um determinado pacote
% \pks
% $\in$ \setpk. Neste caso, como \subsetpks $\subset$ \setpk, se \subsetpkfs
% $\rightarrow$ \setpkf.
%   \end{itemize}

	  \item Seja \setrel, o conjunto finito dos nós relatores, definido por
\setrels $= \{\relconst_1, \relconst_2, \ldots, $\rel$\}$. Como todo nó \clis
pode atuar como \rel, tem-se que $\exists$\subsetrels $\in$
\powerset{\setclic_\subsetclii(\repassconst_\repassi)}, tal que \rels $\in$
\subsetrel. Pelo item~\ref{item:funcao-subsetcli}, que determina que dois
nós \clis não podem estar relacionados a mais de um nó \repass, tem-se portanto
que \subsetrels $\subset$ \setrels e \subsetrels $\cup$
\subsetcli$($\repass$)$ $ = $ \subsetcli$($\repass$)$.

      \end{enumerate}

    \item \setway $=$ $\bigcup^{j}_{\setwayii=1}$ \setwayi, onde $j \in
\mathbb{N}$ e corresponde à quantidade de todos os possíveis caminhos \setwayi,
tal que um caminho é definido por um conjunto \textit{toset}
$($\setwayi,$\prec)$, que denota um dos possíveis caminhos por onde um fluxo de
dados \setpks pode ser transmitido, obrigatoriamente a partir de um nó servidor
\servs até um nó \repassu{1}, tal que:

      \begin{enumerate}

	  \item $($\setwayi$,\prec) = \{$\ways $\mid$
\serv$,\repassconst_{1},\repassconst_{2},\repassconst_3,
\ldots, $\repass$\}$, $\forall$\way$,$\waysu{\wayi+1}$\in$ \setwayis $:$
\way$ \prec$ \wayu{\wayi+1} e \setwayis $\neq \{\emptyset\}$ e
$\mid$\setwayi$\mid$ $>$ $1$;

	  \item Um caminho \setwayis é dito \textit{caminho semi-completo},
representado por \setwayisf, se e somente se \setwayis $\leftrightarrow$
$\exists$\setnetr$_{\theta}$ (bijetora), tal que \setnetr$_{\theta}$
$\in$ \powerset{\setnetrc} e \setnetr$_{\theta} \neq \{\emptyset\}$. Isto é,
todos os roteadores \netrs $\in$ \setnetrs são sobrepostos por um nó \repasss
$\in$ \setwayisf;

	  \item Um caminho \setwayis é dito \textit{caminho completo},
representado por \setwayif, se for \setwayisfs e se \setwayis $\subset$
\settrans, tal que \settranss $\subset$ \setservrepasss é o conjunto dos nós que
transmite os pacotes de dados \pks $\in$ \setpk, definido por \settranss $=
\{$\transs$\mid$ \transmitqus{\trans} $ = 1\}$, sendo $\transi \in
\mathbb{N}$ e $\varphi$ uma função booleana que determina se um nó \transs $\in$
\settranss transmite os pacotes \pks $\in$ \setpks para \clis $\in$
\subsetcli(\trans), ou seja:

	      \begin{enumerate}

		  \item $\varphi:$ (\trans, \setpk) $\rightarrow \{0, 1\},
\forall ($\trans, \setpk$) \in \{$\settrans$ \times \{$\setpk$\}\}$, onde 0 e 1
denotam, respectivamente, \textit{falso} e \textit{verdadeiro}.

	      \end{enumerate}

      \end{enumerate}

    \item Seja $\sim$, uma função reversa de um conjunto \textit{toset}, tal que
$\sim$ $: ($\setwayi$,\prec)$ $\rightarrow ($\setwayi$,\succ)$. Isto é, para um
conjunto $($\setwayi$, \prec) = \{$\ways $\mid$
\serv$,\repassconst_{1},\repassconst_{2},\ldots, $\repass$\}$, então
\invert{\setwayi} produzirá $($\setwayi$, \succ) = \{$\ways $\mid$ \repass
$,\repassconst_{\repassi-1},\repassconst_{\repassi-2},\ldots,\repassconst_{1},
$\serv$\}$;

    \item Seja $\delta$, uma função que define um sub-caminho de \setwayi,
representado por \setwayid, a partir de um nó \transs $\in$ \setwayis até um nó
\transssu{1} $\in$ \setwayi, tal que $\delta: ($\trans$,$\setwayi$) \rightarrow
($\setwayid$, \prec)$. Ou seja, para um caminho qualquer $($\setwayi$, \prec) =
\{$\transu{\transi+1}$,$\transu{\transi+1}$,$\trans$,$\transu{\transi-1}$,
$\transu{\transi-2}$, \ldots,$\transu{2}$,$\transu{1}$\}$,
$\delta($\trans$,$\setwayi$) = $ \setwayids $ =
\{$\trans$,$\transu{\transi-1}$,$\transu{\transi-2}$,\ldots,$\transu{2}$,
$\transu{1}$\}$. Neste caso, como $\delta$ faz um corte no conjunto \setwayi,
pode-se obter \textit{caminho semi-completo} ou \textit{completo},
representados por \setwayidsfs\space e \setwayidfs\space, respectivamente;

    \item Seja $\zeta$ uma função que calcula o custo total para transmitir um
pacote \pks $\in$ \setpk, através de um caminho \setwayi, definida por $\zeta :
\sum_{\setwayii=1}^{|\setwayc_\setwayii|} \gamma($\way$,$ \wayu{\wayi+1}$)$, tal
que $\gamma$ é uma função que determina o custo para transmitir o pacote \pks
entre dois nós distintos $\forall$\way$,$\wayu{\wayi+1} $\in$ \setwayi. No GMTP,
o custo é calculado pelo RTT entre dois nós distintos, mas podendo-se
utilizar outras métricas, como número total de saltos no caminho \setwayi;

    \item \textit{Conjectura 1}: $\forall$\repasss $\in$ \setrepasss e
$\forall$\clis $\in$ \setcli, \repasss é mais estável que qualquer \clis com
relação a sua disponibilidade e participação em uma rede de favores $\eta$. Em
uma rede comutada por pacotes IP, um nó \netrs $\in$ \setnetr, portanto para o
GMTP um nó \repass, fica menos indisponível se comparado aos seus nós
\subsetcli(\repass). Por exemplo, nas transmissões de dados na Internet, a
participação de um roteador no processo de transmissão de um fluxo de dados
\setpks é fundamental, mesmo que seja apenas para rotear os respectivos pacotes.
Apesar de óbvia, tal observação é importante porque para qualquer nó \clis
receber os pacotes de dados \pks $\in$ \setpk, primeiramente os pacotes de dados
\pks devem, obrigatoriamente, passar pelo roteador de \cli, ou seja, o seu
roteador padrão. Sendo assim, quando um nó \repasss se desconecta, todos seus
nós \subsetcli(\repass) tornam-se capazes de receber \setpk, mas a recíproca não
é verdadeira -- se um nó \clis se tornar indisponível, não necessariamente
\repasss também se torna indisponível. Com base na aceitação dessa conjectura,
especificamente para a rede \net, pretende-se permitir que outros nós \clis
possam continuar recebendo \setpk, mesmo ocorrendo a desconexão de um nó
\clis que esteja recebendo \setpks durante a recepção de um fluxo de dados
\setpk. No GMTP, adota-se tal estratégia quando um nó \repasss passa a manter
estado sobre tal transmissão e não mais por qualquer nó \cli, antes prática
comumente adotada em soluções tradicionais de distribuição de conteúdos
multimídia baseado em uma arquitetura P2P ou em qualquer protocolo de
transporte e rede disponível no estado da arte;
    \label{item:conjecture1}

    \item \textit{Conjectura 2}: as tabelas de roteamento dos nós \ways $\in$
\setwayis não mudam frequentemente e são independentes umas das outras. Em
redes comutadas por pacotes IP, as rotas entre quaisquer nós \cliu{\clii_1} e
\cliu{\clii_2} $\in$ \setclis não se alteram com um nível de frequência que
desestabilize a comunicação entre estes. Mesmo se estas mudanças ocorrerem em
uma rota de um caminho \setwayi, o impacto causado é temporário e insignificante
para a transmissão de um evento \event quando se utiliza um conjunto de
algoritmos que tratem essas mudanças. Com base na aceitação dessa conjectura, é
possível antecipar a formação de parcerias entre os nós em \setservrepasss
antes da efetiva transmissão de um fluxo de dados \setpk. Essa estratégia é
adotada no GMTP.
    \label{item:conjecture2}

%   \item $\zeta:$ $\hat{r}_x$, $\hat{r}_y$, $\hat{t}_i$)} =
% \textit{min$\{$cost($\hat{r}_y$, $\hat{r}_z$, $\hat{t}_i$)}$\}$, uma função
% recursiva que determina o custo para um nó repassador $\hat{r}_x$ obter, a
% partir de um nó repassador parceiro $\hat{r}_y$, um evento $\gamma$,
% transmitido em $\hat{t}_i$. Sendo assim, \textit{cost($\hat{r}_x$,
% $\forall\hat{r}_y$, $\hat{t}_i$)} $ = 0$ para $\hat{r}_x = \hat{t}_i$;


%   \item f: \textit{link($\hat{r}_i$, $\hat{r}_j$)} $ =
% \hat{r}_i \leftrightarrow \hat{r}_j$ ou f: \textit{link($\hat{r}_i$,
% $\hat{s}$)} $ = \hat{r}_i \leftrightarrow \hat{s}$, uma função que relaciona um
% nó $\hat{r}_i$
% a um nó $\hat{r}_j$ $\mid$ $\hat{r}_i$ e $\hat{r}_j \in R_{\tau}$ ou a um nó
% $\hat{s}$ $\mid$ $\hat{s} \in S_{\tau}$, respectivamente. A propriedade de
% comutatividade de \textit{link()} é válida, ou seja, \textit{link($\hat{r}_i$,
% $\hat{r}_j$)} $=$ \textit{link($\hat{r}_j$, $\hat{r}_i$)};;
%   \label{i:linkrepass}

    \end{enumerate}

\end{enumerate}

Desta forma, \nets representa formalmente a rede de sobreposição constituída
pelo GTMP, definindo-se as relações, restrições estabelecidas em \transmissions
e as conjecturas consideradas para a execução de tal protocolo.

Nas próximas seções, detalham-se os aspectos teóricos e computacionais
empregados do GMTP a fim de construir \net, em três partes distintas de acordo
com os blocos funcionais ilustrados na Figura~\ref{fig:blocos-funcionais}:

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=.5]{imgs/blocos-funcionais.pdf}
\end{center}
\vspace{-0.8cm}
\caption{Blocos funcionais do GMTP e as relações com a pilha de protocolos
TCP/IP.}
\label{fig:blocos-funcionais}
\end{figure}

\begin{enumerate}

  \item \textit{Constituição da rede de favores $\eta$:} descobrir, definir,
efetivar e desfazer parcerias entre os nós \repasss $\in$ \setrepasss de acordo
com o evento \events a ser transmitido (Seção~\ref{sec:connformnet});

  \item \textit{Distribuição do fluxo de dados \setpks em \net, através
das Instâncias de Aplicações (sockets):} conectar os nós \clis $\in$ \setclis,
\repasss $\in$ \setrepasss e \servs $\in$ \setserv, bem como transmitir os
pacotes de dados \pks $\in$ \setpks através da rede de sobreposição constituída
na Fase 1 (Seção~\ref{sec:asptransrecep});

  \item \textit{Controle de congestionamento em \net:} controlar a
taxa de transmissão dos fluxos de dados \setpks transmitidos em \nets na Fase
1 (Seção~\ref{sec:ccgmtp}); e

  \item \textit{Segurança em \net:} verificar a autenticidade do conteúdo de
\setpks antes de entregar aos nós \clis $\in$ \setpks
(Seção~\ref{sec:seguranca}).

\end{enumerate}

\section{Constituição da Rede de Favores \net}
\label{sec:connformnet}

A constituição da rede de favores \nets ocorre por meio do registro
de participação de um ou mais nós \repasss $\in$ \setrepasss a um ou mais
nós \servs $\in$ \setserv. Isto pode ocorrer de forma direta ou indiretamente
por meio de outros nós \repassu{q} $\in$ \setrepass. Todo esforço realizado
nesse processo objetiva transmitir um determinado fluxo de dados $P$ para um ou
mais nós \clis $\in$ \setcli, podendo ser distribuído pelos nós \repasss por
meio de diferentes caminhos \setwayis $\in$ \setway.

O GMTP tenta determinar um caminho sub-ótimo \setwayiu{\theta} através do qual
os pacotes de dados \pks $\in$ \setpks sejam entregues o mais rápido possível ao
nó \clis interessado em obter \setpk. Para isto, deve-se determinar
\setwayiu{\theta}, tal que \setwayiu{\theta} $= min(\zeta(\forall$\setwayi$))$
e, sempre que possível, que \setwayiu{\theta} seja um caminho completo
\setwayifu{\theta}. Sempre buscar um caminho completo é importante porque como
todos os nós de tal caminho são nós repassadores sobrepostos em cada roteador
da rota de rede utilizada para transmitir \setpk, consequentemente pode-se
distribuir \setpks para mais nós \clis sem que sejam necessárias múltiplas
conexões em \serv, evitando cenários da tragédia dos bens comuns, discutidos no
Capítulo~\ref{cap:introducao}. Além disso, por possuir mais nós \repass, um
utilizar um caminho completo torna os sistemas que transmitem um fluxo de dados
\setpks menos sensíveis às desconexões.

\subsection{Registro de participação de \repasss em \net}
\label{subsec:registro-participacao}

O procedimento de registro de participação de um nó \repasss em uma rede $\eta$
é o primeiro passo, e um dos mais importante. O registro de participação permite
que um nó \repasss se registre a um nó \servs para sinalizar interesse em
funcionar como um nó repassador de um ou mais fluxos de dados \setpk. O
registro de participação pode ocorrer antes do nó \servs iniciar a transmissão
de um fluxo de dados \setpk, ou durante sua transmissão.

Para realizar um registro de participação, um nó \repasss envia uma mensagem
para um nó \servs utilizando o pacote \pac{GMTP-Register}, o que permite a
descoberta de um caminho \setwayi. Isto porque todos os nós repassadores
existentes no caminho entre \repasss e \servs devem adicionar seu código no
pacote \pac{GMTP-Register}, no momento de rotea-lo para o próximo salto da rota
em direção ao nó \serv. Na prática, o identificador de um nó repassador pode ser
o endereço IP, porém o método mais apropriado seria gerar um código-nome baseado
na combinação dos endereços MAC (\textit{Media Access Control}) das interfaces
de rede do roteador. Quando o pacote \pac{GMTP-Register} alcançar o destino
\serv, o nó \servs conhecerá a lista ordenada dos nós \repasss até \servs e a
armazenará como sendo um dos possíveis caminhos para distribuir um fluxo de
dados \setpk. Como resposta ao nó \repass, o nó \servs deve enviar um pacote do
tipo \pac{GMTP-Register-Reply}, que confirma o registro de participação. O
caminho \setwayis pode ser utilizado futuramente no processo de formação de
parcerias, a ser discutido na Seção~\ref{sec:descparc}. Pelas
conjecturas~\ref{item:conjecture1} e~\ref{item:conjecture2}, apresentadas na
Seção~\ref{sec:defsrests}, o nó \servs pode utilizar os caminhos conhecidos
\setwayis $\in$ \setways para coordenar o processo de formação de futuras
parcerias entre os nós \repasss $\in$ \setrepass.

Sendo assim, um registro de participação ocorre quando um nó deseja participar
da rede de sobreposição, não necessariamente quando se deseja obter um fluxo de
dados \setpk. Mesmo assim, um registro de participação pode ocorre no mesmo
instante que um nó \repasss desejar receber um fluxo de dados \setpk. Em ambos
os casos, o algoritmo de registro de participação é similar, com uma diferença:
se um nó \repasss solicitar previamente um registro de participação a um
\serv, inicialmente sem interesse por um evento \events qualquer, será possível
mapeá-lo antecipadamente e selecionar um subconjunto de possíveis nós
parcerios \repassu{q} para executar a distribuição de um fluxo de dados
\setpk. Neste caso, pode-se utilizar \repasss para repassar pacotes de dados
\pks mesmo quando \subsetcli$($\repass$) = \{\emptyset\}$, ou seja, quando o nó
\repasss não tenha nó clientes para repassar o fluxo de dados \setpk. Assim, os
nós \repasss passam a funcionar como se fossem servidores de uma rede CDN,
porém dinâmicos, que poderiam ser acionados quando fosse conveniente, por
exemplo, se ele for um nó comum entre dois caminhos, necessitando apenas de
enviar apenas um fluxo de dados \setpk.

De forma similar, se $\exists$\clis $\in$ \subsetcli$($\repass$)$ interessado
em obter \setpk, com \transmitr\space $ = 1$, ou seja, quando um nó \repasss já
está recebendo o fluxo de dados \setpk, o registro de participação já terá
ocorrido e o fluxo já estará sendo recebido pelo nó \repasss em questão, vindo
do nó \serv, mas não necessariamente direto de \serv, mas sim podendo ser
repassado por outros nó \repass. Como consequência, reduzindo-se o tempo de
início de reprodução do referido fluxo de dados \setpks para aqueles nós
\clis que solicitarem o mesmo fluxo de dados \setpks após o primeiro pedir,
bastando apenas que os próximos nós \clis ``sintonizem'' sua interface de
comunicação (socket de rede) no canal apropriado e informado por \repass, pois
a transmissão ocorre em modo multicast.

Analogamente, a motivação do registro de participação empregado no GMTP é
transformar cada roteador de uma rede IP como se fosse uma antena de recepção de
uma transmissora de TV. Tal antena é capaz de receber um ou mais sinais de
canais de TV diferentes, nesse caso, os fluxos de dados \setpk, e distribuí-los
para os aparelhos de TV da cidade, ou melhor, distribuí-los para os sistemas
finais da respectiva rede, ou seja, seus nós \clis $\in$ \setcli. Este assunto
será retomado na Seção~\ref{sec:asptransrecep}, onde discute-se as funções de
conectividade IP empregadas no GMTP.

No Algoritmo~\ref{algo:registerRelay}, resume-se o procedimento de registro
de participação explicado anteriormente. Um nó \repasss utiliza tal algoritmo
para realizar o registro de participação em um nó \serv. Note que o nó \repasss
não é obrigado a informar qual fluxo de dados \setpks está interessado em obter,
pois lembre-se, o nó \repasss se comporta, por analogia, como uma antena de TV.
Porém, da mesma forma que é possível uma antena de TV obter apenas o sinal
correspondente a um determinal canal (frequência de TV), também é possível que
um nó \repasss especifique exatamente qual fluxo de dados \setpks que deseja
receber. Neste caso, o nó \servs executará um procedimento para determinar se
aceita ou não o pedido de registro de participação para transmitir \setpks a
\repass. Em caso de aceite, a transmissão do fluxo de dados \setpks de \servs
para \repasss ocorrerá em modo unicast.

No Algoritmo~\ref{algo:onReceiveGMTPRegisterReply}, resume-se os passos
descritos anteriormente, executados após o nó \repasss receber o pacote
do tipo \pac{GMTP-Register-Reply}, correspondente ao registro de participação.

% , caso contrário, o nó \servs delegará a transmissão de tal fluxo de
% dados \setpks para algum outro nó repassador \repassu{q} que se tornará parceiro
% do nó requisitante \repass.

\newcommand{\attrib}{$\leftarrow$ }

\begin{algorithm}[H]
\label{algo:registerRelay}
\caption{registerRelay(\serv: PeerServer, \pks $=$ \pac{GMTP-Request})}
\SetAlgoLined

\SetKwFunction{Union}{Union}\SetKwFunction{makePkt}{makePkt}
\SetKwFunction{Union}{Union}\SetKwFunction{recvPktRdt}{recvPktRdt}
\SetKwFunction{Union}{Union}\SetKwFunction{sendPktRdt}{sendPktRdt}
\SetKwFunction{Union}{Union}\SetKwFunction{getCurrRegedServers}{getCurrRegedServers}
\SetKwFunction{Union}{Union}\SetKwFunction{parsePath}{parsePath}
\SetKwFunction{Union}{Union}\SetKwFunction{length}{length}
\SetKwFunction{Union}{Union}\SetKwFunction{getPacketFieldValue}{getPacketFieldValue}
\SetKwFunction{Union}{Union}\SetKwFunction{isFlowBeingReceived}{isFlowBeingReceived}
\SetKwFunction{Union}{Union}\SetKwFunction{respondToClients}{respondToClients}
\SetKwFunction{Union}{Union}\SetKwFunction{getChannelOfFlow}{getChannelOfFlow}
\SetKwFunction{Union}{Union}\SetKwFunction{GMTPRegister}{GMTPRegister}
\SetKwFunction{Union}{Union}\SetKwFunction{isWaitingRegisterReply}{isWaitingRegisterReply}
\SetKwFunction{Union}{Union}\SetKwFunction{waitRegisterReply}{waitRegisterReply}
\SetKwFunction{Union}{Union}\SetKwFunction{addClientWaitingFlow}{addClientWaitingFlow}
\SetKwFunction{Union}{Union}\SetKwFunction{GMTPRequestReply}{GMTPRequestReply}

\tcc{The node \repasss executes this algorithm to send a register of
participation to a given node \serv. If \pks is given, node \clis wants to
receive the flow \setpk, so notify \serv.}

\If(){\pks $\neq$ NULL} {
  \textit{\setpk} \attrib \getPacketFieldValue{\pk, `flow'}\tcc*[r]{Extracts
\setpks in \pk}
  \label{algo-line:registerRelay-getP}
  \textit{\cli} \attrib \getPacketFieldValue{\pk, `client'}\tcc*[r]{Extracts \clis in \pk}
  \textit{channel} \attrib \isFlowBeingReceived{\setpk}\tcc*[r]{See Section~\ref{subsec:tabela-recepcao}}
  \tcc{Add \clis in the list of receivers waiting \setpk.}
  \addClientWaitingFlow{\cli, \setpk}\;
  \label{algo-line:addClientWaitingFlow}
  \uIf(){\textit{channel} $\neq$ NULL} {
    \label{algo-line:isFlowBeingReceived}
    \tcc{Let \clis know that \setpks is already registered in this \repasss and is available from a multicast channel.}
    \respondToClients{\GMTPRequestReply{\textit{channel}}}\;
    \label{algo-line:respondToClients1}
    \Return{0}\;
    \label{algo-line:registerRelay-returnChannel}
  } \Else(\tcc*[f]{Flow \setpks not registered yet.}) {
      \tcc{Send request to \servs and wait registration reply. When \pac{GMTP-Register-Reply} is received, executes onReceiveGMTPRegisterReply (Algorithm~\ref{algo:onReceiveGMTPRegisterReply}).}
%  If the \pac{GMTP-Register} was already sent, nothing should be done other than wait for \pac{GMTP-Register-Reply}.
      \If() {\textbf{not} \isWaitingRegisterReply{\setpk}} {
	\isWaitingRegisterReply{\setpk, true}\;
	\sendPktRdt{\GMTPRegister{\serv, \setpk}}\;
	\Return{0}\;
      }
      \tcc{Ask \subsetcli$($\repass$)$ to wait registration reply for \setpk.}
      \respondToClients{\GMTPRequestReply{\setpk}}\;
      \label{algo-line:respondToClients2}
      \Return{0}\;
  }
}
\If(){\textbf{not} \isWaitingRegisterReply{\serv}} {
  \Return{\sendPktRdt{\GMTPRegister{\serv}}}\;
}
\Return{0};

\end{algorithm}

\vspace{0.8cm}

\begin{algorithm}[H]
\label{algo:onReceiveGMTPRegisterReply}
\caption{onReceiveGMTPRegisterReply(\pks $=$ \pac{GMTP-Register-Reply})}
\SetAlgoLined

\SetKwFunction{Union}{Union}\SetKwFunction{createMulticastChannel}{createMulticastChannel}
\SetKwFunction{Union}{Union}\SetKwFunction{getAndStoreServerPublicKey}{getAndStoreServerPublicKey}
\SetKwFunction{Union}{Union}\SetKwFunction{updateFlowReceptionTable}{updateFlowReceptionTable}
\SetKwFunction{Union}{Union}\SetKwFunction{startRelay}{startRelay}

\tcc{The node \repasss executes this algorithm when receives a packet of type
\pac{GMTP-Register-Reply}, as response for a registration of participation sent to a \servs node.}

\isWaitingRegisterReply{\setpk, false}\;
\uIf(\tcc*[f]{\servs confirmed registration}){\pks = OK} {
  \textit{\servs} \attrib \getPacketFieldValue{\pk, `server'}\tcc*[r]{Gets \servs in \pk}
  \textit{\setpk} \attrib \getPacketFieldValue{\pk, `flow'}\tcc*[r]{Gets \setpks in \pk}
  \If(\tcc*[f]{Reply to \subsetcli$($\repass$)$, waiting for \setpk}){\setpks $\neq$ NULL}{
    \If(\tcc*[f]{Section~\ref{subsec:obterchavepublica}}){\servs enabled security layer} {
      \getAndStoreServerPublicKey{\serv}\;
    }
    \textit{channel} \attrib \createMulticastChannel{\serv, \setpk}\;
    \updateFlowReceptionTable{\textit{channel}}\tcc*[r]{Section~\ref{subsec:tabela-recepcao}}
    \label{algo-line:updateFlowReceptionTable}
    \tcc{Let \clis $\in$ \subsetcli$($\repass$)$ know the multicast channel to receive \setpks (Section~\ref{subsec:conexao-requisicao}).}
    \respondToClients{\GMTPRequestReply{\textit{channel}}}\;
    \label{algo-line:respondToClients3}
    \tcc{Start to relay \setpks to clients (Section~\ref{subsec:trocdados}).}
    \startRelay{\textit{channel}}\;
    \label{algo-line:startRelay}
  }
  \tcc{It was just a reply of a registration of participation. Update flow reception table.}
  \updateFlowReceptionTable{\textit{\serv}}\tcc*[r]{Section~\ref{subsec:tabela-recepcao}}
} \Else() {
  \tcc{\servs refused to accept the registration of participation. This \repasss must notify the clients waiting for receiving \setpk.}
  \textit{errorCode} \attrib \getPacketFieldValue{\pk, `error'}\;
  \respondToClients{\GMTPRequestReply{\textit{errorCode}, \setpk}}\;
  \label{algo-line:respondToClients4}
}

\end{algorithm}
\vspace{0.8cm}

Note que, no GMTP, toda transferência de pacotes de controle entre nós \repass
ocorre com garantia de entrega, representando-se tais ações pelas funções com
nomes contendo o sufixo \textit{Rdt} (\textit{Reliable data transfer}). Uma
outra decisão importante tomada no GMTP é que um nó \repasss deve periodicamente
sinalizar sua participação na rede de favores \nets através de uma função
tradicionalmente conhecida por \textit{keep-alive}, comumente utilizado em
outros protocolos de rede consolidados, como o TCP. Nesse aspecto, o GMTP segue
a RFC 1122, \textit{Requirements for Internet Hosts - Communication
Layers}~\cite{RFC1122}.

Além disso, um nó \repasss pode sinalizar explicitamente sua desconexão a
\serv, quando não desejar mais participar da rede de favores $\eta$ ou receber
um fluxo de dados \setpk. Para isto, deve-se enviar um pacote do tipo
\pac{GMTP-Close}. Em qualquer um dos casos de desconexão, por expiração do
tempo (devido ao procedimento de \textit{keep-alive}) ou explicitamente através
do envio do pacote do tipo \pac{GMTP-Close}, o nó \servs deve desconsiderar
\repasss no processo de formação de parcerias e enviar para este um pacote do
tipo \pac{GMTP-Reset}.

Por fim, salienta-se que o registro de participação do GMTP permite que quanto
mais nós \repasss se registrarem em nós \serv, mais caminhos \setwayis sejam
conhecidos. Consequentemente, quanto mais caminhos forem conhecidos, mais
parcerias poderão ser formadas entre os nós \repass. E, portanto, quanto mais
parcerias forem formadas, maior será o número de nós \clis capazes de receber um
fluxo de dados \setpks originado em \serv, disponibilizado indiretamente através
dos seus respectivos nós \repass, sem nenhuma influência da camada de aplicação.
No mundo real (Internet), os nós \repasss podem passar a constituir
dinamicamente a rede de distribuição de conteúdos de uma empresa. Por exemplo,
um usuário de uma conexão residencial xDSL, por exemplo, pode configurar seu
roteador para registra-lo em múltiplas redes de distribuição, como ilustrou-se
na Figura~\ref{fig:tela-gmtp-inter}. Nesses casos, as redes de distribuição
podem fazer uso do roteador desse usuário em momentos ociosos de recepção e
transmissão de dados através da Internet. Como consequência, relações comerciais
podem ser construídas entre o usuário e os provedores de rede, mas essa
discussão está fora do escopo deste trabalho.

COLOCAR UMA SEÇÃO NO FINAL DESSE CAPÍTULO SOBRE A PROPOSTA DO TRABALHO ENVIADO
PARA O TCE?! ACHO QUE VALE A PENA.

\subsection{Tabela de Recepção de Fluxos de Dados}
\label{subsec:tabela-recepcao}


COLOCAR O CAMPO RTT? ISSO AJUDARÁ MUITO E SEGMENTARÁ O CAMINHO, EVITANDO-SE QUE
A TRANSMISSÃO DE UM FLUXO NÃO SEJA DEGRADADA POR UM NÓ EM GARGALO QUE
ESPECIFICARÁ UMA VELOCIDADE DE TAXA DE TRANSMISSÃO MENOR DO QUE SUPORTADO POR
UM CAMINHO MAIS PRÓXIMO DO SERVIDOR:

S1 R1 R2 R3 R4 R5 (COMO O GMTP USA O RCP, SE R1,R5 RECEBEM P, O USO DO RCP PURO
IMPACTARIA QUE A TAXA DE TRANSMISSÃO DE R1 SERIA GOVERNADA POR R5. GUARDANDO
TAMBÉM, PODE-SE TER TX INFLUENCIADA APENAS PELOS NÓS DO SUBCAMINHO.)



Antes de seguir com a explicação sobre o processo de estabelecimento de conexão
do GMTP, é importante entender que cada nó \repasss mantém uma tabela chamada
\textit{Tabela de Recepção de Fluxos de Dados}, como ilustra-se na
Figura~\ref{fig:tabela-recepcao-1}. O nó \repasss utilizal tal tabela para
registrar todos os fluxos de dados que estão sendo repassados para seus nós
\clis $\in$ \subsetcli$($\repass$)$, mantendo-se as
seguintes informações:

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=.55]{imgs/tabela-recepcao-fluxo-1.pdf}
\end{center}
\vspace{-1cm}
\caption{Exemplo de uma tabela de recepção de fluxo mantida por um nó \repass.}
\label{fig:tabela-recepcao-1}
\end{figure}

\begin{itemize}

  \item \textbf{Nome do Fluxo de Dados \setpk:} é uma sequência de
\ut{128}{bits} que determina o nome de um fluxo de dados, como descrito na
Seção~\ref{subsec:content-index};

  \item \textbf{Servidores \serv:} o endereço IP do nó \servs que gera o fluxo
de dados \setpk;

  \item \textbf{Repassadores \repassu{q}:} o endereço IP do nó \repassu{q},
parceiro de \repass, que está transmitindo o fluxo de dados \setpks para
\repass. Se nulo, significa que o fluxo de dados \setpks está sendo recebido
diretamente do nó \serv;

  \item \textbf{Porta de Recepção de \setpk:} o número da porta do nó remoto
que está transmitindo o fluxo de dados \setpks para \repass. Nesse caso, o nó
remoto pode ser o nó \serv, em caso de conexão direta com o servidor, ou um nó
\repassu{q}, parceiro de \repass;

  \item \textbf{Endereço do Canal Multicast:} o endereço IP multicast utilizado
pelo nó \repasss para repassar o fluxo de dados \setpks para os nós clientes
\clis $\in$ \subsetcli$($\repass$)$; e

  \item \textbf{Porta do Canal Multicast:} o número da porta multicast utilizada
pelo nó \repasss para repassar o fluxo de dados \setpks para os nós clientes
\clis $\in$ \subsetcli$($\repass$)$.

\end{itemize}

Um nó \repasss consulta a tabela de recepção de fluxos de dados quando recebe um
pedido de conexão para obter um fluxo de dados \setpk, tal como apresentou-se
na Linha~\ref{algo-line:isFlowBeingReceived} do
Algoritmo~\ref{algo:registerRelay},
Seção~\ref{subsec:registro-participacao}. Além disso, um nó \repasss atualiza a
tabela de recepção de fluxos de dados após receber uma confirmação do registro
de participação, tal como apresentou-se na
Linha~\ref{algo-line:updateFlowReceptionTable} do
Algoritmo~\ref{algo:onReceiveGMTPRegisterReply},
Seção~\ref{subsec:registro-participacao}. Mais adiante, na
Seção~\ref{subsec:conexao-requisicao}, discute-se em mais detalhes as ações de
consulta e atualização da tabela de recepção de fluxos de dados.

\subsection{Formação de parcerias}
\label{sec:descparc}

No GMTP, as parcerias ocorrem entre os nós \repasss $\in$ \setrepasss
e não entre os nós \clis $\in$ \setcli, como em solução existente baseada no
modelo de serviço P2P. A formação de parcerias consiste em determinar
intersecções de caminhos \setwayi, considerando o nó \textit{pivot} \servs e
diversos nós \repasss interessados em obter \setpk, a pedido de seus nós \clis
$\in$ \subsetcli$($\repass$)$. Este processo ocorre antes e durante a
transmissão de um fluxo de dados \setpk, de forma transparente para a aplicação
em execução em \cli, durante seu pedido de conexão transmitido em direção ao nó
\serv, que transmite \setpk. Como consequência, constitui-se um ou mais caminhos
\setwayis $\in$ \setway, os quais interconectam um nó \servs e os nós \clis
$\in$ \subsetcli(\way), de modo que $\exists$\setwayis $\mid$ \ways $\in$
\setwayi. Como regra geral para formação de parcerias, definem-se dois
critérios:

\begin{enumerate}

  \item o melhor nó \servs para servir um nó \repasss é aquele que está
especificado em seu pedido de registro de participação;

  \item se \transmitqu{\way} $=$ $1$, então \ways pode agir como se fosse um nó
\serv;

  \item se o nó \ways $\in$ \setwayi, tal que \setwayis é parte ou
todo o caminho entre \repasss e \servs e \ways se enquadra no Item 2, então o
melhor nó \servs para servir \repasss será o mesmo que serve o nó \way.

\end{enumerate}


\begin{figure}[ht]
\begin{center}
\includegraphics[scale=.5]{imgs/esquema-abstrato-formacao-parceria-intra.pdf}
\end{center}
\vspace{-0.8cm}
\caption{Cenário e passos para seleção de nós (exemplo 1).}
\label{fig:esquema-abstrato-formacao-parceria-intra}
\end{figure}

% $\{$\setwayiu{1}, \setwayiu{2}, $\dots$ \setwayiu{\setwayii}$\}$

Para entender detalhes desse processo, considere a
Figura~\ref{fig:esquema-abstrato-formacao-parceria-intra}. No Passo 1,
ilustra-se um cenário de rede \nets $=$ $G($\setservrepass, \setway$)$, onde
\setservrepasss $=$ $\{$\servu{1}, \repassu{1..19}$\}$, \setways $=$
$\{\emptyset\}$ e \transmission $=$ $\{\{\emptyset\}$, $\{\emptyset\}$,
$\{\emptyset\}\}$, ou seja, sem qualquer fluxo de dados \setpks sendo
transmitido, tampouco nenhuma parceria efetivada e suprimindo-se os nós \clis
$\in$ \subsetcli$($\repassu{1..19}$)$. Já no Passo 2, ilustra-se a mesma rede
\net, porém com \transmission $=$ $\{\{$\servu{1}, \repassu{5..9}$\}$, \setpk,
\subsetcli$($\repassu{5..9}$)\}$, constituindo-se o caminho \setwayiu{1} $=$
$\{$\servu{1}, \repassu{5..9}$\}$ (linha tracejada e vermelha) e, portanto,
\setway $=$ $\{$\setwayiu{1}$\}$ com \transmitqu{\repassu{9}} $=$ $1$. Nesse
exemplo do Passo 2, o nó \repassu{9} recebe o fluxo de dados \setpks em modo
unicast e repassa \setpks para todos os nós \clis $\in$
\subsetcli$($\repassu{9}$)$ em modo multicast. Para constituir o caminho
\setwayiu{1}, o nó \repassu{9} deve transmitir o pedido de registro de
participação ao nó \servu{1} (como
discutiu-se na Seção~\ref{subsec:registro-participacao}) e, a
partir de sua confirmação, processada pelo nó \servu{1} e enviada de volta ao nó
\repassu{9}, \repassu{9} começa a receber os pacotes \pks $\in$ \setpk. Com
este procedimento, o nó \servu{1} passa a conhecer o caminho \setwayiu{1}, que
pode ser utilizada para determinar futuras parcerias. Desse ponto em
diante, utilizar-se-á tal exemplo como base para explicar o funcionamento de
formação de parceria do GMTP.

Na Figura~\ref{fig:esquema-abstrato-formacao-parceria-interseccao}, considera-se
a formação de parceria por intersecção do fluxo de dados \setpk, a partir
do Passo 2 da Figura~\ref{fig:esquema-abstrato-formacao-parceria-intra}.
Este procedimento ocorre quando um outro nó \repasss envia um pedido de
registro de participação em direção ao nó \servu{1}, a fim de obter o fluxo de
dados \setpk, motivado por algum nó \clis $\in$ \subsetcli$($\repass$)$. Nesse
caso, se um nó \repasss transmitir um pedido de registro de participação através
de um sub-caminho \setwayids tal que $\exists$\setwayis $\in$ \setway, o
nó \servs determina a intersecção de ambos e instrui o nó comum \ways a
repassar o fluxo de dados \setpks também para \repass, sem a necessidade de
enviar um segundo fluxo de dados na mesma direção de \setwayid. Sendo assim, a
resposta de \servu{1} não resulta em uma nova transmissão do fluxo de dados
\setpk, mas sim em uma mensagem de controle para o nó \way, após identificá-lo
como o nó comum a dois ou mais caminhos \setwayi. Isto implicará que o referido
nó \ways replique o fluxo de dados \setpk, mesmo quando $|$\subsetcli$($\way$)|$
$=$ $0$, mas de modo conveniente para evitar múltiplas transmissões do
fluxo de dados \setpk, originadas no nó \serv. A fim de compreender o
funcionamento desse procedimento, acompanhe a explicação a seguir, com base na
ilustração da Figura~\ref{fig:esquema-abstrato-formacao-parceria-interseccao} e
no caminho \setwayiu{1}.

\begin{figure}
\begin{center}
\includegraphics[scale=.5]{imgs/esquema-abstrato-formacao-parceria-interseccao.pdf}
\end{center}
\vspace{-0.8cm}
\caption{Cenário para seleção de nós por interseção de caminhos \setwayi.}
\label{fig:esquema-abstrato-formacao-parceria-interseccao}
\end{figure}

Se qualquer um dos nós \repassu{7,8,10,11,12}, suponha \repassu{11}, enviar um
registro de participação em direção à \servu{1} para obter um fluxo de dados
\setpks (Passo 3 da
Figura~\ref{fig:esquema-abstrato-formacao-parceria-interseccao}), o nó
\servu{1} descobrirá o caminho \setwayiu{2} $=$ $\{$\repassu{5}, \repassu{6},
\repassu{7}, \repassu{10}, \repassu{11}$\}$. Em seguida, pela intersecção
$($\setwayiu{1} $\cap$ \setwayiu{2}$)$, o nó \servu{1} determinará que o nó
\repassu{7} é o nó comum e portanto instruirá que \repassu{7} repasse o fluxo de
dados \setpks também para o nó solicitante \repassu{11} (Passo 4). A instrução
de \servu{1} para \repassu{7} deve determinar \transmitqu{\repassu{7}} $=$ $1$.
Em termos práticos, isto obriga o nó \repassu{7} a adicionar uma nova entrada na
tabela de recepção de fluxos de dados referente a \setpk, mesmo se
$|$\subsetcli$($\repassu{7}$)|$ $=$ $0$ para \setpk. É óbvio que, se
posteriormente $|$\subsetcli$($\repassu{7}$)|$ $>$ $0$ para \setpk, será
necessário apenas \repassu{7} criar um canal multicast para a transmissão
local de \setpk, evitando-se um novo registro de participação em \servu{1}. Na
Seção~\ref{subsec:conexao-requisicao}, discute-se em mais detalhes este aspecto
do GMTP, explicando-se os procedimentos de pedido de conexão de um nó \cli.

Ao estender a discussão sobre o cenário ilustrado na
Figura~\ref{fig:esquema-abstrato-formacao-parceria-interseccao}, percebe-se que
se o nó \repassu{10} necessitar obter o mesmo fluxo de dados \setpk, seu pedido
de registro de participação será interceptado pelo nó \repassu{7} e parte do
procedimento supracitado se repete. Uma situação similar ocorre se o nó
\repassu{12} ou qualquer nó \repasss $\in$ \setwayiu{4} também desejar obter o
fluxo de dados \setpk, tal que \setwayiu{4} $=$ $\{$\repassu{1},
\repassu{2}, \repassu{3}, \repassu{4}$\}$ (Passo 5). Para o caso do nó
\repassu{12}, o nó \repassu{11} interceptará o pedido de registro de
participação de \repassu{12}, ao passo que se for qualquer nó \repasss $\in$
\setwayiu{4}, o nó \repassu{6} realizará tal interceptação, pois o nó
\servu{1} determinará \transmitqu{\repassu{6}} $=$ $1$, depois do
primeiro pedido de registro de participação originado por qualquer nó \repasss
$\in$ \setwayiu{4} (Passo 6). A única diferença nesses últimos casos é que,
como \transmitqu{\repassu{7}} $=$ $1$ e \transmitqu{\repassu{11}} $=$ $1$, o nó
\repassu{7} tem autonomia para responder ao nó \repassu{10} e o nó \repassu{11}
tem autonomia para responder ao nó \repassu{12}, ambos como se fossem o nó
\servu{1}, sem repassar tal pedido em direção ao nó \servu{1}.

Para generalizar essa discussão sobre o processo de formação de parcerias do
GMTP, caso existam outros nós \repassu{q} interessados em obter um fluxo de
dados \setpks e estão interligados direto ou indiretamente a \repass,
tal que \transmitqu{\repass} $=$ $1$, o nó \repasss sempre interceptará o pedido
de registro de participação dos nós \repassu{q} e atuará como se fosse o nó
\servu{1}. No caso do exemplo que se discute, independente da ordem em que as
requisições de registro de participação sejam enviadas por \ways $\in$
(\setwayiu{1} $\cup$ \setwayiu{2} $\cup$ \setwayiu{3} $\cup$ \setwayiu{4}), será
necessário transmitir apenas um fluxo de dados \setpks para ``alimentar'' os
quatro caminhos referidos. Isto significa que todos os nós \clis $\in$
\subsetcli$($\setwayiu{1} $\cup$ \setwayiu{2} $\cup$ \setwayiu{3} $\cup$
\setwayiu{4}$)$ receberão um único fluxo de dados, com repasse dos pacotes \pks
$\in$ \setpks realizado em modo multicast para cada sub-rede representada por
\ways (Passo 7). Como a transmissão será em modo multicast, torna-se indiferente
a quantidade de nós \clis desses caminhos, mas faz-se necessário um mecanismo
para controle de congestionamento em modo multicast. Na Seção~\ref{sec:ccgmtp},
discute-se em mais detalhes este aspecto.

Note que, o nó \repasss que interceptar um pedido de conexão para um fluxo de
dados \setpk, deve transmitir para o nó \servs uma notificação sobre
a(s) parceria(s) formada(s) por intersecção. No caso do exemplo anterior, os nós
\repassu{6}, \repassu{7} e \repassu{11} devem realizar tal notificação enviando
um pacote do tipo \pac{GMTP-Register}, como explicado na
Seção~\ref{subsec:registro-participacao}. Para isso, deve-se
ativar o bit \textit{intercepted} do pacote definido no
pacote \pac{GMTP-Register}. Esta ação é importante devido aos aspectos
gerenciais de uma transmissão, onde uma aplicação poderá contabilizar os nós
\repasss que estão recebendo \setpk, mesmo que indiretamente, por meio da
interceptação de registros de participação. No ponto de vista prático, não se
faz necessário que o nó \repasss envie tal notificação no instante em que se
intercepte um pedido de registro de participação. Em vez disso, pode-se acumular
diversos registros de participação durante um determinado intervalo de tempo e,
em seguida, transmiti-los para o nó \serv. Como se trata de um aspecto a
nível de implementação, tal decisão não está no escopo dessa discussão. No caso
da implementação do GMTP realizada em simulador e utilizada neste trabalho,
definiu-se que para todo registro de participação interceptado, gera-se e
transmite-se uma notificação ao nó \serv.

No Algoritmo~\ref{algo:findPartnerIntersectPath}, resume-se os passos
descritos anteriormente na perspectiva do nó \serv, a fim de determinar a
formação de parcerias por intersecção. Executa-se tal algoritmo quando o nó
\servs recebe um pedido de registro de participação originado por um nó \repasss
para obter um fluxo de dados \setpk. Através dessa estratégia de formação de
parceria empregada no GMTP, permite-se repasses de pacotes de dados levando-se
em consideração o fluxo de dados de interesse e não o nó que o
produz. Em todo caso, o destino da requisição é o nó servidor, garantindo-se que
se nenhum nó repassador interceptar o pedido de registro de participação, tal
pedido alcançará o nó servidor e o estabelecimento de conexão ocorrerá
normalmente.

% O nó \servs compara os caminhos conhecidos
% \setwayis $\in$ \setways com o caminho \textit{\setwayiu{\repassconst_\repassi}}
% contido no pedido de conexão transmitido por \repass. Se \servs encontrar um nó
% \ways em comum entre algum \setwayis e
% \textit{\setwayiu{\repassconst_\repassi}}, \servs instrui o nó \ways a
% interceptar os próximos pedidos de registro de participação para obter \setpk;
% caso contrário, \servs aceita o novo pedido de conexão, permitindo-se futuras
% parcerias por intersecção. Note que, após este procedimento, o nó \servs passa a
% conhecer o caminho \textit{\setwayiu{\repassconst_\repassi}}.

\begin{algorithm}[H]
\label{algo:findPartnerIntersectPath}
\SetAlgoLined
\caption{handleRegisterParticipation(\repass: PeerRelay, \pks $=$
\pac{GMTP-Register})}
\tcc{\servs executes this algorithm to finds the first node \ways common to a
known path \setwayis and the path \setwayiu{\repassconst_\repassi}. \setwayis is
already used for transporting \setpks to node in $\delta($\way, \setwayi$)$, and
\setwayiu{\repassconst_\repassi} contains all nodes between \repasss (requester)
and \serv. The packet \pks carries \setwayiu{\repassconst_\repassi} and the
\setpks flow name.}
\textit{done} \attrib \textit{false}\tcc*[r]{It becomes true when \ways is found}

\SetKwFunction{Union}{Union}\SetKwFunction{makePkt}{makePkt}
\SetKwFunction{Union}{Union}\SetKwFunction{getPacketFieldValue}{getPacketFieldValue}
\SetKwFunction{Union}{Union}\SetKwFunction{recvPktRdt}{recvPktRdt}
\SetKwFunction{Union}{Union}\SetKwFunction{sendPktRdt}{sendPktRdt}
\SetKwFunction{Union}{Union}\SetKwFunction{length}{length}
\SetKwFunction{Union}{Union}\SetKwFunction{getKnownPathsOfFlow}{getKnownPathsOfFlow}
\SetKwFunction{Union}{Union}\SetKwFunction{GMTPRegisterReply}{GMTPRegisterReply}

\textit{\setpk} \attrib \getPacketFieldValue{\pk, `flow'}\tcc*[r]{Extracts \setpks in \pk}
\textit{\setwayiu{\repassconst_\repassi}} \attrib \invert{\getPacketFieldValue{\pk, `path'}}\;
\textit{\setwayiu{\setpkc}} \attrib \getKnownPathsOfFlow{\setpk}\tcc*[r]{\setwayiu{\setpkc} $\subset$ \setway}
% \tcc*[r]{For a given flow and all the known paths \setways in this \serv, get a sub set of paths used to transmit \setpk}

\ForEach{\setwayis $\in$ \setwayiu{\setpkc}}{
    \ForEach{\ways $\in$ \setwayi} {
      \If(){\ways $\in$ \textit{\setwayiu{\repassconst_\repassi}}} {
        \tcc{The node \ways is common in \setwayis and in \textit{\setwayiu{\repassconst_\repassi}}.}
        \textit{done} \attrib \textit{true}\;
        break\;
      }
    }
    \If(){\textit{done}} {
% \tcc{Create a \pac{GMTP-Response} and send it to \way. After receiving \textit{\pk}, \ways becomes a relay of the flow \setpk.}
% \pks \attrib \makePkt{\pac{GMTP-Response}(1), \ways}\;
      \tcc{\servs stores \textit{\setwayiu{\repassconst_\repassi}} as a known path and replies to \repass, asking \ways to act as a relay for \setpk. \servs actives flag 'relay' of the \pac{GMTP-RegisterReply}.}
      \setwayiu{\setpkc}[\length{\setwayiu{\setpkc}}] \attrib \textit{\setwayiu{\repassconst_\repassi}}\;
      \Return{\GMTPRegisterReply{\way, relay=1}}\;
% \sendPktRdt(\pk)\;
% \exit{}\;
    }
}
\tcc{\servs must register \textit{\setwayiu{\repassconst_\repassi}} as a known path and reply to \repasss by accepting its connection request, since no node \ways is intersecting \textit{\setwayiu{\repassconst_\repassi}}. In this case, \servs starts the transmission of \pks $\in$ \setpks to \repass.}
\setway[\length{\setway}] \attrib \textit{\setwayiu{\repassconst_\repassi}}\;
\Return{\GMTPRegisterReply{\repass, relay=0}}\;
% \pks \attrib \makePkt{\pac{GMTP-Response}(0), \repass}\;
% \sendPktRdt(\pk)\;

\end{algorithm}
\vspace{0.8cm}

Pela solução apresentada de formação de parceria empregada no GMTP, percebe-se
que o nó servidor ajuda na formação de parcerias entre os nós repassadores,
quando se permite o nó servidor se comunicar diretamente com o nó \repass, a fim
de delegar a responsabilidade em distribuir um determinado fluxo de dados
\setpk. Esses procedimentos não são adotados em nenhum protocolo de rede
conhecido do estado da arte.

Com relação à praticidade dessa solução empregada no GMTP, um aspecto técnico
muito importante deve ser ressaltado: apenas o nó \repasss que repassar \pks
$\in$ \setpks para seus nós \clis $\in$ \subsetcli$($\repass$)$ deve manter uma
entrada sobre \setpks na tabela de recepção de fluxos de dados, exceto quando
sinalizado pelo nó \serv, como foi o caso dos nós \repassu{6} e \repassu{7}.
Além disso, como a transmissão de um fluxo de dados \setpks entre um nó \repasss
e seus nós \clis $\in$ \subsetcli$($\repass$)$ ocorrerá sempre em modo
multicast, faz-se necessária apenas uma entrada na tabela de recepção de fluxos
de dados sobre \setpk. Com essa estratégia, deve-se esperar uma quantidade
significativa de nós \clis capazes de reproduzir um fluxo de dados \setpk,
sem sobrecarregar a rede com demasiadas transmissões do mesmo fluxo de dados
\setpk, além da redução do tempo de inicialização para reproduzir o fluxo
de dados \setpk (\textit{startup time}).

% \subsubsection{\space\space\space\space\space\space2. Formação de parcerias por
% intersecção de \setwayi}
% \label{subsec:parcintersec}

% \subsubsection{\space\space\space\space\space\space3. Formação de parcerias por
% combinação de \setwayi}
% \label{subsec:parccombina}
%
% O procedimento de formação de parcerias por combinação considera um nó
% \textit{pivot} \servs e consiste em combinar caminhos distintos \setwayiu{1} e
% \setwayiu{2}, tal que \setwayiu{1} $\cap$ \setwayiu{2} $= \{$\serv$\}$, como
% ilustra-se na Figura~\ref{fig:esquema-abstrato-formacao-parceria-combinacao},
% Passo 1. Dessa forma, dado um conjunto de caminhos conhecidos \setway, o nó
% \servs executa as combinações e instrui, por exemplo, dois nós \wayu{1} $\in$
% \setwayiu{1} e \wayu{2} $\in$ \setwayiu{2} a se tornarem parcerios para
% compartilharem o mesmo fluxo de dados \setpk, transmitindo apenas um fluxo de
% dados \setpks para ser distribuídos aos nós \clis $\in$
% $($\subsetcli$($\wayu{1}$)$ $\cup$ \subsetcli$($\wayu{2}$))$. Este procedimento
% resultará na constituição de um caminho \setwayis contendo todos os nós \repasss
% entre os \wayu{1} e \wayu{2}. Como consequência, pode-se repassar o mesmo fluxo
% \setpks também para outros nós \clis $\in$ \subsetcli$($\repass$)$.
%
% \begin{figure}[ht]
% \begin{center}
% \includegraphics[scale=.5]{imgs/esquema-abstrato-formacao-parceria-combinacao.pdf}
% \end{center}
% \vspace{-0.8cm}
% \caption{Cenário e passos para seleção de nós por combinação de caminhos
% \setwayi.}
% \label{fig:esquema-abstrato-formacao-parceria-combinacao}
% \end{figure}
%
% % Tal procedimento pode ajudar os nós \repasss a expandirem
% % suas parcerias, incluindo a possibilidade de obter pacotes de dados \pks $\in$
% % \setpks de múltiplos nós parceiros \repassu{q}.
%
% Com o registro de participação de cada nó \repasss em \serv, o nó \servs
% conhece os caminhos \setwayis $\subset$ \setways através dos quais se
% transmite o fluxos de dados \setpk. Sendo assim, \servs pode determinar
% candidados a parcerios \repassu{q} de um determinado nó \repasss e esse
% procedimento acontece da seguinte forma. Um nó \repasss enviar uma mensagem ao
% nó \servs para solicitando a lista de parceiros
%
% Para isso, o nó
% \servs instrui
% os nós \wayu{1} e \wayu{2} a executarem um algoritmo para determinar se
% \wayu{1} servirá \wayu{2} ou se \wayu{2} servirá \wayu{1}. Note que é possível
% que a parceria entre \wayu{1} e \wayu{2} não ocorra. Por exemplo, \wayu{1} se
% tornará parceiros de \wayu{2} apenas se o custo entre \wayu{1} e \wayu{2} for
% menor do que o custo entre \wayu{1} e \serv.
%
%  a
% execução da formação de parceria por combinação, o nó \servs envia um pacote do
% tipo \pac{GMTP-Partnership} aos nós \repass, escolhidos dentre os que estão
% conectados e recebendo o fluxo de dados \setpks diretamente de \serv, para
% executarem o Algoritmo~\ref{algo:findPartnerCombinePath}. Em geral funciona com
% base em busca binária, tendo como critério o custo entre $\zeta($\setwayiu{1}$)$
% e $\zeta($\setwayiu{2}$)$  da seguinte forma. O nó \servu{2} processa os
% caminhos
% \setwayis conhecidos e determina quais são os melhores parceiros \repassu{q}
% para um determinado nó \repass, sendo tal informação enviada para \repass. No
% caso do cenário ilustrado na
% Figura~\ref{fig:esquema-abstrato-formacao-parceria-combinacao}, Passo 2, é
% possível combinar os caminhos \setwayiu{1} e \setwayiu{2} pelos nós \repassu{6}
% e o \repassu{15}. Ao combinar dois caminhos \setwayiu{1} e \setwayiu{2}, sempre
% haverá duas direções para a transmissão do fluxo de dados \setpk, uma ilustrada
% no Passos 3 e outra ilustrada no Passo 4 da
% Figura~\ref{fig:esquema-abstrato-formacao-parceria-combinacao}. Para decidir
% qual opção escolher, o nó \servu{2} compara os custos $\zeta($\setwayiu{1}$)$ e
% $\zeta($\setwayiu{2}$)$. Se $\zeta($\setwayiu{1}$) \geq \zeta($\setwayiu{2}$)$,
% então o nó \servu{2} solicita que \repassu{9} envie um pedido de conexão para
% \repassu{16} (Passo 4). Por fim, o nó \repassu{15} deve enviar uma notificação
% para o nó \servu{2} informando sobre a constituição do novo caminho \setwayi. Em
% caso de $\zeta($\setwayiu{1}$) \leq \zeta($\setwayiu{2}$)$, então o nó \servu{2}
% solicitará que \repassu{16} envie um pedido de conexão para \repassu{9} (Passo
% 3), ao passo que o restante do procedimento ocorrerá de forma similar ao que
% acabara de ser explicado.
%
% Esta é a grande motivação da formação de parceria por combinação, pois quando o
% pedido de conexão do nó \repassu{9} alcançar o nó \repassu{15}, este o
% interceptará e, nesse instante, constitui-se um novo caminho \setwayis $=
% \{$\repassu{15}$,$\repassu{14}$,$\repassu{6}$,$\repassu{7}$,$\repassu{8}$,
% $\repassu{9}$\}$.
%
% É importante salientar que o pedido de conexão enviado pelo nó \repassu{9}
% para o nó \repassu{15} deve conter uma sinalização (\textit{flag}) que
% instruirá o nó \repassu{6} a não interceptar tal pedido de conexão. Para
% tal sinalização, dá-se o nome de \textit{ignorar pedido de conexão},
% do inglês \textit{bypass connection request}.
%
% Nessa estratégia de formação de parceria, permite-se que um nó \repasss obtenha
% os pacotes \pks $\in$ \setpks de duas ou mais fontes distintas. No caso do
% exemplo supracitado, o nó \repassu{6} pode continuar recebendo o fluxo de dados
% através do caminho \setwayiu{1} e também através do novo caminho \setwayis que
% acabara de ser constituído.
%
% Nesse contexto, para realizar a formação de parceria por combinação, o nó \servs
% executa o Algoritmo~\ref{algo:findPartnerCombinePath}.\\
%
% \begin{algorithm}[H]
% \label{algo:findPartnerCombinePath}
% \SetAlgoLined
% \KwData{\textit{relayPartners} \attrib [ ]}
%
% \SetKwFunction{Union}{Union}\SetKwFunction{make_pkt}{make\_pkt}
% \SetKwFunction{Union}{Union}\SetKwFunction{recv_pkt_rdt}{recv\_pkt\_rdt}
% \SetKwFunction{Union}{Union}\SetKwFunction{send_pkt_rdt}{send\_pkt\_rdt}
% \SetKwFunction{Union}{Union}\SetKwFunction{getKnownPaths}{getKnownPaths}
% \SetKwFunction{Union}{Union}\SetKwFunction{matchSimilarPath}{matchSimilarPath}
% \SetKwFunction{Union}{Union}\SetKwFunction{parse_path}{parse\_path}
% \SetKwFunction{Union}{Union}\SetKwFunction{length}{length}
%
% mspf \attrib 0.4\tcc*[r]{paths are considered similar if similarity level is
% equal or above mspf value}
% pathSet \attrib \getKnownPaths{}\tcc*[r]{get \setways known in this \serv}
%
% \ForEach{\setwayiu{x} $\in$ \setway}{
%   \If(){\matchSimilarPath{\setwayiu{x}, \setwayis} >= mspf}{
%     \tcc{Get the closest partner in the path (intersection between \setwayiu{x}
% and \setwayi) and add to the list of prospective partners for \repass.}
%
%     prosRelay = NULL\;
%     \ForEach{\ways $\in$ \setwayiu{x}} {
%       \If(){\ways $\in$ \setwayi} {
% 	\textit{relayPartners}[\length{relayPartners}] \attrib prosRelay\;
%       }
%     }
%   }
% }
%
% pkt $ \leftarrow$ make\_pkt(GMTP\_ADV\_RELAY(\textit{relayPartners}), \repass)\;
%
% send\_pkt\_rdt(pkt)\;
%
% \caption[matchPartnersByPathCombination(\setwayi,
% \repass)]{matchPartnersByPathCombination(\setwayi, \repass)}
% \end{algorithm}
% \vspace{0.8cm}

\section{Transmissão de \pks $\in$ \setpks através de \net}
\label{sec:asptransrecep}

QUANDO UMA ENTRADA É COLOCADA NA TABELA DE RECEPÇÃO DE FLUXOS DE DADOS, UM
BUFFER PARA P DEVE SER ALOCADO. ESSE BUFFER É BASEADO NA DESCRIÇÃO DA MÍDIA,
QUE VEM DENTRO DE REGISTER-REPLY.

No GMTP, a transmissão de dados é feita utilizando uma estratégia híbrida
\textit{pull/push} para obtenção do fluxo de dados \setpk. O método
\textit{push} é adotado como padrão, onde os nós \servs iniciam a
transmissão de \pks $\in$ \setpks para os demais nós \ways
$\in$ \setwayi, onde \wayu{1} $=$ \serv. Já o método \textit{pull} é utilizado
quando um nó \clis precisa obter parte de uma mídia que está na iminência de ser
reproduzida e ainda não foi repassada por um nó \repasss via \textit{push}, de
acordo com o seu mapa de \textit{buffer}. Os nós \repasss e \clis mantêm seus
próprios mapas de \textit{buffer}, sendo que um no \repasss sempre terá um mapa
de \textit{buffer} mais atualizado do que os mapas de \textit{buffer} dos nós
\clis $\in$ \subsetcli$($\repass$)$.

Nessa seção, apresentam-se detalhes sobre como se realiza a disseminação de
pacotes de dados \pks $\in$ \setpks e como os nós \clis recebem tal conteúdo
para reprodução, discutindo-se aspectos sobre indexação, requisição, recepção e
compartilhamento de um fluxo de dados \setpk.

\subsection{Indexação de Conteúdo}
\label{subsec:content-index}

O NOME DO FLOW SERÁ MD5(IP+PORTA) DO NÓ SA FONTE, O GERADOR DO VIDEO

No GMTP, um fluxo de dados \setpks tem um nome único que o identifica em
qualquer nó, seguindo o princípio das redes centradas no conteúdo. Na
prática, cada fluxo de dados \setpks corresponde a uma mídia gerada a partir de
um evento real \event, por exemplo, a transmissão de um jogo de futebol, corrida
de fórmula 1 etc.

No GMTP, define-se um nome de um fluxo de dados \setpks por um UUID
(\textit{Universally Unique IDentifier}) de 128 bits~\cite{RFC4122}. Na sua
forma canônica, \setpks é representado por uma sequência de 32
dígitos hexadecimal, exibidos em cinco grupos separados por hífen, na forma de
\{8\}-\{4\}-\{4\}-\{4\}-\{12\}. Por exemplo, \setpks $=$
641f931f-d3ac-50e3-b625-537574541f1f.

Na prática, a aplicação GMTP em execução no nó \serv, que é responsável por
gerar os pacotes de dados \pks $\in$ \setpk, define o identificador para um
fluxo de dados \setpks e o divulga através do serviço DNS. Já com relação ao
título do conteúdo e sua descrição, tais informações podem ser divulgadas por
meio de um serviço web, ou por meio de uma busca de diretório via um \textit{Web
Services}. Independente da forma que o nó \servs disponibilize os nomes dos
fluxos de dados \setpk, os nós \repasss mantém uma lista contendo os nomes dos
fluxos de dados que estão repassando para seus clientes \clis $\in$
\subsetcli$($\repass$)$ e, sendo assim, podem compartilhá-la para outros nós
repassadores, o que caracteriza um modelo distribuído de indexação de conteúdo.

De posse de um identificador de um fluxo de dados \setpk, um nó GMTP poderá
solicitar os pacotes de dados \pks $\in$ \setpk. No caso do uso do DNS, o nó
\servs divulga os identificadores de todos os eventos sendo transmitido
por meio de um mecanismo de atualização dinâmica de registro de DNS, como
especificado na RFC 2136~\cite{RFC2136}. Para o GMTP, criou-se um novo
tipo de registro de DNS chamado de SID (\textit{Streaming IDentifier}).

No Quadro~\ref{algo:requestDNS}, ilustra-se um exemplo de uma requisição DNS,
utilizando a ferramenta \textit{dig}, um comando de terminal para Linux. Nesse
exemplo, apresenta-se a lista dos nomes dos fluxos de dados transmitidos pelo
domínio administrativo \textit{globo.com}. Por ser uma consulta simples de DNS,
qualquer sistema final conectado à Internet pode realizar tal procedimento,
enaltecendo-se a facilitar de adaptar aplicações multimídia existentes para
utilizar o GMTP. Ao indexar o conteúdo através de um serviço de DNS, permite-se
desacoplar a forma de indexar um determinado conteúdo e a forma de obtê-lo, que
passa a ser de responsabilidade da infra-estrutura de rede e não de uma
ou mais aplicações isoladamente. Isto pode permitir o aumento em grandes
proporções das aplicações multimídia sem se preocupar como localizar um
determinado conteúdo, extrapolando-se as barreiras administrativos de cada
sistema de geração de conteúdos multimídia, bastante para isso apenas todos
passarem a adotar o GMTP (quando desejado).

\vspace{0.5cm}

\newcommand{\bigspace}{~~~~~}

\begin{algorithm}[H]
\label{algo:requestDNS}
\SetAlgoLined
\SetAlgorithmName{Quadro}{quadro}{.}

\caption{Exemplo de requisição e resposta da lista de nomes dos fluxos de dados
\setpks de um distribuidor de conteúdos multimídia.}

\textbf{dig} -t SID globo.com\\
\textbf{QUESTION SECTION:}\\
\bigspace globo.com.\bigspace IN\bigspace SID\\

\textbf{ANSWER SECTION:}\\
\bigspace globo.com.\bigspace IN\bigspace SID\bigspace
"111f931f-d3ac-10e3-b62f-f17f74541f1f"\\
\bigspace globo.com.\bigspace IN\bigspace SID\bigspace
"72c44591-7d82-427c-825f-722f015787c1"\\
\bigspace globo.com.\bigspace IN\bigspace SID\bigspace
"0bb0b9f5-f57d-4da5-8a6c-13acf1965188"\\

\textbf{SUMMARY:}\\
\bigspace Query time: 4 msec\\
\bigspace SERVER: 192.168.1.252:53(192.168.1.252)\\
\bigspace WHEN: Tue Jul 16 15:44:25 2013\\

\end{algorithm}
\vspace{0.8cm}

\subsubsection{Descrição de um fluxo de dados \setpk}
\label{subsubsec:desc-conteudo}

FALAR SOBRE MULTIPLE BIT-RATES

MPEG DASH - T. Stockhammer, Dynamic adaptive streaming over HTTP:
standards and design principles, ACM MMSys 2011

Como uma das principais motivação do GMTP é promover a compatibilidade entre
diferentes aplicações que o utiliza, afim de reduzir o tráfego de rede
para um mesmo fluxo, faz-se necessária uma forma flexível de permitir que
qualquer aplicação consiga reproduzir o fluxo de dados \setpk. Para isto,
incorporou-se um mecanismo para permitir que as aplicações consigam obter mais
detalhes sobre a mídia transmitida, flexibilizando-se o acesso a um
determinado conteúdo, instruindo a aplicação como o conteúdo deve ser
decodificado para ser reproduzido e consumido (escutado ou visualizado) pelo
usuário final. Nesse contexto, adotou-se o SDP (\textit{Session Description
Protocol}), definido na RFC 2327~\cite{RFC2327}, que permite um sistema final
servidor descrever, de forma padronizada, o conteúdo mídia, tornando possível
que os sistemas finais clientes possam interpretá-lo corretamente a fim de
reproduzí-lo para o usuário final.

No caso do GMTP, o nó \servs gera uma descrição SDP e envia para os nós \clis
$\in$ \setclis que, com base na descrição da mídia recebida, a interpreta e a
reproduzir para o usuário final. Com esta decisão, torna-se mais fácil
implementar novas aplicações multimídia, ao passo que também fica mais fácil
adaptar aplicações existentes para fazer uso do GMTP, uma vez que em sua grande
maioria, utiliza-se o protocolo SDP. Do ponto de vista de engenharia de
software, isto evitará a repetição de esforço com implementações já consolidadas
e que, com o passar dos anos, provou-se funcionar a contento, como o SDP.
Consequentemente, caso seja necessário a atualização do referido padrão, tal
atualização será realizada internamente no GMTP e todas as aplicações
automaticamente já poderão usufruir dos novos recursos disponibilizados.

Na prática, a aplicação em execução no nó \servs determina as informações da
mídia as fornecem ao GMTP, através de passagem de parâmetro via socket GMTP. Em
seguida, o GMTP gera um pacote do tipo \pac{GMTP-MediaDesc}, que encapsula o
conteúdo de descrição SDP e fica pronto para transmití-lo para o nó \repasss
interessado em obter o fluxo de dados \setpk, além de poder disseminá-lo para
seus nós parceiros \repassu{q}. No Quadro~\ref{algo:sdp-mediadesc}, apresenta-se
um exemplo de uma mensagem SDP, que deve ser disponibilizada no campo de dados
do pacote do tipo \pac{GMTP-MediaDesc}. Em seguida, apresenta-se o significado
de cada atributo de uma mensagem SDP.

\vspace{0.5cm}

\begin{algorithm}[H]
\label{algo:sdp-mediadesc}
\SetAlgoLined
\SetAlgorithmName{Quadro}{quadro}{.}

\bigspace v=0\\
\bigspace o=- IN IP4 177.135.177.241,
IP4 186.192.82.163, IP6 2001:0db8:85a3::7344\\
\bigspace s=72c44591-7d82-427c-825f-722f015787c1\tcc*[r]{ver
Seção~\ref{subsec:content-index}}
\bigspace i=An Introduction about Global Media Transmission Protocol (GMTP).\\
\bigspace u=http://www.ic.ufal.br/projects/gmtp/introduction.ps\\
\bigspace c=IN IP4 200.17.113.100\\
\bigspace f=x509:http://vid12.akamai.com/certs/cert.crt\tcc*[f]{ver
Seção~\ref{sec:seguranca}}\\
\label{line:sdp-mediadesc:f}
\bigspace m=audio 49170 GMTP/RTP/AVP 16000-20000\\
\bigspace m=video 51372 GMTP/RTP/AVP 163840-655360\\
\bigspace a=type:multicast\\
\bigspace a=sendrecv\\
\bigspace a=quality:10\\
\bigspace a=lang:en\tcc*[f]{ver RFC1766~\cite{RFC1766}}\\
\bigspace a=framerate:23.0\\

\caption{Exemplo de uma mensagem SDP no pacote \pac{GMTP-MediaDesc}.}
\end{algorithm}
\vspace{0.8cm}

\begin{itemize}

  \item \textit{v}, a versão do SDP;

  \item \textit{o}, a lista de nós \servs que a distribui;

  \item \textit{s}, o nome da mídia, como discutido na
Seção~\ref{subsec:content-index};

  \item \textit{i}, o título da mídia;

  \item \textit{u}, a URI que descreve detalhes sobre a mídia;

  \item \textit{c}, as informações de conexão, como o tipo da rede, a versão do
protocolo de rede e o endereço do nó \repass;

  \item \textit{f}, o certificado digital emitido pelo nó \servs para
verificação
de autenticidade dos pacotes \pks $\in$ \setpks (opcional). Este assunto
será retomado na Seção~\ref{sec:seguranca};

  \item \textit{m}, o tipo da mídia, a porta de conexão e protocolo de
transporte; e

  \item \textit{a}, atributos adicionais sobre a mídia como, por exemplo,
qualidade, idioma, taxa de bits mínima e máxima necessária para transmitir a
mídia, em bytes.

\end{itemize}

No exemplo apresentado no Quadro~\ref{algo:sdp-mediadesc}, utiliza-se a
primeira versão do protocolo SDP e descreve-se a transmissão de dois fluxos
\setpks (Linhas 10 e 11), sendo um deles de áudio e outro de vídeo.
A distribuição dos fluxos de dados \setpks ocorre com a geração dos pacotes de
dados \pks $\in$ \setpks em três nós \servs (Linha 2), dos quais dois são
acessíveis através de endereços IPv4 e um através de um endereço IPv6. Os fluxos
de áudio e vídeo são repassados por um nó \repass, acessível por um endereço
IPv4 (Linha 6), através das portas 49170 e 51372, respectivamente (Linhas 9 e
10). As informações de endereço IP e porta do nó \repasss são utilizadas para
que os nós \clis $\in$ \subsetcli$($\repass$)$ possam sintonizar seus sockets
de conexão e iniciar a reprodução da mídia, através do modo de transmissão
multicast (Linha 10). Em seguida, na Linha 8, observa-se uma URL do certificado
digital a ser utilizado pelo nó \repasss para verificar a autenticidade do
conteúdo de pacote de dados \pks $\in$ \setpks -- este assunto será discutido
com mais detalhes na Seção~\ref{sec:seguranca}. Por fim, entre as Linhas 11 e 17
especificam-se outros parâmetros para descrever a mídia, tais como o nível de
qualidade da mídia, que varia entre 1 e 10, as taxas de bits para cada fluxo de
dados, sendo para o áudio variando-se entre \ut{16000}{Bytes} e
\ut{20000}{Bytes} e, para o vídeo, variando-se entre \ut{156250}{Bytes} e
\ut{625000}{Bytes}. É importante salientar que os nós \repasss utilizam as
informações de taxa de bits para determinar o tamanho do buffer necessário para
permitir a transmissão da mídia -- este assunto será retomado na
Seção~\ref{subsec:trocdados}.

% Além
% disso, o tamanho do buffer é definido em consonância com os parâmetros
% determinados pelo algoritmo de controle de congestionamento executado no módulo
% GMTP-Inter, a ser discutido em detalhes na
% Seção~\ref{sec:ccgmtp}, a seguir.

\subsection{Estabelecimento de conexão e compartilhamento para obter \setpk}
\label{subsec:conexao-requisicao}

No GMTP, divide-se o processo de estabelecimento de conexão em três fases. A
Fase 1 acontece quando, por exemplo, um nó qualquer \cliu{1} $\in$
\subsetcli$($\repass$)$ deseja obter \setpks transmitido por um nó \servu{1} e
não existe nenhum outro nó \clis $\in$ \subsetcli$($\repass$)$ em sua rede local
recebendo \setpk. Já a Fase 2 acontece quando um outro nó \cliu{2} $\in$
\subsetcli$($\repass$)$ precisa obter o mesmo fluxo de dados \setpk, solicitado
previamente pelo nó \cliu{1}. E, por fim, a Fase 3 acontece quando o nó
\repasss começa a buscar novos nós parceiros \repassu{q} a fim de obter
\setpk.

Na Figura~\ref{fig:processo-conexao}, ilustram-se um nó \serv, que gera um fluxo
de dados \setpks e 12 nós \repass, que constituem uma rede de diferentes
domínios administrativos, sendo o nó \repassu{1} o repassador de um desses
domínios, composto por 6 nós \clis $\in$ \subsetcli$($\repass$)$ (Rede Local).

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=.7]{imgs/processo-conexao.pdf}
\end{center}
\vspace{-1cm}
\caption{Exemplo de rede para o estabelecimento de conexão do \mudccp.}
\label{fig:processo-conexao}
\end{figure}

A regra geral é que um nó \repasss deve consultar a tabela de recepção de fluxo
de dados (Seção~\ref{subsec:tabela-recepcao}) todas as vezes que receber um
pacote do tipo \pac{GMTP-Request} ou do tipo \pac{GMTP-Register}, transmitido
por um nó \clis $\in$ \subsetcli$($\repass$)$. Com base no estado da referida
tabela, que define a fase de conexão para um determinado fluxo de dados \setpks
solicitado, o nó \repasss realiza uma determinada ação de registro de
participação e repasse.

\subsection{Fase 1: primeira requisição a um fluxo de dados \setpk}
\label{subsec:conn-fase1}

A Fase 1 ocorre quando nenhum nó \clis $\in$ \subsetcli$($\repass$)$ está
recebendo um fluxo de dados \setpk. Com base na
Figura~\ref{fig:processo-conexao-1}, onde ilustra-se um exemplo
de conexão na Fase 1, considere:

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=.7]{imgs/processo-conexao-1.pdf}
\end{center}
\vspace{-1cm}
\caption{Passos do processo de estabelecimento de conexão do \mudccps (Fase 1).}
\label{fig:processo-conexao-1}
\end{figure}

\begin{itemize}

  \item \setpk, um fluxo de dados cujo nome é definido por:\\
\textit{72c44591-7d82-427c-825f-722f015787c1};

  \item \servu{1}, o nó servidor que gera os pacotes de dados \pks $\in$ \setpk;

  \item \repassu{1}, o nó repassador para os clientes \clis $\in$
\subsetcli$($\repassu{1}$)$; e

  \item \cliu{1}, um nó cliente que deseja obter um fluxo de dados \setpk, tal
que \cliu{1} $\in$ \subsetcli$($\repassu{1}$)$.

\end{itemize}

Para obter o fluxo de dados \setpk, o nó \cliu{1} inicia um canal de controle
GMTP (Seção~\ref{subsec:canaiscommudccp}), se ainda não criado, e transmite um
pacote do tipo \pac{GMTP-Request} (Figura~\ref{fig:processo-conexao-1}, Passo
1). Para construir o pacote do tipo \pac{GMTP-Request}, qualquer nó \clis deve
especificar o valor para o endereço IP de destino como sendo o endereço do nó
\servs que transmite \setpk, com o valor para o campo do cabeçalho de rede
\textit{TTL=1}. Alternativamente, o nó \clis pode especificar o endereço IP de
destino como sendo \textit{0.0.0.0}. Além dos valores para o IP de destino e
para o \textit{TTL}, o nó \clis também deve informar o nome do fluxo de dados
\setpks que o usuário deseja reproduzir, sendo tal informação incapsulada no
campo \textit{nome do fluxo de dados} (\textit{data flow name}), presente no
cabeçalho de transporte do pacote do tipo \pac{GMTP-Request}. Ao definir o
endereço IP de destino como sendo o IP de \serv, permite-se que o roteador
padrão de \cliu{1}, no caso o nó \repassu{1}, obter o endereço IP do nó \servs
sem precisar consultar o servidor DNS. Caso contrário, quando o IP especificado
for \textit{0.0.0.0}, o nó \repassu{1} deverá realizar tal consulta, como
discutiu-se na Seção~\ref{subsec:content-index}. Além disso, pelo valor de
\textit{TTL=1}, permite-se interceptar o referido pacote de requisição,
evitando-se extrapolar o domínio administrativo de tal rede local.

Na Fase $1$ de conexão, considera-se que não existe nenhum nó \clis $\in$
\subsetcli$($\repassu{1}$)$ recebendo o fluxo de dados \setpk. Sendo assim,
quando o pacote \pac{GMTP-Request} alcançar o nó \repassu{1} (Passo 2 da
Figura~\ref{fig:processo-conexao-1}), o nó \repassu{1} consulta a
tabela de recepção de fluxos de dados e constata que não há qualquer registro
para o fluxo de dados \setpk. Nesse instante, o nó \repasss inicia um
processo de registro de participação para obter o fluxo de dados \setpk, como
descreveu-se na Seção~\ref{subsec:registro-participacao}. Isto significa que a
execução do procedimento \textit{registerRelay(\serv, \pk)}, onde \pks é o
pacote do tipo \pac{GMTP-Request}, fará o nó \repassu{1} transmitir um pacote do
tipo \pac{GMTP-Register} em direção ao nó \servu{1}. À medida que os nós
\repasss repassam o pacote \pac{GMTP-Register} até alcançar o nó \servu{1},
constitui-se o caminho \setwayiu{1}
$=$
$\{$\repassu{1},\repassu{2},\repassu{3},\repassu{4},\repassu{5},\servu{1}$\}$
(Passo 3 da Figura~\ref{fig:processo-conexao-1} e destacado na cor vermelha),
conforme discutiu-se na Seção~\ref{sec:descparc}. É importante lembrar que,
pelos processos de formação de parcerias intra ou por combinação, descritos na
Seção~\ref{sec:descparc}, qualquer nó \repasss $\in$ \setwayiu{1} pode
interceptar o pedido de registro de participação enviado por \repassu{1}.

Em seguida, ao receber o pacote do tipo \pac{GMTP-Register-Reply}, como
resposta ao registro de participação, o nó \repassu{1} cria um canal
multicast e envia um pacote do tipo \pac{GMTP-RequestNotify} para um ou mais
clientes \clis $\in$ \subsetcli$($\repassu{1}$)$ (Passo 4 da
Figura~\ref{fig:processo-conexao-1}). Esta notificação sinalizará os nós
clientes \clis qual canal multicast seus respectivos sockets devem
ser ``sintonizado''. No caso do exemplo supracitado, o no \cliu{1}, após
sintonizar o socket no canal multicast informado pelo nó \repassu{1}, começa
a receber os pacotes de dados \pks do tipo \pac{GMTP-Data} ou \pac{GTMP-DataAck}
(Passo 5 da Figura~\ref{fig:processo-conexao-1}). Na
Seção~\ref{sec:asptransrecep}, discute-se em detalhes sobre os aspectos de
transmissão de pacotes do tipo \pac{GMTP-Data} ou \pac{GTMP-DataAck}.

No Algoritmo~\ref{algo:respondToClients}, resume-se os passos descritos
anteriormente para iniciar a transmissão dos pacotes de dados \pks $\in$ \setpks
aos nós \clis $\in$ \subsetcli$($\repass$)$, após \repasss receber o pacote do
tipo \pac{GMTP-RequestReply}. Note que, o nó \repasss invoca tal procedimento
nas Linhas~\ref{algo-line:respondToClients1} e~\ref{algo-line:respondToClients2}
do Algoritmo~\ref{algo:registerRelay} e nas
Linhas~\ref{algo-line:respondToClients3} e~\ref{algo-line:respondToClients4} do
Algoritmo~\ref{algo:onReceiveGMTPRegisterReply}
(Seção~\ref{subsec:registro-participacao}).

Como resultado da Fase 1, gera-se uma nova entrada na tabela de recepção de
fluxos de dados do nó \repass, tal como ilustra-se na
Figura~\ref{fig:tabela-recepcao-fluxo-11}. Com base no exemplo citado, a tabela
de recepção antes vazia, agora contém uma entrada que informa a ocorrência de
recepção do fluxo de dados \setpks $=$
\textit{72c44591-7d82-427c-825f-722f015787c1}, originado no nó \serv,
cujo endereço é \textit{177.135.177.241}, com porta de recepção \textit{49170}.
Além disso, define-se o canal multicast no endereço
\textit{239.192.68.79} e porta \textit{1900}, por onde os nós \clis $\in$
\subsetcli$($\repass$)$ podem receber os pacotes de dados \pks $\in$ \setpk.

\vspace{0.8cm}

\begin{algorithm}[H]
\label{algo:respondToClients}
\caption{respondToClients(\pk: \pac{GMTP-RequestNotify})}
\SetAlgoLined
\tcc{A \repasss node executes this Algorithm to respond to clients waiting for
receiving a flow \setpk. This algorithm is invoked in Lines~\ref{algo-line:respondToClients1}
and~\ref{algo-line:respondToClients2} of
Algorithm~\ref{algo:registerRelay} and in
Lines~\ref{algo-line:respondToClients3} and~\ref{algo-line:respondToClients4}
of the Algorithm~\ref{algo:onReceiveGMTPRegisterReply}.}

\SetKwFunction{Union}{Union}\SetKwFunction{getClientsWaitingForFlow}{getClientsWaitingForFlow}
\SetKwFunction{Union}{Union}\SetKwFunction{getCtrlChannel}{getCtrlChannel}
\SetKwFunction{Union}{Union}\SetKwFunction{getMediaDescription}{getMediaDescription}
\SetKwFunction{Union}{Union}\SetKwFunction{setPacketFieldValue}{setPacketFieldValue}
\SetKwFunction{Union}{Union}\SetKwFunction{getPacketFieldValue}{getPacketFieldValue}
\SetKwFunction{Union}{Union}\SetKwFunction{sendPktRdt}{sendPktRdt}
\SetKwFunction{Union}{Union}\SetKwFunction{sendPkt}{sendPkt}
\SetKwFunction{Union}{Union}\SetKwFunction{waitAck}{waitAck}
\SetKwFunction{Union}{Union}\SetKwFunction{startRelay}{startRelay}
\SetKwFunction{Union}{Union}\SetKwFunction{removeClientsWaitingForFlow}{removeClientsWaitingForFlow}

% \clis \attrib \getPacketFieldValue{\pk, `client'}\;
\textit{destAddress} \attrib \getCtrlChannel{}\tcc*[r]{238.255.255.250:1900}
\setPacketFieldValue{\pk, `destinationAddress', destAddress}\;
\textit{\setpk} \attrib \getPacketFieldValue{\pk, `flow'}\tcc*[r]{Extracts \setpks in \pk}

\textit{errorCode} \attrib \getPacketFieldValue{\pk, `errorCode'}\;
\If(){errorCode $\neq$ NULL} {
  \removeClientsWaitingForFlow{\setpk}\tcc*[r]{See Algorithm~\ref{algo:registerRelay}}
  \sendPkt{\pk}\;
  \Return{0}\;
}

\textit{channel} \attrib \getPacketFieldValue{\pk, `channel'}\;
\label{algo-line:respondToClients-getChannel}
\uIf () {\textit{channel} $\neq$ NULL} {
  \tcc{Node \repasss is already receiving \setpks and clients \subsetcli$($\repass$)$ must know the media description.}
  \textit{mediaDescription} \attrib \getMediaDescription{\setpk}\;
  \setPacketFieldValue{\pk, `data', mediaDescription}\;
  \tcc{In Algorithm~\ref{algo:registerRelay}, Line~\ref{algo-line:addClientWaitingFlow}, \clis nodes are added in a list of clients waiting for flow \setpk. Now, \repasss notifies them, wait confirmation (ACKs) from them and start relaying \pks $\in$ \setpks to them through given channel.}
  \sendPkt{\pk}\;
  \subsetcli$($\repass$)$ \attrib \getClientsWaitingForFlow{\setpk}\;
  \waitAck{\subsetcli$($\repass$)$, \setpk}\;
  \label{algo-line:respondToClients-waitAck}
} \Else (\tcc*[f]{Let \subsetcli$($\repass$)$ know \repasss is waiting for registration.}) {
  \setPacketFieldValue{\pk, `waitingRegistration', true}\;
  \sendPkt{\pk}\;
}
\Return{0}\;

\end{algorithm}
\vspace{0.8cm}

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=.55]{imgs/tabela-recepcao-fluxo-11.pdf}
\end{center}
\vspace{-1cm}
\caption{Tabela de recepção de fluxos de dados após a Fase 1.}
\label{fig:tabela-recepcao-fluxo-11}
\end{figure}

\subsection{Fase 2: próximas requisições para obter \setpk}

A Fase $2$ de conexão ocorre quando futuras requisições para obter o
fluxo de dados \setpks são originadas por qualquer nó \clis $\in$
\subsetcli$($\repassu{1}$)$. Considerando o exemplo anterior, citado na Fase 1,
se um nó \cliu{2} $\in$ \subsetcli$($\repassu{1}$)$ também solicitar \setpk, o
nó \repassu{1} simplesmente informará o canal multicast correspondente ao fluxo
de dados \setpk, como ilustra-se na Figura~\ref{fig:processo-conexao-2}.
Para isto, o nó \repassu{1} intercepta a requisição do nó \cliu{2}, consulta a
tabela de recepção de fluxos de dados e dessa vez constata a recepção do fluxo
de dados \setpk, criando o pacote do tipo \pac{GMTP-Request-Reply}. Este
procedimento ocorre no registro de participação, especificamente no trecho de
código definidos entre as Linhas~\ref{algo-line:registerRelay-getP}-\ref{algo-line:registerRelay-returnChannel} do
Algoritmo~\ref{algo:registerRelay}. Em seguida, o pacote do tipo
\pac{GMTP-Request-Reply} é transmitido para o nó \cliu{2}, como descreve-se no
trecho de código entre as Linhas~\ref{algo-line:respondToClients-getChannel}-\ref{algo-line:respondToClients-waitAck} do
Algoritmo~\ref{algo:respondToClients}. Tal procedimento se repete para cada
novo nó \clis $\in$ \subsetcli$($\repassu{1}$)$ interessado em obter \setpk.

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=.6]{imgs/processo-conexao-2.pdf}
\end{center}
\vspace{-1cm}
\caption{Passos do processo de estabelecimento de conexão do \mudccps (Fase 2).}
\label{fig:processo-conexao-2}
\end{figure}

\subsection{Fase 3: busca por mais parceiros \repassu{q} para obter \setpk}


/////////////////////////////////


\subsection{Sobre o melhor caminho \setwayi}
\label{subsec:melhorcaminho}

LER ISSO DAKI E O QUE ESTÁ SENDO DESCRITO NESSA FASE 3. PENSAR NA IDÉIA DE QUANDO
O NO REPASS PROCURAR POR MAIS PARCEIROS, USAR
O CRITÉRIO COM CAMINHOS MAIS FOLGADOS (MAIORES TAXAS DE TRANSMISSÃO)
%
% \begin{algorithm}[H]
% \label{algo:findPartnerIntersectPath}
% \SetAlgoLined
% \caption{handleRegisterParticipation(\repass: PeerRelay, \pks $=$
% \pac{GMTP-Register})}
% \tcc{\servs executes this algorithm to handle the request for register of
% participation. It finds the first node \ways common to a known path \setwayis
% and the path \setwayiu{\repassconst_\repassi}. \setwayis is already used for
% transporting \setpks to node in $\delta($\way, \setwayi$)$, and
% \setwayiu{\repassconst_\repassi} is the path composed by all nodes in between
% \repasss and \serv. The packet \pks carries \setwayiu{\repassconst_\repassi} and
% the \setpks name.}
%
% \SetKwFunction{Union}{Union}\SetKwFunction{makePkt}{makePkt}
% \SetKwFunction{Union}{Union}\SetKwFunction{getPacketFieldValue}{getPacketFieldValue}
% \SetKwFunction{Union}{Union}\SetKwFunction{recvPktRdt}{recvPktRdt}
% \SetKwFunction{Union}{Union}\SetKwFunction{sendPktRdt}{sendPktRdt}
% \SetKwFunction{Union}{Union}\SetKwFunction{length}{length}
% \SetKwFunction{Union}{Union}\SetKwFunction{pathsContainingRelayByFlow}{pathsContainingRelayByFlow}
% \SetKwFunction{Union}{Union}\SetKwFunction{GMTPRegisterReply}{GMTPRegisterReply}
% \SetKwFunction{Union}{Union}\SetKwFunction{pathPriority}{pathPriority}
%
% \textit{\setpk} \attrib \getPacketFieldValue{\pk, `flow'}\tcc*[r]{Extracts \setpks in \pk}
% \textit{\setwayiu{\repassconst_\repassi}} \attrib \invert{\getPacketFieldValue{\pk, `path'}}\;
% \textit{\setwayiu{\setpkc}} \attrib \pathsContainingRelayByFlow{\repass, \setpk}\tcc*[r]{\setwayiu{\setpkc} $\subset$ \setway}
% % \tcc*[r]{For a given flow and all the known paths \setways in this \serv, get a sub set of paths used to transmit \setpk}
%
% \setwayiu{selected} \attrib \setwayiu{\repassconst_\repassi}\;
%
% \ForEach{\setwayis $\in$ \setwayiu{\setpkc}}{
%     \If() {\pathPriority{\setwayis > \setwayiu{selected}}} {
%       \setwayiu{selected} \attrib \setwayi\;
%     }
% }
%
% \ForEach{\ways $\in$ \setwayiu{selected}} {
%   \If(){\ways $\in$ \textit{\setwayiu{\repassconst_\repassi}}} {
%     \tcc{The node \ways is common in \setwayis and in \textit{\setwayiu{\repassconst_\repassi}}.}
%     \textit{done} \attrib \textit{true}\;
%     break\;
%   }
% }
%
%     \If(){\textit{done}} {
% %       \tcc{Create a \pac{GMTP-Response} and send it to \way. After receiving \textit{\pk}, \ways becomes a relay of the flow \setpk.}
% %       \pks \attrib \makePkt{\pac{GMTP-Response}(1), \ways}\;
%       \tcc{\servs stores \textit{\setwayiu{\repassconst_\repassi}} as a known path and replies to \repass, asking \ways to act as a relay for \setpk. \servs actives flag 'relay' of the \pac{GMTP-RegisterReply}.}
%       \setwayiu{\setpkc}[\length{\setwayiu{\setpkc}}] \attrib \textit{\setwayiu{\repassconst_\repassi}}\;
%       \Return{\GMTPRegisterReply{\way, relay=1}}\;
% %       \sendPktRdt(\pk)\;
% %       \exit{}\;
%     }
%
% \tcc{\servs must register \textit{\setwayiu{\repassconst_\repassi}} as a known path and reply to \repasss by accepting its connection request, since no node \ways is intersecting \textit{\setwayiu{\repassconst_\repassi}}. In this case, \servs starts the transmission of \pks $\in$ \setpks to \repass.}
% \setway[\length{\setway}] \attrib \textit{\setwayiu{\repassconst_\repassi}}\;
% \Return{\GMTPRegisterReply{\repass, relay=0}}\;
% % \pks \attrib \makePkt{\pac{GMTP-Response}(0), \repass}\;
% % \sendPktRdt(\pk)\;
%
% \end{algorithm}
% \vspace{0.8cm}

De acordo com os procedimentos empregados de seleção de nós, é possível obter
diferentes caminhos \setwayi, partindo-se de um nó \repasss para um nó \serv.
Por este motivo, é importante definir, a partir de um conjunto de caminhos
possíveis, qual é o melhor caminho a utilizar e ordená-los de acordo com a
prioridade de uso. Com isto, é possível obter \setpks a partir de múltiplos
\repasss e usar caminhos alternativos em caso de falha de algum caminho, por
exemplo, por desconexão. No GMTP, utiliza-se os seguintes critérios para
decidir entre um conjunto de caminhos \setway qual será o escolhido:

\begin{enumerate}
  \item Quanto mais o caminho \setwayis estiver próximo de ser um caminho
\setwayif; \label{i:c-waycomp}
  \item Menor número de nós \ways $\in$ \setwayi; \label{i:c-nnos}
  \item Escolha aleatória de \setwayis entre os \setways conhecidos.
\label{i:c-aleat}
\end{enumerate}

O critério~\ref{i:c-waycomp} é determinado através da verificação da condição
$\mid$\setwayi$\mid$ $=$ $ttl($\repass$,$\setwayi$)$, onde \textit{ttl} é uma
função que determina o número de saltos entre o nó \repasss até o nó \serv. Na
prática, pode-se determinar tal condição comparando-se quantos nós existem no
caminho \setwayis e o valor do campo TTL (\textit{Time-to-Live}), disponível no
cabeçalho de qualquer pacote IP. Este critério é o primário porque quanto mais
nós GMTP estiverem no caminho, maior será a possibilidade de interceptação
para obter um fluxo de dados \setpk. O critério~\ref{i:c-nnos} é determinado
pela contagem do número de \ways $\in$ \setwayi. O critério~\ref{i:c-aleat} é
utilizado em caso de não determinação do melhor \setwayis até o critério
anterior.

Note que no GMTP é possível que um nó \repasss tenha simultaneamente mais de um
nó parceiro \repassu{q}, porém não mais do que uma certa qualidade configurável
devido ao fato de que os pacotes \pks dos fluxos \setpks serem transientes,
portanto não faz sentido realizar muitas parcerias. No caso do GMTP, a
quantidade máxima padrão de parcerias que um nós \repasss realiza é $5$, valor
praticado em outros soluções similares para transmissão de fluxos de dados ao
vivo baseados em arquitetura P2P.



/////////////////////////////////





Na Fase $3$, o nó \repasss inicia um processo de aumentar suas parcerias a fim
de obter mais rapidamente os pacotes \pks $\in$ \setpks e caminhos \setways alternativos
em caso de falha e/ou desconexões de algum nó parceiro \repassu{q}. Ao
considerar os aspectos discutido na Seção~\ref{sec:descparc}, nota-se que na
Fase $1$ e $2$ utiliza-se os modos de formação de parcerias intra \setways e por
intersecção, porém ainda resta fazer uso do modo de formação de parceria por
combinação de \setway
(Figura~\ref{fig:esquema-abstrato-formacao-parceria-combinacao}). Na fase $3$ de
conexão, o GMTP explora tal recurso.

Nesse contexto, seja um nó \repassu{3} que esteja recebendo \setpks originado
em um nó \serv. Para conseguir mais nós parceiros \repassu{q}, o nó \repassu{3}
envia uma requisição do tipo \pac{GMTP-RelayQuery} para \servs e obtém um
subconjunto de nós \repasssu{q} candidatos a parceiro de \repassu{3}, como
ilustrado na Figura~\ref{fig:conn-phase3-1}. Note que a lista de nós parceiros
enviada pelo nó \servs é construída usando o
algoritmo~\ref{algo:findPartnerCombinePath} e,
portanto, os nós \servs funcionam como um indexador (\textit{tracker}) de nós
parceiros \repassu{q}, executando uma pré-seleção de nós parcerios para
\repassu{3}. Esta pré-seleção ajuda o nó \repassu{3} a selecionar os melhores
parcerios disponíveis, de acordo com os critérios definidos
em~\ref{subsec:melhorcaminho}.

Diante do exposto, faz-se necessário registrar três procedimentos importantes
realizados pelo GMTP na Fase $3$:

\begin{enumerate}

  \item um nó \repasss pode enviar periodicamente requisições do tipo
\pac{GMTP-RelayQuery} para o servidor a fim de descobrir melhores parceiros e
aumentar seu leque de opções. Apesar disso, a quantidade de possíveis parcerios
de um nó \repasss não significa, necessariamente, que tal nó mantém a mesma
quantidade de parcerias efetivas para obter um fluxo de dados \setpk. Os
parâmetros de periodicidade de requisições do tipo \pac{GMTP-RelayQuery} e a
quantidade máxima de parcerias efetivas pode ser alteradas pelo administrador
de \repasss e tem valores padrões de 10 minutos e 5 nós, respectivamente;

  \item como ilustra-se na Figura~\ref{fig:conn-phase3-2}, apenas na Fase $3$,
permite-se requisições do tipo \pac{GMTP-Request} partindo de um nó
\repassu{\repassi_{3}} em direção a outro nó \repassu{\repassi_{2}}, que irá
enviar um resposta do tipo \pac{GMTP-Response} se \repassu{\repassi_{1}} enviar
uma chave secreta aceita por \repassu{\repassi_{2}} e encaminhada para
\repassu{\repassi_{1}} pelo nó \serv, que a obteve de \repassu{\repassi_{2}} no
processo de registro de participação discutido na
Seção~\ref{subsec:registro-participacao}. Note que nesse caso, mesmo se nó
\repassu{\repassi_{2}} não estiver recebendo o fluxo de dados \setpks de
interesse de \repassu{\repassi_{1}}, o nó \repassu{\repassi_{2}} deve
estabelecer uma conexão (Fase 1) para obtê-lo e então repassar \setpks para
\repassu{\repassi_{1}};

  \item como se considera uma arquitetura híbrida P2P/CDN, o nó \servs pode
facilmente realizar um mecanismo de balanceamento de carga, incluindo na lista,
como se fosse um nó \repass, um outro nó \serv, levando-se em consideração,
inclusive, todos os critérios estabelecidos na
Seção~\ref{subsec:melhorcaminho}.

\end{enumerate}

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=0.9]{imgs/gmtp-conn-phase3-1.pdf}
\end{center}
\vspace{-1cm}
\caption{Fase 3 de conexão do GMTP (Passo 1).}
\label{fig:conn-phase3-1}
\end{figure}

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=0.9]{imgs/gmtp-conn-phase3-2.pdf}
\end{center}
\vspace{-1cm}
\caption{Fase 3 de conexão do GMTP (Passo 2).}
\label{fig:conn-phase3-2}
\end{figure}










\subsection{Manutenção da conexão}
\label{subsec:manutencao-conexao}

Note que, por serem pacotes de
controle, estes pacotes são transmitidos com garantia de entrega, similar ao
mecanismo adotado pelo TCP.

Após o registro de participação, o nó \repasss deve enviar periodicamente
sinalizações de controle (\textit{polling}) sobre sua participação na rede de
favores $\eta$. Este procedimento deve ser feito usando o pacote do tipo
\pac{GMTP-Ack} em um tempo $t = max(300, t_{user}) - RTT$, onde $t$ e $RTT$ são
definidos em segundos, e $t_{user}$ é um parâmetro de tempo definido pelo
usuário. Quando \servs receber um pacote do tipo \pac{GMTP-Ack} do nó \repass,
este deve enviar um pacote do mesmo tipo. Caso \repasss não receba
\pac{GMTP-Ack} no período de $4 \times RTT$, deve-se repetir tal procedimento
por no máximo 3 vezes, quando \repasss deve considerar a conexão finalizada por
tempo de expiração (\textit{timeout}) e enviar um pacote do tipo
\pac{GMTP-Reset}. Na RFC 5482~\cite{RFC5482}, discute-se sobre outros aspectos
de expiração no tempo que podem ser adaptadas para o GMTP.


\subsection{Compartilhamento de \setpks entre \servs}
\label{subsec:compartilhamento-de-p}

Além do processo transparente para se obter um fluxo de dados \setpks
empregado
no GMTP, como os nós \servs constituem uma rede CDN, estes podem negociar entre
si o envio e a recepção de um fluxo de dados \setpks de acordo com as
requisições submetidas aos nós \repass. Desta forma, se um nó \repasss enviar
uma requisição para obter \setpks de um evento \events a um nó \servs e este não
esteja recebendo tal fluxo, \servs poderá solicitá-lo a outros nós \servs da
CDN que participa. A partir desse ponto, o nó \servs passará a servir o nó
\repasss normalmente. Como no GMTP se faz uso indireto dessa função das redes
CDNs, a qual já está consolidada, resolveu-se suprimir maiores detalhes a
respeito deste assunto. Para maiores informações sobre a função de distribuição
de conteúdos ao vivo entre os servidores de uma rede CDN, o leitor pode
consultar as
referências~\cite{Nygren:2010:ANP:1842733.1842736,1250586,Pathan2008}.

\vspace{0.5cm}

Desta forma, o processo de conexão do GMTP é fundamental para a efetiva
distribuição de mídias ao vivo, pois permite-se que as aplicações compartilhem
fluxos de dados entre si, mesmo que tais aplicações não tenham sido
desenvolvidas pela mesma equipe. Esta unificação ajuda no processo de
distribuição do fluxo de dados \setpk, pois, na prática, até mesmo uma aplicação
\textit{standalone} e um objeto de vídeo imbutido em uma página Web podem obter
o mesmo fluxo de dados sem que estas conheçam um a outra. Como resultado,
reduz-se para 1 o número de transmissões para um mesmo fluxo de dados \setpks
destinados a uma mesma rede ou para um subconjuntos de redes adjacentes. Além
dessa diferença substancial, a forma de conexão do GMTP supre uma antiga
deficiência das soluções tradicionais de transmissão multicast, as quais os
nós clientes, camada de aplicação, tinham que se adaptar às configurações
estáticas dos canais multicast definidos pelo administrador de rede, e até os
próprios administradores de rede tinham que fazer tal configuração de forma
manual, que obrigatoriamente tem que ser realizada em todos os nós roteadores
de um determinado caminho. Até o presente momento, não se conhece nenhuma
solução que permita configuração dinâmica de canais multicast da forma que foi
explicada nesta seção, com benefícios diretos para a aplicação e para a rede,
fazendo-se uso dos recursos computacionais e de rede de forma mais apropriada,
como será discutido no Capítulo~\ref{cap:analisedesemp}.

\subsection{Envio e recebimento de \pks $\in$ \setpks em \net}
\label{subsec:trocdados}

Após o estabelecimento de conexão, os nós \repasss trocam dados entre si em modo
unicast a fim de obter \setpk, constituído de pacotes \pks do tipo
\pac{GMTP-Data} e \pac{GMTP-DataAck}. De forma similar, os nós \repasss
utilizam os mesmos tipos de pacotes para enviar \pks $\in$ \setpks para os nós
\cli, porém em modo multicast. Nesta seção, detalha-se como o GMTP executa as
funções para transmissão que, em ambos os casos, realiza-se controle de
congestionamento, sendo tal função descrita na Seção~\ref{subsec:ccgmtp}.

Após o processo de estabelecimento de conexão, o \mudccps entra no
estado de transmissão de dados. Se o \mudccps estiver em funcionamento em
um nó \servs ou em um \repass, o estado é o de \textit{transmitindo dados}, ao
passo que quando executado em um cliente o estado é o de \textit{recepção de
dados}. Nesta seção, discute-se o funcionamento do mecanismo de transmissão e
recepção de dados no \mudccp.

Para o transporte de dados da aplicação, um \servs ou um \repasss deve criar
pacotes do tipo \pac{GMTP-Data} ou o \pac{GMTP-DataAck} e enviá-los aos nós
\clis através do socket correspondente à conexão estabelecida. Embora o
protocolo \mudccps transmite dados sem garantia de entrega, em alguns casos,
dados de controle podem ser transmitidos de forma confiável. Nestes casos,
durante a transmissão de dados, um nó \mudccps utiliza-se do pacote do
tipo \pac{GMTP-Data} para enviar dados, ao passo que utiliza-se pacote
\pac{GMTP-Ack} para confirmar a recepção de pacotes, ou ainda, utiliza-se
\pac{GMTP-DataAck} para enviar pacotes de dados e ao mesmo tempo confirmar a
recepção de pacotes de dados vindos da direção oposta (\textit{piggyback}).

\subsubsection{Buffer de Envio e Recepção:}

A transmissão de um evento \events consiste no processo de disseminação
dos pacotes \pks $\in$ \setpks através dos nós interessados em obtê-lo. Para
isto, cada nó GMTP controla um buffer de envio e recepção no formato de uma
estrutura de dados do tipo array, onde cada posição é utilizada para armazenar
um pacote \pks (Figura~\ref{fig:buffer-envio-recepcao}). Ao receber \pk, um nó
GMTP armazena-o no buffer e posteriormente o entrega para a aplicação, que o
reproduz para o usuário final. Para o envio ou repasse de um pacote, o nó GMTP
consome os pacotes \pks do buffer e transmite para o(s) nós interessados, seja
em modo unicast e/ou em modo multicast. Isto porque é possível que um nó
\repassu{\repassi_{1}} repasse \pks para um outro nó \repassu{\repassi_{2}}
(unicast) ao mesmo tempo que \repassu{\repassi_{1}} pode repassar \setpks para
seus nós \clis (multicast).

O buffer de envio e recepção do GMTP tem seu tamanho definido no processo de
estabelecimento de conexão, sendo determinado um valor mínimo e um valor
máximo, sendo estes permanecendo fixos durante todo o ciclo de vida de uma
conexão GMTP. Essa decisão é importante porque permite um nó \repasss alocar
previamente o recurso necessário para um determido fluxo de dados \setpk. O
tamanho do buffer é especificado pelo nó \servs e sempre é propagado para os
demais nós no cabeçalho do pacote do tipo \pac{GMTP-MediaDesc}, como discutido
a seguir. Este aspecto é muito importante, pois a aplicação que deve tomar tal
decisão, de acordo com o tipo e formato da mídia a ser transmitida. Para o GMTP,
é importante apenas ter conhecimento sobre o tamanho do buffer para executar
ações de descarte de \pk.

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=0.76]{imgs/buffer-envio-recepcao.pdf}
\end{center}
\vspace{-1cm}
\caption{Exemplo da estrutura do buffer de envio e recepção de um nó GMTP com
tamanho de 17 \pk.}
\label{fig:buffer-envio-recepcao}
\end{figure}

\subsubsection{Mapa de \textit{Buffer}:}

O mapa de buffer do GMTP descreve o estado atual do buffer de envio e recepção
de um nó GMTP. Como ilustrado na
Figura~\ref{fig:mapa-buffer-envio-recepcao}, trata-se de uma estrutura de dados
binária que determina se um pacote \pks está ou não presente no buffer de um
respectivo nó GMTP.

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=0.76]{imgs/mapa-buffer-envio-recepcao.pdf}
\end{center}
\vspace{-1cm}
\caption{Exemplo do mapa de buffer de um nó GMTP com tamanho de 17 \pk.}
\label{fig:mapa-buffer-envio-recepcao}
\end{figure}

O mapa de buffer é utilizado por um nó GMTP para sinalizar seu atual estado com
relação a um determinado fluxo de dados \setpk. Um nó GTMP pode enviar o mapa de
buffer completo, como ilustrado na Figura~\ref{fig:mapa-buffer-envio-recepcao},
ou o mapa de buffer apenas dos \pks presentes ou ausentes. Na prática,
um nó \repasss envia para um nó parceiro \repassu{q} o mapa de buffer dos \pks
presentes quando deseja indicar a sua atual disponibilidade; ao passo que envia
o mapa de buffer dos \pks ausentes quando desejar obtê-los. Para diferençar o
tipo de requisição, utiliza-se uma sinalização binária (\textit{flag}) chamada
\textit{request-type}, onde $0$ significa que o mapa de buffer contém pacotes
disponíveis e $1$, pacotes ausentes;

As trocas do mapa de buffer entre os nós GMTP ocorrem sob demanda, utilizando o
método \textit{pull}, uma vez que o método \textit{push} é utilizado por padrão.
Neste caso, quando um nó \repasss percebe a falta de um ou mais pacotes \pk,
este pode solicitar a um ou mais nós \repasss os pacotes \pks ausentes e então
obtê-los usando o método \textit{pull}. Para isso, um nó \repasss enviar aos
seus nós parceiros \repasssu{q} o mapa de buffer dos pacotes \pks ausentes e
aguarda as respostas sobre tal disponibilidade. Essa sinalização ocorre através
do uso do pacote do tipo \pac{GMTP-DataPull-Request}, que é preenchido com o mapa
de buffer dos pacotes ausentes e transmitido aos respectivos nós parceiros. Ao
receber esse tipo de requisição, um nó parceiro avalia seu conteúdo e responde
com o pacote do tipo \pac{GMTP-DataPull-Response}, o qual contém o mapa de buffer
dos pacotes disponíveis, seguido dos pacotes \pks do tipo \pac{GMTP-Data}. Note
que os pacotes do tipo \pac{GMTP-DataPullRequest} e \pac{GMTP-DataPull-Response}
são transmitidos com garantia de entrega, ou seja, caso sejam perdidos, o GMTP
garante sua retransmissão. Para isto, o GMTP utiliza o mecanismo básico de
envio e confirmação utilizando o pacote do tipo \pac{GMTP-DataAck} ou
\pac{GMTP-DataAck}. No caso de falha na execução de uma requisição utilizando o
método \textit{pull}, o nó GMTP pode reavaliar a necessidade de retransmitir o
pedido, pois é possível que os \pks ausentes já tenham sido expirados e
requisitá-los novamente não fará mais sentido.

Na prática, o mapa de buffer utilizado para sinalizar a presença ou ausência de
\pks é representado por faixas de acordo com o índice do buffer. Por exemplo,
para representar o mapa de buffer dos pacotes ausentes ilustrados na
Figura~\ref{fig:mapa-buffer-envio-recepcao}, o nó GMTP preenche o pacote do
tipo \pac{GMTP-DataPull-Request} com a sequencia \textit{2;6-10;12}. Ao receber
esta sequência, o nó parceiro \repasssu{q} responde com o pacote do tipo
\pac{GMTP-DataPull-Response}, que contém o mapa de buffer de quais
pacotes serão enviados e começa a transmití-los.

% * RELATAR TAXA DE RECEPCAO	- NO RELATA QUAL A TAXA DE RECEPÇÃO
% (PREENCHIMENTO+ATUALIZAÇÃO DO BUFFER)
% * USA ESSA INFO PARA SELECIONAR OS MELHORES PARCEIROS (FILTRO APRIMORADO)

\subsubsection{Descarte de pacotes:}

O descarte de pacotes \pks ocorre sempre no nó \repasss e em duas situações:

\begin{enumerate}

 \item \textbf{Por transbordo do buffer:} descartar os primeiros pacotes \pks
recebidos se o buffer alcançou seu limite, mesmo que ainda não tenham
sido repassados. Uma otimização não explorada neste trabalho, mas que é
possível de ser realizada, é o descarta seletivo de pacotes, primeiro os que
tenham menos impacto na qualidade da mídia, por exemplo, pacotes de dados
contendo quadros B (codificação mpeg). Isto não impede que o vídeo seja
reproduzido, porém com perda de qualidade, ao passo que permite-se a transmissão
de conteúdo com os recursos disponíveis;

 \item \textbf{Por duplicação:} ocorre quando o pacote \pks já foi recebido
anteriormente. Tal verificação é feita de acordo com o número de sequência
presente em cada pacote \pk.

\end{enumerate}


\section{Controle de Congestionamento em \net}
\label{sec:ccgmtp}

LER O COMENTÁRIO EM \label{subsec:tabela-recepcao} SOBRE SEGMENTAÇÃO DO CAMINHO

No \mudccp, disponibiliza-se um arcabouço para adição de novos algoritmos de
controle de congestionamento de forma modularizada. Desta forma, permite-se a
adição e remoção de novos algoritmos de controle de congestionamento.
Atualmente, o GMTP oferece dois algoritmos, um voltado para transmissões em modo
unicast e outro voltado para transmissões em modo multicast.

Na prática, definiu-se um algoritmo para controle de congestionamento híbrido,
cujo comportamento dependerá se o nó que o executa está transmitindo em modo
unicast ou em multicast. Em modo de transmissão unicast, utilizado na
comunicação entre os nós \repass, define-se a taxa de transmissão de um nó
\mudccps através de um algoritmo de janela deslizante baseado em uma equação
cúbica, com suporte aos protocolos RCP~\cite{REF} e ConEx~\cite{REF}. Já em modo
de transmissão multicast, executa-se um algoritmo baseado em relatórios
transmitidos pelos nós \rel, eleitos em cada rede controlado por um nó \repass,
tal que \rels $\in$ \subsetcli$($\repass$)$. Como ilustrado na
Figura~\ref{fig:ucc-mcc-esquema}, para a parte do algoritmo que funciona em modo
unicast, dar-se o nome de \textit{\mudccps Unicast Congestion Control}
(GMTP-UCC), ao passo que para a parte do algoritmo que funciona em modo
multicast, dar-se o nome de \textit{\mudccps Multicast Congestion Control}
(GMTP-MCC).

\begin{figure}[htb!]
\begin{center}
\includegraphics[scale=.7]{imgs/ucc-mcc-esquema.pdf}
\end{center}
\vspace{-1cm}
\caption{Organização do algoritmo de controle de congestionamento no \mudccp.}
\label{fig:ucc-mcc-esquema}
\end{figure}

\subsection{Controle de Congestionamento Unicast}
\label{subsec:mudccp-ucc}

O \mudccp-UCC funciona de forma similar ao protocolo RCP (Rate Control
Protocol)~\cite{Dukkipati:2008:RCP:1368746}, porém com alguns diferenciais a
serem discutidos a seguir. O RCP é um protocolo para controle de
congestionamento assistido pela rede que tenta emular um Comutador
Compartilhado, ou \textit{Processor Sharing} (PS), por exemplo, um
roteador~\cite{Dukkipati:2005:PSF:2103175.2103204}. Nesse caso, se um roteador
pudesse obter a informação exata sobre o número de fluxos de entrada em um
instante $t$, a taxa de transmissão ideal para cada fluxo de dados seria
$R_{ps}(t) = \frac{C}{N(t)}$, onde $C$ corresponde à capacidade do link e $N(t)$
ao número de fluxos no instante $t$.

Dessa forma, Nandita et. al\cite{Dukkipati:2008:RCP:1368746} argumenta que para
um roteador funcionar de forma equânime, tal roteador deve oferecer a
mesma taxa de transmissão para todos os fluxos transmitidos através dele,
mantendo-se o número de pacotes na fila de roteamento perto de zero, a fim de
evitar que apenas os fluxos que tem pacotes na fila de repasse compartilhem a
largura de banda disponível. Com base nisso, Nandita et.
al\cite{Dukkipati:2008:RCP:1368746}
determinou a Equação~\ref{eq:cc-rcp-teoria}, onde $R(t)$ é a taxa de transmissão
que deve ser oferecida para cada fluxo de dados que passa pelo roteador. Pela
Equação~\ref{eq:cc-rcp-teoria}, estima-se a largura de banda disponível
em um determinado canal, representado pela porção $\alpha(C - y(t)) - \beta
\frac{q(t)}{d_0}$ (mudança agregada) e a divide por $N(t)$. Porém, como é
impossível determinar o valor exato de $N(t)$, estima-se $\hat{N}(t) =
\frac{C}{R(t-T)}$ e para atualizar $R(t)$ com mais frequência do que no tempo de
um RTT, escala-se a mudança agregada por $\frac{T}{d_0}$, resultando na
Equação~\ref{eq:cc-rcp}, onde:

  \begin{equation}
  R(t) = R(t - d_0) + \frac{\alpha(C - y(t)) - \beta
\frac{q(t)}{d_0}}{\hat{N}(t)}
  \label{eq:cc-rcp-teoria}
  \end{equation}

  \begin{equation}
  R(t) = R(t -T) \left[1+\frac{\frac{T}{d_0}\left(\alpha(C - y(t)) -
\beta \frac{q(t)}{d_0}\right)}{C}\right]
  \label{eq:cc-rcp}
  \end{equation}

  \begin{itemize}

    \item $d_0$, é a média móvel dos valores de $RTT_{s}$, calculada através da
Equação~\ref{eq:calcrtt-rcp}, onde $\theta$ é o ganho e corresponde a $0.02$.
Note que quanto maior o valor de $\theta$, mais rápida será a convergência de
$d_0$ ao valor de $RTT_{s}$.

      \begin{equation}
      d_0 = \theta \times RTT_{s} + (1 - \theta) \times d_0
      \label{eq:calcrtt-rcp}
      \end{equation}

    \item $T = min(RTT_{user}$, $d_0))$, sendo $RTT_{user}$ um tempo definido
pelo usuário caso seja necessário atualizar $R(t)$ mais rápido do que o tempo de
$d_0$;

    \item $R(t - T)$, é a última taxa de transmissão medida;

    \item $y(t)$, é a taxa de tráfego de entrada medida no intervalo entre a
última atualização da taxa de transmissão e $d_0$;

    \item $q(t)$, é o tamanho instantâneo da fila de repasse, em bytes;

%     \item $\hat{N}(t)$, é uma estimativa do número de fluxos em um tempo $t$,
% por exemplo, o número de fluxos enviando pacotes de dados \pk;

    \item $\alpha$ e $\beta$, são parâmetros pré-definidos que determinam
a estabilidade e o desempenho;

    \item $C$, é a capacidade do link.

  \end{itemize}


No GMTP-UCC, o algoritmo para controle de congestionamento, adaptado do
RCP, funciona da seguinte forma:


\begin{enumerate}[{\tab}1$^{\circ}$]

  \item Todo nó \repasss mantém uma única taxa de transmissão $R(t)$, que é
oferecida para todos os fluxos de dados passando por \repasss em um certo
instante $t$. Cada nó \repasss atualizada $R(t)$ aproximadamente a cada RTT.
  \label{step:rcp-gmtp-0}

  \item Todo pacote dos tipos \pac{GMTP-Ack}, \pac{GMTP-Data} ou
\pac{GMTP-DataAck} carrega duas informações de controle (campo no cabeçalho):
  \label{step:rcp-gmtp-1}
  \begin{itemize}

    \item \textit{taxa de transmissão proposta} ($R_{p}$):
corresponde à taxa de transmissão necessária para transmitir um fluxo de dados
\setpk, em geral, calculada pelo nó \serv;

    \item \textit{RTT na fonte} ($RTT_{s}$): corresponde ao RTT
estimado entre quaisquer nós \transu{\transi},\transu{\transi+1} $\in$
\setwayi, ou seja, o RTT entre dois nós \transu{\transi} e \transu{\transi+1}
que processam o respectivo pacote \pks de um fluxo de dados \setpk, a fim de
repassar aos seus nós \clis $\in$ $($\subsetcli(\trans) $\cup$
\subsetcli(\transu{\transi+1})$)$.

%     \item \textit{Diferença de RTT} (RTT$_{d}$): corresponde à diferença entre
% RTT$_{s}$ e o RTT medido entre dois nós \way. Por exemplo, seja um
% caminho \setwayis por onde o fluxo de dados \setpks é transmitido, com
% \waysu{1}=\space \servu{1}, \waysu{2}=\space \repassu{1}, \waysu{3}=\space
% \repassu{2} e \waysu{4}=\space \repassu{3}, tal que
% \wayu{1},\wayu{2},\wayu{3},\wayu{4} $\in$ \setwayi. Considere que o RTT entre
% \wayu{1} e \wayu{2} corresponda a um valor qualquer \textit{x}, o RTT entre
% \wayu{2} e \wayu{3} corresponda a um valor qualquer \textit{y} e o RTT entre
% \wayu{3} e \wayu{4} corresponda a um valor qualquer \textit{z}. Para esse caso,
% \wayu{1} deve especificar RTT$_{s}$ = \textit{x} e RTT$_{d}$ = 0, \wayu{2} deve
% especificar RTT$_{s}$ = \textit{x} e RTT$_{d}$ = \textit{y}; e \wayu{3} deve
% especificar RTT$_{s}$ =
% \textit{x+y} e RTT$_{d}$ = \textit{z}. Com isto, é possível que o nó
% \wayu{4} saiba qual é o RTT acumulado entre \wayu{1} até seu nó parceiro
% \wayu{3} (RTT$_{s}$) e também o RTT apenas entre \wayu{3} e \wayu{4}
% (RTT$_{d}$). Com essas informações expostas para cada nó \ways em um caminho
% \setway, qualquer nó \repasss poderá fazer uso de tais informações para decidir
% com quais nós devem fazer parcerias ou quais são seus melhores parceiros.

  \end{itemize}

  \item No início de uma transmissão de um fluxo de dados \setpk, o nó \servs
transmite um pacote \pks com o valor de $R_{p}$ correspondente à taxa de
transmissão desejada para transmitir o referido fluxo \setpk, com o valor para
$RTT_{s}$ = $\infty$. A taxa de transmissão desejada $R_{p}$ deve ser calculada
pela aplicação, de acordo com a taxa de bits da mídia a ser transmitida e
repassada à instância do GMTP no nó \serv.
  \label{step:rcp-gmtp-2}

  \item Todo nó \ways = \repasss que receber um pacote \pk, se $R(t) <
R_{p}$, então $R_{p} \leftarrow R(t)$, caso contrário nenhuma
modificação é realizada nesse campo. Nesse ínterim, se existir pelo menos um nó
\clis $\in$ \subsetcli$($\way$)$ interessado em obter os pacotes \pks $\in$
\setpks
(Seção~\ref{subsec:conexao-requisicao}), \ways executa as seguintes ações:
  \label{step:rcp-gmtp-3}

  \begin{enumerate}

    \item repassa \pks para seus nós \clis em modo multicast
(Seção~\ref{subsec:trocdados});

    \item cria um pacote \pac{GMTP-Ack} contendo $R_{p}$ e o envia de volta
para seu nó parceiro \repassu{q} $=$ \wayu{\wayi-1}. O pacote \pac{GMTP-Ack}
também carrega um campo de $RTT_{s}$. Quando \ways receber um pacote
\pac{GMTP-Ack}, deve-se utilizar $RTT_{s}$ para atualizar a média móvel do RTT
no intervalo de $d_0$.

  \end{enumerate}

  \item O nó \ways deve usar $R_{p}$ como a nova taxa de transmissão para
enviar os próximos pacotes de dados \pks para seu nó parceiro \repassu{q} $=$
\wayu{\wayi+1}. Assim, $R_{p}$ é a menor taxa de transmissão oferecida ao
longo do caminho \setwayis no intervalo de $RTT_{s}$.

  \item Todo nó \repasss atualiza periodicamente sua taxa de transmissão local
$R(t)$ de acordo com a Equação~\ref{eq:cc-rcp}.

\end{enumerate}

Sendo assim, no caso do GMTP, a ideia básica é a seguinte: para quaisquer
dois nós \transu{1},\transu{2} $\in$ \setwayi, a taxa de transmissão a ser
utilizada por \transu{1} e \transu{2} será definida pela menor taxa de
transmissão oferecida pelos nós \ways $\in$ \setwayis posicionados entre
\transu{1} e \transu{2}. Com isto, se existir largura de banda disponível entre
\transu{1} e \transu{2}, ou seja, $C - y(t) > 0$, então o GMTP compartilhará
igualmente o canal entre todos os fluxos, inclusive para o fluxo entre
\transu{1} e \transu{2}. Caso contrário, ou seja, se $C - y(t) < 0$,
considera-se o canal saturado e o GMTP reduzirá a taxa de transmissão igualmente
para todos os fluxos, inclusive para o fluxo entre \transu{1} e \transu{2}.
Especificamente, a largura de banda necessária para repassar todos os pacotes
\pks $\in$ \setpks que estão na fila de roteamento no intervalo de um RTT
corresponde à $\frac{q(t)}{d_0}$~\cite{Dukkipati:2005:PSF:2103175.2103204}.

% \subsubsection{Diferença entre o RCP e o GMTP-UCC}
%
% Como discutido, o RCP é um protocolo para controle de congestionamento
% fim-a-fim, % onde os sistemas finais de origem e destino se comunicam e trocam
% pac tes de ACK % para determinar a nova taxa de transmissão $R(t)$ que o nó
% transmissor deve  utilizar para transmitir um fluxo de dados \setpk. Porém, no
% caso do GMTP um nó % \repassu{1} tem como principal função repassar os pacotes
% de dados \pks $\in$ % \setpks do tipo \pac{GMTP-Data/DataAck} para seus nós
% parceiros \repass, em c so % de $\mid$\subsetcli$($\repassu{1})$\mid$ $>$ $0$
% para o fluxo de % dados setpk. Nesse interím, tais nós realizam ações para dar
% suporte ao % ecanismo de controle de congestionamento da rede, como por exemplo
% atualizar o % valor de $R_p$ e $RTT_s$. No RCP, o valor de $RTT_s$ é calculado
% pelo sistema  final de origem, mas no GMTP, quando um nó \repassu{1} forma uma
% parceria co % outros nós \repass, é como se \repassu{1} funcionasse como o nó de
% origem \se vs % e portanto também deveria atualizar o valor para $RTT_s$. Para
% isto, um nó % \repasss precisaria manter estado para cada fluxo de dados \setpk,
% o que % significa manter um temporizador para cada fluxo de dados \setpks %
% compart lhado. Do ponto de vista computacional, delegar tal responsabil dade %
% para um roteador seria uma atividade onerosa porque múltiplos fluxo de dados, %
% originados por diversas fontes \serv, podem passar por um roteador e facilment %
% este se tornaria um ponto de gargalo por ter que processar cada pacote, ca cular
% e atualizar o valor para $RTT_s$ para cada um deles.
%
% Diante desta questão, no GMTP-UCC, em vez de um nó \repasss manter o
% temporizador para cada fluxo de dados \setpk, os nós relatores \rels, tal
% que \rels $\in$ \subsetcli$($\repass) são responsáveis por tal atividade. Isto
% significa que um nó cliente \cli=\rel, localizado na rede de \repass,
% realizará a computação para obter o valor de $RTT_s$, bastando o nó \repasss
% notificar qual nó \rels será responsável por manter tal estado. Isto só é
% possível porque quando um nó \repasssu{1} se torna parceiro de outro nó
% \repassu{2}, a condição $\mid$\subsetcli$($\repassu{1})$\mid$ $>$ $0$ é
% satisfeita para um fluxo de dados \setpk.

\subsubsection{Escolha do algoritmo RCP em detrimento ao XCP:}

Tanto o RCP quanto o XCP são os protocolos mais conhecidos do estado da arte
que tentam emular um PS e, por este motivo, suas equações de controle
de congestionamento são similares. Porém, o modo que o RCP e o XCP tentam
convergir as taxas de transmissão $R_{rcp}(t)$ e $R_{xcp}(t)$,
respectivamente, para emular a taxa de transmissão do PS, definida por
$R_{ps}(t)$, é bastante diferente. Dito isto, o grande dilema foi decidir qual
dos dois protocolos seria mais adequado para o GMTP-UCC. Para tomar tal
decisão, estudou-se a diferença entre tais protocolos e decidiu-se utilizar o
RCP, de acordo com o que se discute a seguir.

Especificamente, a diferença está no tipo de informação enviada para um nó
transmissor de um fluxo de dados para atualizar o valor de $R_{rcp}(t)$
ou de $R_{xcp}(t)$. O XCP continuamente tenta convergir a taxa de transmissão
para um ponto de equilíbrio onde todos os transmissores transmitirão pacotes de
dados a uma taxa de transmissão $R_{xcp}(t)$, ao passo que o RCP calcula uma
única taxa de transmissão que deve ser utilizada por todos os nós transmissores
em um certo instante \textit{t}. Apesar dessa diferença suscinta, deve-se
entender minuciosamente o que isto significa.

No caso do XCP, o protocolo aumenta ou diminui a janela de congestionamento de
um fluxo de dados de acordo com o tamanho atual da sua janela de
congestionamento. Isto ocorre porque o XCP reduz gradativamente os tamanhos da
janela de congestionamento dos fluxos com $R_{xcp}(t)$ maior do que o
$R_{ps}(t)$ estimado, aumentando-se gradativamente o tamanho das janelas de
congestionamento dos fluxos com $R_{xcp}(t)$ menor do que $R_{ps}(t)$ estimado.
Porém, o tamanho da janela de congestionamento é sempre menor para os fluxos
iniciados mais recente. Assim, em qualquer momento, os fluxos XCP podem ter
diferentes tamanhos de janela de congestionamento e de RTTs, portanto diferentes
taxas de transmissão $R_{xcp}(t)$, resultando em valores para $R_{xcp}(t)$ não
equânimes para todos os fluxos de dados.

Já no RCP, todos os fluxos (novos e antigos) recebem a mesma taxa de transmissão
$R_{rcp}(t)$ baseada no estado atual do nó \repasss com menor largura de banda
disponível em um certo instante $t$. Isto permite que um fluxo de dados de
curta duração termine o mais rápido possível ao passo que os fluxos de dados
mais longos não influenciam diretamente no compartilhamento equânime do PS, sem
permitir que parte da largura de banda disponível fique ociosa por muito tempo.
Este procedimento ocorre em um intervalo de tempo definido por $d_0$ que, no
caso do GMTP, tal vamor não é definido entre o nó \servs e o nó
\cli, como na versão original do RCP. Em vez disso, o tempo $d_0$ é definido
entre dois nós \repasss consecutivos em um caminho \setwayi, tal que \repasss
$\in$ \settrans.

O XCP é computacionalmente mais complexo do que o RCP, uma vez que o
XCP define diferentes valores de \textit{feedback} para cada fluxo, envolvendo
operações matemáticas (multiplicação e soma) para cada pacote, o que torna o XCP
mais lento que o RCP. Pela estratégia de mudança no tamanho da janela de
congestionamento, o XCP pode leva múltiplos RTTs para a maioria dos fluxos
alcançarem a taxa de transmissão equânime entre eles, mas que mudam com o passar
do tempo à medida que novos fluxos são injetados na rede e outros são
finalizados, devido à natureza dinâmica das redes. No caso do RCP, essa
complexidade é menor e há uma redução significativa de convergência entre o
taxa de transmissão praticada $R_{rcp}(t)$ e a $R_{ps}(t)$. Isto porque
mantém-se uma única taxa de transmissão para todos os fluxos, não envolvendo
qualquer computação adicional por pacote \pks que passa por \repass. Além
disso, para determinar $R_{rcp}(t)$, necessita-se apenas o tamanho da fila e da
taxa agregada de entrada, sem necessitar manter estado por fluxo de dados e
operações matemáticas por pacote de dados.

Desta forma, os aspectos que determinam o funcionamento do RCP são fundamentais
quando se trata de transmissão de conteúdos multimídia ao vivo, aliado às outras
estratégias adotadas no GMTP para a distribuição de conteúdos multimídia ao
vivo. Isto porque, ao tempo que o RCP define uma taxa de transmissão equânime
para todos os fluxos, sua reação é rápida às mudanças circunstanciais na rede,
tanto para uma super-utilização de um canal quanto para a sua sub-utilização.
Como o RCP escala naturalmente com relação à capacidade de transmissão do canal
e ao RTT, o seu desempenho é invariante com relação ao tamanho de um fluxo,
portanto não importa qual tipo de fluxo as aplicações geram (se de curta ou de
longa duração; independente de qualquer protocolo de transporte). Com isto,
permite-se que fluxos de dados GMTP+RCP e TCP+RCP coexistam na Internet de forma
equânime, aliado às funções do GMTP de distribuição de conteúdo assistida pela
rede, evitando-se sobrecarga nos nós \serv, como discutiu-se anteriormente.

Ao perceber essa diferenças, nandita et al. PLATAR O GRÁFICO

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=0.25]{imgs/rcp-vs-xcp-vs-tcp.png}
\end{center}
\vspace{-1cm}
\caption{Tempo médio, em segundos, de finalização de um fluxo de dados, ao
utilizar os protocolos XCP, TCP e RCP, para C = \ut{2.4}{Gbps}. Os fluxos foram
injetados na rede com base na distribuição pareto, com E[L] = \ut{25}{pacotes} e
shape = 1.2. Extraído de~\cite{Dukkipati:2005:PSF:2103175.2103204}.}
\label{fig:mapa-buffer-envio-recepcao}
\end{figure}

~\cite{4460574}. O artigo está na area de trabalho
% http://ieeexplore.ieee.org/xpl/login.jsp?tp=&arnumber=4460574&url=http%3A%2F%2Fi
% eeexplore.ieee.org%2Fiel5%2F90%2F4359146%2F04460574.pdf%3Farnumber%3D4460574

Achieving efficient and fair bandwidth allocation while minimizing packet loss
and bottleneck queue in high bandwidth-delay product networks has long been a
daunting challenge. Existing end-to-end congestion control (e.g., TCP) and
traditional congestion notification schemes (e.g., TCP+AQM/ECN) have significant
limitations in achieving this goal. While the XCP protocol addresses this
challenge, it requires multiple bits to encode the congestion-related
information exchanged between routers and end-hosts. Unfortunately, there is no
space in the IP header for these bits, and solving this problem involves a
non-trivial and time-consuming standardization process. In this paper, we design
and implement a simple, low-complexity protocol, called variable-structure
congestion control protocol (VCP), that leverages only the existing two ECN bits
for network congestion feedback, and yet achieves comparable performance to XCP,
i.e., high utilization, negligible packet loss rate, low persistent queue
length, and reasonable fairness. On the downside, VCP converges significantly
slower to a fair allocation than XCP. We evaluate the performance of VCP using
extensive ns2 simulations over a wide range of network scenarios and find that
it significantly outperforms many recently-proposed TCP variants, such as HSTCP,
FAST, CUBIC, etc. To gain insight into the behavior of VCP, we analyze a
simplified fluid model and prove its global stability for the case of a single
bottleneck shared by synchronous flows with identical round-trip times.



%
% =====>> PAREI AQUI. LER O ARQUIVO http://yuba.stanford.edu/rcp/RCP-IWQoS.pdf,
% SEÇÃO 2.2
%
% Rate Control Protocol (RCP) is a congestion control algorithm designed for fast
% download times (i.e. aka user response times, or flow-completion times). Whereas
% other modifications to TCP (e.g. STCP, Fast TCP, XCP) are designed to work for
% specialized applications that use long-lived flows (scientific applications and
% supercomputer centers), RCP is designed for the typical flows of typical users
% in the Internet today. For example, a mid-size flow in the Internet today
% contains 1000 packets and TCP typically makes them last 10x longer than need-be
% (XCP is even worse). RCP makes flows finish close to the minimum possible,
% leading to a perceptible improvement for web users, distributed computing, and
% distributed file-systems. We believe RCP is the only congestion control
% algorithm to do this.
% The main properties of RCP are:
%
% Typical Internet flows will see 10 times faster download times than TCP and 30
% times faster than XCP. Winners are the greater than 90% of sessions that never
% leave slow-start today.
% Efficiently uses high bandwidth-delay product networks such as the long haul
% optical links
% Provably stable network independent of link-capacities, round-trip times and
% number of flows
% Flows are easy to police, to ensure they adhere to congestion control (not
% generally possible with other schemes)
% Network operators can give preference (or weighted preference) to some
% flows/aggregates.
% RCP has two components: (1) End-host congestion control layer that sits between
% IP and TCP/UDP. During introduction, the end-host could adapt by testing for RCP
% at each end and along the path, falling back to TCP if need-be. (2) Each router
% maintains a single fair-share rate per link. Each packet carries the rate of the
% bottleneck link. For each packet, the router compares the two values. If the
% router's fair-share rate is smaller, it overwrites the value in the packet. This
% way, the source learns the fair-share rate of bottleneck link. It is simple,
% requires a very minor change to switches/routers and requires no per-flow
% state.

% \subsubsection{Considerações do GMTP-UCC em caminhos \setwayisfs e \setwayif}

% \subsubsection{Integração do GMTP-UCC com o ConEx}
%
% COMPARAR O GMTP AO TCP NO QUE DIZ RESPEITO COMO AS INFORMAÇÕES SÃO EXPOSTAS VIA
% CONEX.
%
% ========== REVER ===========
%
% No GMTP, os nós \repasss transmitem os vetores de ACKs para o seus nós \repasss
% parceiros e não para o nó \servs que origina o fluxo de dados \setpk. Esta é
% uma diferença considerável se o GMTP-UCC for comparado a qualquer variante do
% protocolo TCP, onde um sistema final transmite os pacotes de ACK para o sistema
% oposto e vice-versa. O ponto é o seguinte: sejam todos os caminhos \setwayis tal
% que um nó \repasss= \ways $\in$ \setwayi. No GMTP, um nó \ways enviará o vetor
% de ACKs apenas para seus nós parceiros \waysu{\wayi-1}. Essa estratégia é
% fundamental para uma transmissão de um fluxo de dados ao vivo que leva em
% consideração uma arquitetura P2P e o uso de um mecanismo para controle de
% congestionamento. Quando um nó \ways expõe o seu vetor de ACK apenas para seus
% nós parceiros \waysu{wayi-1}, permite-se uma regulação da taxa de transmissão
% específica apenas entre eles. Isto significa que o GMTP-UCC realiza controle
% de congestionamento regulando a taxa de transmissão entre dois nós \repass
% visinhos a fim de controlar apenas aquelas que estão envolvidos em um
% congestionamento. Com isto, evita-se o aumento ou a redução da taxa de
% transmissão de um fluxo \setpks para todo um caminho \setway, que ocorreria com
% o uso de algoritmos de congestionamento fim-a-fim, como os adotados no TCP.
% Consequentemente, o GMTP-UCC não sobrecarrega a rede com uma taxa de
% transmissão acima do esperado e também não sub-utiliza a rede com uma taxa de
% transmissão inferior a que a rede pode suportar.
%
% ============================
%
% Uma das funcionalidades do
% TCP é computar os pacotes que alcançam o sistema de destino, uma vez que se
% trata de um protocolo com suporte a garantia de entrega cujo mecanismo funciona
% com base na retransmissão de cada pacote perdido. No caso de protocolos como
% o \mudccp, a computação dos pacotes recebidos e perdidos pelo nó receptor é
% realizada pelo algoritmo de controle de congestionamento. No \mudccp-UCC,
% utiliza-se um mecanismo de vetores de ACKs, computado pelo nó receptor e
% transmitido para o nó transmissor, que então são repassados para o algoritmo
% Cubic a fim de definir a próxima taxa de transmissão. Os vetores de ACKs contém
% informações sobre pacotes perdidos ou pacotes marcados com ECN. Para maiores
% detalhes de como funciona o mecanismo de vetores de ACKs, o leitor pode
% consultar a RFC4341~\cite{RFC4341}.
%
%
% O ConEx é um protocolo que permite um nó remetente informar à rede sobre o
% congestionamento experimentado por pacotes anteriormente transmitindo em uma
% determinada transmissão de dados. No GMTP, especificamente no módulo
% GMTP-Inter, discutido na Seção~\ref{subsec:gmtp-intra-inter}, incorporou-se o
% ConEx para permitir que um nó \repasss possa obter as informações de
% congestionamento experimentada pelos seus nós \repasss parceiros. Com tais
% informações expostas aos nós \repass, é possível utilizá-las para realizar
% gerenciamento de tráfego, por exemplo.

% \subsubsection{Justificativa de uso do TCP-Cubic no GMTP}
%
% Por se tratar de um algoritmo já consolidado, decidiu-se omitir explicações
% detalhadas do funcionamento do algoritmo Cubic no \mudccp. Embora não será
% apresentada uma explicação detalhada do algoritmo TCP Cubic, considera-se de
% suma importância justificar os motivos que levaram a escolha do TCP Cubic para
% transmissões unicast no \mudccp.
%
% O primeiro motivo está relacionado com os diversos resultados de pesquisas
% anteriores, incluindo uma série de resultados obtidos no contexto deste
% trabalho. Nos últimos anos diversas pesquisas científicas constataram a eficácia
% do TCP Cubic em termos da sua equidade para com outros fluxos TCP e, ao
% mesmo tempo, para com fluxos de dados TCP transmitidos utilizando outras
% variantes do TCP, como o TCP Vegas~\cite{Low:2002:UTV:506147.506152}, TCP
% HSTCP~\cite{RFC3649} e o recém lançado TCP Compound~\cite{4146841,5472999},
% utilizado na versão do sistema operacional Windows Vista em diante. O TCP Cubic
% não degrada os fluxos de dados transmitidos utilizando estas variantes do TCP e
% também não é degradado quando em disputa com fluxos de dados não-controlados,
% como os transmitidos utilizando o protocolo UDP.
%
% O segundo motivo é que o TCP Cubic tem sido utilizado pela maioria dos sistemas
% em execução na Internet da atualidade, uma vez que este é o algoritmo para
% controle de congestionamento utilizado por padrão para o sistema operacional
% Linux. Diante disto, desenvolver um protocolo cujo mecanismo para controle de
% congestionamento seja compatível com a maioria dos fluxos de dados é uma decisão
% primordial para o correto funcionamento e aproveitamento dos recursos de rede,
% em especial na Internet.

\subsection{Controle de Congestionamento Multicast}
\label{subsec:mudccp-mcc}

Da mesma forma que no \mudccp-UCC, o objetivo principal do \mudccp-MCC é
determinar uma taxa de transmissão equânime entre os fluxos de dados
transmitidos pelo GMTP e por outros protocolos, como o TCP, porém
em modo de transmissão multicast. No caso GMTP-MCC, trata-se de um algoritmo
responsável pelo controle de congestionamento em uma rede local constituída por
\net$_{sub}$ = \repasss $\cup$ \subsetcli(\repass). Na prática, os nós da rede
\net$_{sub}$ formam um grupo multicast para a transmissão e recepção de um ou
mais fluxos de dados \setpk, onde o nó \repasss sempre será o transmissor e os
nós \clis $\in$ \subsetcli(\repass) os receptores. A estratégia é que o
valor da taxa de transmissão para um fluxo de dados \setpks seja tão próximo ao
valor da taxa de transmissão que o fluxo TCP utilizaria caso fosse
transmitido na rede, portanto um algoritmo \textit{TCP-Friendly}. Um fluxo de
dados é considerado \textit{TCP-Friendly} quando este não degrada a taxa de
transmissão de um fluxo de dados TCP mais do que outro fluxo TCP degradaria
se começasse a ser transmitido na rede.

O \mudccp-MCC foi inspirado em um protocolo publicado pela IETF chamado
\textit{TCP-friendly Rate Control protocol (TFRC)} (RFC 3448~\cite{RFC3448}). O
TFRC é um mecanismo para controle de congestionamento de fluxos unicast que
tenta prevê a taxa de transmissão de um fluxo TCP e utilizá-la em protocolos
diferentes do TCP~\cite{CONG:Floyd00:TFRC:art}. Trata-se de uma abordagem
diferente da utilizada em algoritmos baseados em janela deslizante e que
utilizam pacotes de confirmação para determinar a taxa de transmissão de uma
conexão, como acontece no TCP. No TFRC, o receptor envia para o transmissor
relatórios sobre as perdas observadas e, com base nesse relatório, o transmissor
calcula a nova taxa de transmissão. O TFRC é categorizado com um protocolo
de controle de congestionamento baseado em uma equação matemática
(\textit{Equation Based Congestion Control}). Algoritmos desse tipo são adotados
em diversos protocolos, como é o caso dos CCIDs 3 e 4 do
DCCP~\cite{RFC4341,RFC4342}. Em linhas gerais, o algoritmo TFRC funciona da
seguinte forma:

\begin{enumerate}[{\tab}1$^{\circ}$]
 \item o receptor mede a taxa de perda de pacotes e envia essa informação para o
transmissor;
 \item o transmissor usa esse relatório para medir o RTT até o
receptor;
 \item o transmissor utiliza a Equação~\ref{eq:trfcmudccp} para determinar qual
será a sua próxima taxa de transmissão em função do relatório de perdas e o
RTT obtidos anteriormente;
 \item o transmissor então ajusta sua taxa de transmissão para o valor
calculado no passo anterior.
\end{enumerate}

\begin{equation}
R(p) = \frac{s}{RTT \times \left(\sqrt{\frac{2 \times p}{3}} + \left(12 \times
\sqrt{\frac{3 \times p}{8}}\right) \times p \times (1 + 32 \times p^2)\right)}
\label{eq:trfcmudccp}
\end{equation}

\vspace{0.5cm}

Na Equação~\ref{eq:trfcmudccp}~\cite{Padhye98model}, $T$ é a taxa de transmissão
medida em bytes/segundo definida em função de \textit{s}, que é o tamanho do
pacote medido em bytes; $RTT$, é o RTT entre o nó transmissor e o receptor,
medido em segundos e $p$, a taxa de perda de pacotes observado pelo nó receptor.

Apesar de ser uma estratégia interessante e funcionar em conexões unicast, em
transmissões multicast o algoritmo descrito anteriormente não é eficiente. O
algoritmo é limitado devido a um problema conhecido por \textit{explosão de
retorno} (\textit{feedback implosion}). Esse problema ocorre quando há muitos
receptores enviando relatórios de perdas para o mesmo transmissor, o que resulta
em uma inundação de relatórios, os quais o transmissor é incapaz de processar em
tempo hábil.

Nesse contexto, para evitar o problema da \textit{explosão de retorno},
determinou-se que apenas alguns nós \clis são obrigados a enviar tais
relatórios ao nó \repass. Estes nós são chamados de nós GMTP Relatores e
representados por \rel. No GMTP-MCC, a versão original do TFRC foi alterada e
funciona da segunte forma:

\begin{enumerate}[{\tab}1$^{\circ}$]

  \item O nó \repasss executa um algoritmo de eleição de nós relatores \rels
$\in$ \subsetcli(\repass). Na Seção~\ref{subsec:electrelsreps}, descreve-se o
procedimento para eleger os nós \rel.

  \item Os nós \rels calculam a taxa de transmissão utilizando a
Equação~\ref{eq:trfcmudccp}, ao invés do transmissor realizar este cálculo,
como na versão original do TFRC;
  \label{step:gmtp-mcc2}

  \item Os nós \rels determinam a taxa de eventos de perda, e não todos os
receptores do grupo multicast. Para calcular o evento de perda $p$, utiliza-se
o mesmo procedimento feito pelo TFRC~\cite{RFC3448,Padhye98model}, onde um
intervalo de perda é determinado por consecutivas perdas de pacotes, desde do
primeiro pacote perdido até o último pacote perdido, seguido de um pacote
recebido com sucesso;

  \item O RTT é calculado entre o nó \rels e o nó \repass, com o temporizador
controlado pelos nós \rels e não pelo nó \repass. Isto evita que o nó \repasss
tenha que manter estado de temporizador para cada fluxo de dados \setpks
transmitido para os nós \clis $\in$ \subsetcli(\repass). Para determinar o valor
do parâmetro RTT e calcular a taxa de transmissão através da
Equação~\ref{eq:trfcmudccp}, o GMTP-MCC utiliza a
Equação~\ref{eq:calcrtt-rcp}, com $\theta = 0.25$, padrão do TCP;

  \item A taxa de transmissão a ser utilizada pelo nó \repasss é a média
aritmética de todas as taxas enviadas pelos nós \rel;

  \item Repete-se todos os passos a partir do passo~\ref{step:gmtp-mcc2} a cada
intervalo igual ao RTT ou quando um intervalo de perda $p$ é determinado.

\end{enumerate}

Teoricamente, o GMTP-MCC seria um protocolo \textit{TCP-Friendly} se $R(RTT, p)$
fosse o valor máximo entre as taxas de transmissão relatadas pelos nós \rel.
Porém, optou-se por utilizar a média aritimética dos valores relatados pelos
nós \rels porque, na prática, diversos fatores podem alterar o estado da rede no
instante da transmissão usando o valor máximo da taxa de transmissão reportada
pelos nós \rel. Com esta decisão, define-se uma margem de segurança
evitando-se que o GMTP-MCC alcance o limite superior para o valor da taxa de
transmissão de um fluxo transmitido com TCP. Além disso, a média aritimética
suaviza os valores subsequentes para a taxa de transmissão a ser utilizada pelo
nó \repass.

Um aspecto importante na medição do RTT está relacionado com o início de uma
conexão GMTP, pois não se sabe o valor para inicial para RTT até o final do
processo de estabelecimento de uma conexão. Nesse caso, deve-se utilizar um
valor consideravelmente alto para evitar taxas de transmissões maiores do
que a rede tem capacidade de suportar. No GMTP, utiliza-se o valor inicial de
RTT igual a \ut{150}{ms}. Quando um nó \clis envia um pedido de conexão
utilizando o pacote do tipo \pac{GMTP-Request}, o mesmo deve realizar a sua
primeira medição do valor de RTT, iniciando-se o marcador de tempo para o
cálculo do RTT quando enviar o primeiro \pac{GMTP-Request} e parando-o quando
receber o pacote do tipo \pac{GMTP-Response}. Em seguida, deve-se acionar o
mecanismo de cálculo da taxa de transmissão através da
Equação~\ref{eq:trfcmudccp}, caso o respectivo nó \clis seja eleito um
nó relator.

% No caso do \mudccp-MCC, cada nó \rels
% agrega as perdas de pacotes que ocorrem dentro de um evento de perda, definido
% por uma ou mais perdas de pacotes no espaço de tempo de um RTT. Para o cálculo
% de $p$, utiliza-se a média dos tamanhos dos intervalos de perda, calculada
% através da média ponderada dos $m$ mais recentes intervalos de perdas $l_k,
% \dots, l_{k-m+1}$ seguindo a Equação~\ref{eq:losseventmean}. O conjunto de todos
% os intervalos de perda é chamado de \textit{histórico de perdas}.
%
% \begin{equation}
% l_{avg} = \frac{\sum_{i=0}^{m} w_i \times l_{k-i}}{\sum_{i=0}^{m} w_i}
% \label{eq:losseventmean}
% \end{equation}
%
% Os pesos $w_i$ são escolhidos de tal forma que os intervalos de perdas mais
% recentes recebem pesos mais altos, decrescendo-os gradualmente até $1$
% para os intervalos de perdas mais antigos. Por exemplo, para $8$ intervalos de
% perda $m$, pode-se utilizar os pesos $w = [5, 5, 5, 5, 4, 3, 2, 1]$. Ao
% utilizar-se da média ponderada para o cálculo da média dos tamanhos dos
% intervalos de perda, obtem-se mudanças mais suaves para o valor de $l_{avg}$ à
% medida que os tamanhos dos intervalos de perdas se tornam mais antigos. Para
% grandes valores de $m$, obtem-se mudanças mais suaves para $p$ ao longo do
% tempo, porém isto também reduz a capacidade de resposta e portanto a equidade do
% protocolo. No TFRC, recomenda-se utilizar valores de $m$ entre $8$ e $32$ e por
% este motivo no \mudccps é considerada esta recomendação. A
% Equação~\ref{eq:losseventmean} é definida na RFC 3448~\cite{RFC3448} e foi
% mantida no \mudccp. O protocolo DCCP também utiliza essa mesma abordagem no
% algoritmo de controle de congestionamento CCID-3~\cite{RFC4342}.
%
% Uma vez definido como determina-se a média dos tamanhos dos intervalos de
% perda, a taxa dos eventos de perda $p$ é definido pelo inverso de $l_{avg}$,
% definido na Equação~\ref{eq:losseventrate}. Como um intervalo de perda é
% definido em função do número de pacotes entre de eventos de perdas consecutidos,
% o mais recente evento de perda não pode influenciar na taxa do evento de perda,
% por isto utilizou a função \textit{max} no denominador da
% Equação~\ref{eq:losseventrate}.
%
% \begin{equation}
% p = \frac{1}{max(l_{avg}(k), l_{avg}(k-1))}
% \label{eq:losseventrate}
% \end{equation}
%
%
% Uma outra observação com relação ao ajuste da nova taxa de transmissão de $s_i$
% está relacionado ao fato de um nó $\hat{r}_i$ se desconectar ou perder
% repentinamente sua conexão. Caso isto aconteça com algum nó $\hat{r}_x$, seu
% valor $T_{\hat{r}_x}$ deverá ser desconsiderado no cálculo da nova taxa de
% transmissão $T_{s_{i}}$. Existem duas formas que um relay $s_i$ pode perceber a
% desconexão de um ou mais nós $\hat{r}_i$. A primeira forma é quando um nó
% $\hat{r}_x$ envia explicitamente um pedido de desconexão para $s_i$,
% tal processo é discutido na Seção~\ref{subsec:mudccp-desconexao}, ao passo que a
% segunda forma é quando um contador de tempo de manutenção de conexão, mantido
% pelo relay $s_i$ se expira, tal processo é discutido na
% Seção~\ref{subsec:electrelsreps}. Com esta medida, evita-se utilizar um taxa de
% transmissão $T_{s_{i}}$ incorreta, portanto não correr o risco de utilizar uma
% taxa de transmissão não condizente com o estado atual da rede.
%
% \subsection{Taxa de Eventos de Perda $p$}
% \label{subsec:mcclossevent}


% Para mais discussões acerca de como funciona o mecanismo para medição dos
% intervalos de perda, consulte a referência~\cite{CONG:Floyd00:TFRC:art}.

% Um aspecto importante no cálculo do valor de $p$ é determinar o seu valor
% inicial.

% \subsection{Cálculo do RTT}
% \label{subsec:mccrtt}
%
% O cálculo do RTT realizado no \mudccp-MCC é feito apenas pelos nós
% reporters e funciona da seguinte forma. Um nó $\hat{r}_i$ transmite ao seu
% respectivo relay $\hat{s}_i$ um pacote de controle e inicia um marcador de
% tempo. Ao receber uma resposta do nó relay $\hat{s}_i$, o nó reporter
% $\hat{r}_i$ pára o marcador de tempo e utiliza este tempo chamado de
% $RTT_{instant}$ para calcular o valor do próximo $RTT$ de acordo com a
% Equação~\ref{eq:calcrtt}.
%
% \begin{equation}
% RTT = \beta \times RTT_{instant} + (1 - \beta) \times RTT
% \label{eq:calcrtt}
% \end{equation}
%
% Note que no \mudccp-MCC não se utiliza o valor de $RTT$ instantâneo
% ($RTT_{instant}$) como o valor do $RTT$, mas sim utiliza-se de um mecanismo
% para suavizar as mudanças do $RTT$ ao longo do ciclo de vida de uma conexão.
% Desta forma, procura-se evitar que valores absurdos de $RTT_{instant}$ -- muito
% baixos ou muito altos com relação aos valores medidos anteriormente --
% influenciem demasiadamente na taxa de transmissão $T_{\hat{s}_i}$.
%
% O mecanismo mencionado anteriormente para suavizar as medições do valor de
% $RTT$ é chamado de Médias Móveis Exponencialmente Ponderadas ou
% \textit{Exponentially Weighted Moving Average} (EWMA). O EWMA foi primeiramente
% utilizado para índices financeiros de medição de risco, onde a série de retornos
% diários com $n$ observações é ponderada por um fator de decaimento. As
% observações mais recentes no tempo são ponderadas com um peso maior que as
% observações mais antigas. O peso de uma observação decai exponencialmente com
% $n$. Em seguida, utilizou-se EWMA em medições de tempo do $RTT$ em protocolos
% como o TCP. Como trata-se de uma estratégia conhecida para medição de RTT, no
% \mudccp-MCC manteve-se o mesmo mecanismo, principalmente por já ter sido
% exaustivamente testado e utilizado. Tanto no TCP quanto no caso do \mudccp,
% utiliza-se $\beta = 0.25$ para o cálculo do valor de $RTT$ através da
% Equação~\ref{eq:calcrtt}~\cite{kurose2006}.

% Porém, diferentemente do mecanismo de medição de $RTT$ no TCP e no TFRC, os nós
% reporters $\hat{r}_i$ são os responsáveis pela medição do $RTT$ e não o nó
% transmissor. Um aspecto importante na medição do RTT está relacionado com o
% início de uma conexão \mudccp, pois não se sabe o valor para $RTT_{instant}$
% até o final do processo de estabelecimento de uma conexão. Nesse caso, deve-se
% utilizar um valor consideravelmente alto para evitar taxas de transmissões
% $T_{\hat{s}_i}$ muito maiores do que a rede tem capacidade de suportar. No
% \mudccp, utiliza-se o valor inicial de $RTT_{instant}$ igual a \ut{150}{ms}.
% Quando um nó $\hat{r}_i$ enviar um pedido de conexão utilizando o pacote do tipo
% \mudccp-Request, o mesmo deve realizar a sua primeira medição do valor de
% $RTT_{instant}$, iniciando-se o marcador de tempo para o cálculo do RTT quando
% enviar o primeiro \mudccp-Request e parando-o quando receber o pacote do tipo
% \mudccp-Response. Em seguida, deve-se acionar o mecanismo de cálculo de
% $T_{\hat{r}_i}$, caso o respectivo nó $\hat{r}_i$ seja eleito como reporter.

% \subsubsection{Confirmação de recepção de \pk}
%
% O GMTP realiza confirmação de recepção de pacotes \pks para avaliar a
% capacidade de entrega e realizar controle de congestionamento.
%
% Nesse contexto, o GMTP é um protocolo orientado a mensagem, como o UDP e o DCCP,
% e não a cadeia de bytes, como é o caso do TCP. Dessa forma, a unidade básica de
% transporte no GMTP é um segmento completo e não cada byte individualmente. O
% tamanho de um segmento varia de acordo com o MTU (\textit{Maximum Transport
% Unit}) da rede, que em geral tem tamanho de \ut{1500}{bytes}, contando com o
% espaço ocupado pelo cabeçalho.
%
% Vetor de ACK \pac{GMTP-DataAck}

\section{Autenticidade de \setpk}
\label{sec:seguranca}

Em uma solução baseada em um modelo de serviço P2P, é possível que nós
mal-intencionados \repasss poluam o sistema com conteúdos que não foram
gerados pelo nó servidor (Figura~\ref{fig:bucket-brigade-principle-4}).

\begin{figure}[ht]
\begin{center}
\includegraphics[natwidth=797,natheight=213,scale=.74]{imgs/bucket-brigade-principle-4.png}
\end{center}
\vspace{-0.8cm}
\caption{Um nó \repasss mal-intencionados podem poluir o sistema com conteúdos
que não foram gerados pelo nó \serv.}
\label{fig:bucket-brigade-principle-4}
\end{figure}

Para evitar esse tipo de ataque, executa-se um procedimento para verificar a
autenticidade de um fluxo de dados \setpk. Para isto, os próprios nós \ways
$\in$ \setwayis verificam se o conteúdo de um pacotes de dados \pks $\in$
\setpks foi alterado por algum nó \ways anterior, durante o procedimento de
repasse. Apenas após comprovar a autenticidade de um pacote \pk, o nó \ways
repassa tal pacote de dados \pks para o próximo nó \wayu{\wayconst+1},
transmitindo-os também para seus nós \clis $\in$ \subsetcli$($\way$)$, se houver
demanda. Este procedimento evita que todos os nós \clis que receberem o fluxo de
dados \setpks tenham que verificar a autenticidade dos pacotes \pk.

Na prática, o ideal seria que todos nós \ways verificassem a autenticidade de
cada pacote \pk, porém, tal ação pode onerar os recursos computacionais de cada
nó \ways e aumentar o tempo de entrega de \pks aos nós
\clis $\in$ \subsetcli$($\way$)$. Isto porque os nós \ways também processam cada
pacote de dados \pks para decidir sobre seu repasse, como discutido nas
Seções~\ref{sec:connformnet} e~\ref{sec:asptransrecep}.

Para reduzir a sobrecarga de verificação de autenticidade de um fluxo de dados
\setpks em cada nós \way, definiu-se duas regras, uma para decidir quais
nós devem realizar a verificação de autenticidade (Regra 1) e a outra para
determinar a quantidade de pacotes que se deve realizar tal procedimento
(Regra 2). Tais regras são definidas a seguir.

\begin{enumerate}

  \item apenas os nós \way, tal que \transmitqu{\way} = 1, ou seja, se \way
$=$ \transs $\in$ \settrans, devem realizar o procedimento de verificação de
autenticidade do fluxo de dados \setpk; e

  \item os nós \way, definidos pela Regra 1, não devem verificar todos os
pacotes \pks $\in$ \setpk, mas apenas uma quantidade $pc(t)$ de pacotes de dados
\pks $\in$ \setpk, em um instante $t$. Nesse caso, define-se
$pc(t)$, apresentada na Equação~\ref{eq:qtpxcheck}, em função de:

  \begin{itemize}

    \item $bs(t, \setpkc)$, o número de pacotes \pks $\in$ \setpks presentes no
buffer de repasse de \ways em um instante $t$;

    \item $\frac{1}{\mid \setwayc^{\lhd}_{\setwayii} \mid -1}$, a probabilidade
de um nó \repasss $\in$ \setwayids ter alterado o conteúdo de um ou mais \pks
presente(s) no buffer de repasse de \way, onde \setwayids $=$
\invert{$\delta(\wayconst_{\wayi+1}$, \setwayi$)$} e \setwayis é o caminho
através do qual se transmite os pacotes de dados \pks $\in$ \setpk;

  \end{itemize}

\end{enumerate}

\begin{equation}
pc(t) = \floor*{bs(t) \times \left(1 - \frac{1}{\mid
\setwayc^{\lhd}_{\setwayii} \mid -1}\right)}
\label{eq:qtpxcheck}
\end{equation}

\vspace{0.5cm}

Sendo assim, quanto mais distante um nó \ways estiver do nó \serv, que gera o
fluxo de dados \setpk, mais pacotes \pks $\in$ \setpks deve-se verificar sua
autenticidade. Antes de entender o procedimento para verificar a autenticidade de
um pacote \pks $\in$ \setpk, deve-se entender como o nó \servs deve gerar
manipular os referidos pacotes de dados para que seja possível verificar sua
autenticidade. Este procedimento é explicado a seguir.

\subsection{Transmissão e assinatura de autenticidade de \pks $\in$ \setpk}
\label{subsec:gerar-pacote-assinado}

Quando o nó \servs gerar cada pacote de dados \pks $\in$ \setpk, este deve
gerar uma assinatura digital dos dados da aplicação a serem transportados. Em
seguida, o nó \servs deve incluir a assinatura digital gerada no cabeçalho do
pacote de dados \pk, no campo assinatura (\textit{signature}). Para assinar
digitalmente o conteúdo da aplicação, utiliza-se o método de criptografia
assimétrica RSA, onde $K^{-}_{\servconst_{\servi}}$ e
$K^{+}_{\servconst_{\servi}}$ representam a chave privada e a chave pública de
\serv, respectivamente. No Trecho de Código~\ref{algo:digitalSignPacket},
apresenta-se o procedimento de assinatura de um pacote \pks $\in$ \setpk.

\vspace{0.5cm}

\begin{algorithm}[H]
\label{algo:digitalSignPacket}
\caption{digitalSignPacket(\pk: \pac{GMTP-Data})}

\SetAlgoLined
\tcc{\servs executes this algorithm to digital sign the packet content using
its private key $K^{-}_{\servconst_{\servi}}$ and a pre-defined hash function,
such as the well-know md5 or sha1 function. \servs get the value of data field,
which is the content that application wants to transport and generates a
signature by encrypt the hash of the data using the \servs private key. After,
put the generated signature in the signature field of the packet \pk. The
signature field will be used later by a note \repasss to verify the packet \pks
authenticity executing the Algorithm~\ref{algo:verifyPacketAuthenticity}.}

\SetKwFunction{Union}{Union}\SetKwFunction{getPacketFieldValue}{getPacketFieldValue}
\SetKwFunction{Union}{Union}\SetKwFunction{setPacketFieldValue}{setPacketFieldValue}
\SetKwFunction{Union}{Union}\SetKwFunction{hash}{hash}
\SetKwFunction{Union}{Union}\SetKwFunction{encrypt}{encrypt}

\textit{data} \attrib \getPacketFieldValue{\pk, `data'}\;
\textit{hashValue} \attrib \hash{\textit{data}}\;
\textit{signature} \attrib \encrypt{$K^{-}_{\servconst_{\servi}}$,
\textit{hashValue}}\;
\setPacketFieldValue{\pk, `signature', \textit{signature}}\;
\Return{\pk}\;

\end{algorithm}
\vspace{0.8cm}

\subsection{Verificação de autenticidade de \pks $\in$ \setpk}
\label{subsec:verifyPacketAuthenticity}

Após definir as regras para verificação de autenticidade do fluxo de dados
\setpk, a quantidade de pacotes $pc(t)$ que um nó \ways deve verificar, nesta
seção discute-se como ocorre o procedimento de verificação de autenticidade de
um ou mais pacotes de dados \pks $\in$ \setpk.

Dada a quantidade $pc(t)$ de pacotes que \ways deve verificar suas respectivas
autenticidades, o nó \ways escolhe aleatoriamente (distribuição uniforme) os
pacotes \pks disponíveis no buffer de recepção, gerendo um conjunto \setpk'
$\subset$ \setpk. Uma vez definido \setpk', \ways executa o procedimento de
verificação de autenticidade que funciona a seguinte forma. Para cada pacote
\pks $\in$ \setpk', extrai-se a assinatura do pacote \pk, gerada pelo nó \serv,
como explicado na Seção~\ref{subsec:gerar-pacote-assinado}. Em seguida,
extrai-se o campo de dados para que se possa verificar sua autenticidade. Para
isto, gera-se o valor de \textit{hash} do campo de dados e compara-se com o
valor de \textit{hash} gerado pelo nó \servs no momento da transmissão do
pacote \pk. Note que o valor de \textit{hash} gerado pelo nó \servs é obtido
através de processo de decriptar a assinatura do pacote de dados \pks utilizando
a chave pública do nó \serv. Assim, se o valor de \textit{hash} gerado com base
no conteúdo transportado no pacote \pks for igual ao valor de \textit{hash}
disponível na assinatura do pacote, conclui-se que o pacote \pks não foi
alterado por nenhum nó \ways $\in$ \setwayids $=$
\invert{$\delta(\wayconst_{\wayi+1}$, \setwayi$)$}. Se o pacote de dados \pks
não foi alterado, marca-o como aprovado para ser repassado, caso contrário,
marca-o como desaprovado e deve ser descartado. No Trecho de
Código~\ref{algo:verifyPacketAuthenticity}, apresenta-se o procedimento de
verificação de autenticidade de um pacote \pks $\in$ \setpk.

\vspace{0.5cm}

\begin{algorithm}[H]
\label{algo:verifyPacketAuthenticity}
\caption{verifyPacketAuthenticity(\setpk': \textbf{array of} \pac{GMTP-Data})}

\SetAlgoLined
\tcc{\ways executes this Algorithm to check if the content of a subset of
packets \setpk' $\subset$ \setpks was modified. It marks each \pks $\in$ \setpk'
to be relayed or discarded. \ways uses the \servs public key to decrypt the \pks
signature and compares it to the hash value of the \pks content. It marks \pks
to be relayed if \pks content was not modified, otherwise it marks \pks to be
discarded, because \pks was modified by a node in \setwayids $=$
\invert{$\delta(\wayconst_{\wayi+1}$, \setwayi$)$}.}

\SetKwFunction{Union}{Union}\SetKwFunction{getPacketFieldValue}{getPacketFieldValue}
\SetKwFunction{Union}{Union}\SetKwFunction{GMTPResponse}{GMTPResponse}
\SetKwFunction{Union}{Union}\SetKwFunction{hash}{hash}
\SetKwFunction{Union}{Union}\SetKwFunction{decrypt}{decrypt}
\SetKwFunction{Union}{Union}\SetKwFunction{destroy}{destroy}

verifiedPackets \attrib \textbf{array of} boolean;

\ForEach{\pks $\in$ \setpk} {
  \textit{signature} \attrib \getPacketFieldValue{\pk, `signature'}\;
  \textit{data} \attrib \getPacketFieldValue{\pk, `data'}\;
  \textit{verifiedPackets[$x$]} \attrib $($\hash{\textit{data}} =
\decrypt{$K^{+}_{\servconst_{\servi}}$, \textit{signature}}$)$\;
}
\Return{\textit{verifiedPackets}}\;

\end{algorithm}
\vspace{0.8cm}


\subsection{Habilitar ou desabilitar o procedimento de segurança}

A função de verificação de autenticidade de um fluxo de dados \setpks do GMTP é
opcional e desabilitada por padrão. Isto porque um sistema de transmissão, em
execução na camada de aplicação, pode ou não desejar tal função. Por isso,
considera-se que apenas o nó \servs tem o controle de habilitar tal
funcionalidade, e este procedimento requer sinalizar os nós \ways para que
estes executem o procedimento de verificação de autenticidade descrito
na Seção~\ref{subsec:verifyPacketAuthenticity}. Para isto, o nó \servs ativa o
da opção assinado (\textit{signed}) disponível no pacote de dados
\pac{GMTP-Register-Reply}, sinalizando que todos os pacotes de dados \pks
$\in$ \setpks conterá a assinatura do conteúdo de dados sendo transportados e
que poderá ser verificado pelos nós \ways $\in$ \setwayi, desde que
\transmitqu{\way} $=$ 1.

Note que quando um nó \clis $\in$ \subsetcli$($\repass$)$ solicitar um fluxo
de dados \setpk, em resposta a tal pedido, o nó \repasss retornará um pacote do
tipo \pac{GMTP-Request-Notify}. No cabeçalho desse pacote, o nó \repasss deve
também ativar a opção assinado (\textit{signed}) para que o nó \clis seja
notificado e entenda que seu nó \repasss realizará a verificação de
autenticidade do fluxo de dados \setpks da forma descrita anteriormente na
Seção~\ref{subsec:verifyPacketAuthenticity}. Este procedimento permitirá que a
aplicação em execução no nó \clis possa informar ao usuário final que tal
funcionalidade está habilitada, por exemplo.

Além disso, como parâmetros de configuração, o usuário administrador do nó
\repasss pode habilitar ou desabilitar a opção de verificação de autenticidade
dos fluxos de dados \setpk, mesmo que o nó \servs possibilite tal verificação,
como descrito anteriormente.

\subsection{Obter a chave pública $K^{+}_{\servconst_{\servi}}$ de \serv}
\label{subsec:obterchavepublica}

Um nó \repasss obtem a chave pública $K^{+}_{\servconst_{\servi}}$ de \servs
através do certificado digital disponível na URI especificada no parâmetro
\textit{f} da descrição da mídia, como ilustrou-se no Trecho de
Código~\ref{algo:sdp-mediadesc}, Linha~\ref{line:sdp-mediadesc:f}, da
Seção~\ref{subsubsec:desc-conteudo}. Isto ocorre após o nó \repasss receber o
pacote \pac{GMTP-Register-Reply}, que confirma o registro de participação ou a
conexão para obter um fluxo de dados \setpk, como apresentou-se no Trecho de
Código~\ref{algo:registerRelay}, Linha X,
Seção~\ref{subsec:registro-participacao}.

Após obter o referido certificado digital do nó \serv, o nó \repasss pode
realizar \textit{cache} de tal conteúdo para que os próximos nós \clis e evitar
ter que obtê-lo a todo instante. De forma alternativa, o usuário administrador
do nó \repasss pode obter o arquivo de certificação digital do nó \repasss e
salvá-lo, por meio de \textit{upload}, por exemplo, manualmente nas
configurações do nó \repass. Deve ser opcional também para o usuário
administrador do nó \repasss escolher se tal nó deve ou não realizar
\textit{cache} dos certificados digitais dos nós \serv.

%
% Para evitar esta situação, empregou-se no GMTP um mecanismo para validação do
% conteúdo de \pks antes que o mesmo seja transmitido para os nós \clis $\in$
% \subsetcli(\repass). Esta função é opcional no GMTP e funciona da forma
% apresentada a seguir.
%
% \begin{enumerate}
%  \item
% \end{enumerate}


\section{Outras considerações sobre o GMTP}
\label{sec:outros-aspectos}

Nesta seção, apresentam-se brevemente outras funcionalidades do GMTP, tais como
o procedimento de desconexão e falha de um nó repassador, adaptação de fluxo,
eleição de nós relatores.

\subsection{Procedimentos para desconexão de nós \cli, \rels e \repass}
\label{subsec:desconexao}

% \begin{figure}[ht]
% \begin{center}
% \includegraphics[natwidth=797,natheight=173,scale=.73]{imgs/bucket-brigade-principle-3.png}
% \end{center}
% \vspace{-0.8cm}
% \caption{Um usuário pode desconectar e é preciso um mecanismo de tolerância à
% desconexão.}
% \label{fig:bucket-brigade-principle-3}
% \end{figure}
%
% \vspace{0.5cm}


O processo de finalização de uma conexão \mudccps ocorre com algumas
diferenças se comparado com outros protocolos orientados à conexão. Para
sinalizar uma desconexão, um nó \clis transmite um pacote do tipo
\pac{GMTP-Close} pelo canal de controle, contendo o nome do fluxo que deseja
se desconectar. Ao receber este tipo de pacote, o nó \repasss transmite ao nó
\clis um pacote do tipo \pac{GMTP-Reset}, sinalizando que está ciente do
fechamento da conexão. Nesse interim, os nós desalocam recursos relacionados à
respectiva conexão. Este procedimento é suficiente para o pedido de finalização
de uma conexão de um cliente \mudccp, porém para finalizar uma conexão de um nó
\rel e \repasss outros procedimentos são necessários.

\subsubsection{Desconexão de um nó \rel}

Como apresentado na Seção~\ref{subsec:mudccp-mcc}, um nó \rels é responsável
por relatar ao nó \repasss as condições de recepção de pacotes \pks $\in$
\setpks em uma transmissão multicast e assim determinar a taxa de transmissão
que deve ser utilizada para repassar o referido fluxo de dados. Sem os nós
\rel, tal procedimento não seria possível. Sendo assim, deve-se realizar um
procedimento para eleger um novo nó \rels quando um nó com tal responsabilidade
solicite desconexão. São candidatos a nó \rels os nós \clis já recebendo
o fluxo de dados \setpk, e o nó \rels em procedimento de desconexão deve
esperar que o procedimento de nova eleição seja concluído. Nesse
interim, o nó \rels em processo de desconexão deve continuar enviando pacotes
do tipo \pac{GMTP-Ack} para o nó \repass.

\subsubsection{Desconexão de um nó \repass}

Um nó \repasss realiza o procedimento de desconexão não por intervenção da
aplicação, mas sim quando \subsetcli(\repass) $= 0$ para um determinado
fluxo de dados \setpk. Neste caso, pode ocorrer uma situação crítica para todos
os nós parceiros \repasssu{q} de \repass, pois teoricamente estes não poderão
mais receber os pacotes de dados \pks $\in$ \setpk. Para evitar um período de
instabilidade na recepção de \setpks por parte dos nós parceiros de \repass,
define-se no GMTP um parâmetro chamado de período de carência para novas
parcerias (\textit{grace period for new partnerships}). Trata-se de um parâmetro
que determina o tempo que um nó \repasss continuará repassando o fluxo de dados
\setpks para seus parceiros.

O valor para o \textit{período de carência para novas parcerias} é transmitido
para os nós parceiros \repasssu{q} de \repass, que por sua vez deve iniciar o
procedimento de realizar outras parcerias a fim de continuar recebendo o fluxo
de dados \setpk. Opcionalmente, um nó \repasss pode aceitar receber de seus nós
parceiros \repasssu{q}, o valor para o período de carência, desde que não
ultrapasse um limite máximo definido pelo administrador de \repass.

\subsubsection{Falha de um nó \repass}

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=.5]{
imgs/esquema-abstrato-formacao-parceria-intra-falha.pdf}
\end{center}
\vspace{-0.8cm}
\caption{Cenário de falha do nó \repassu{6} em um caminho \setwayiu{1}, seguida
de constituição de um novo caminho \setwayiu{3} formado pelo procedimento de
formação de parceria intra \setwayi.}
\label{fig:esquema-abstrato-formacao-parceria-intra-falha}
\end{figure}

Além disso, uma ação específica é realizada se um nó \ways $\in$ \setwayis
circunstancialmente falhar. Para tratar estes casos, definiu-se que o nó
\repasss pode formar parcerias com os próprios nós \repasss $\in$ \setwayid, tal
que \setwayid\space $=$ \invert{$\delta($\wayu{\wayi+1}, \setwayi$)$}, através
de uma outra rota de rede que também alcance o nó \servs -- isto pode acontecer
devido à execução de algoritmos de roteamento dinâmico \textit{Intra-AS
(Autonomous Systems)}, por exemplo, o OSPF, e \textit{Inter-AS}, por exemplo, o
BGP~\cite{kurose2006}.

Para entender o comportamento do GMTP em caso de falha de um nó \repass,
observe a Figura~\ref{fig:esquema-abstrato-formacao-parceria-intra-falha}. Se o
nó \repassu{6} falhar e o nó \repassu{14} também estiver repassando \setpk, uma
nova parceria é formada transparentemente entre o nó \repassu{7} e o nó
\repassu{14}. Isto porque o nó \repassu{14} interceptará os pacotes de controle
de \textit{keep-aline} que o nó \repassu{7} está transmitindo para o nó \serv.
Mas, pode acontecer o caso de que \transmitru{14} $ = 0$ e \transmitru{13} $ =
0$ para o fluxo de dados \setpk, portanto o pedido de conexão enviado pelo nó
\repassu{9} alcançará o nó \servu{1} como antes. Isto resultará na constituição
de um novo caminho \setwayiu{3} $=$ \setwayidu{1} $\cup$ \setwayidu{2}, tal que
\setwayidu{1} $=$ \invert{$\delta($\repassu{6}, \setwayiu{1}$)$} e \setwayidu{2}
$=$ $\delta($\invert{\setwayiu{2}}, \repassu{15}$)$. Isto fará com que todo o
caminho \setwayiu{3} repasse o fluxo de dados \setpk. Como consequência,
aumenta-se a possibilidade de parcerias futuras com nós \repasss cujo pedido de
conexão para obter \setpks seja roteado pelo caminho \setwayiu{3}. Para este
caso, criou-se o procedimento de formação de parceria por intersecção de
caminhos \setwayi, detalhado mais adiante.

Na Seção~\ref{subsec:desconexao}, apresenta-se uma discussão geral sobre o
comportamento do GMTP em outros casos de desconexões. O procedimento de formação
de parceria intra \setwayi, apresentado nesta seção, está intimamente
relacionado com o processo de estabelecimento de conexão do GMTP, detalhado mais
adiante na Seção~\ref{subsec:conexao-requisicao}.


\subsection{Eleição de nós \rel}
\label{subsec:electrelsreps}

Para um fluxo de dados \setpk, o primeiro nó \rels será o nó \clis que iniciar a
primeira conexão unicast para obter o referido fluxo. Os seguintes nós \rels
serão os próximos nós \clis que se conectar para receber o fluxo de dados
\setpk, até atingir um parâmetro que determinará a quantidade máxima de nós
\rels por fluxo de dados \setpk. Tal parâmetro pode ser determinado pelo
administrador do nó \repass.

Sendo assim, à medida que um nó \repasss recebe pacotes do tipo
\pac{GMTP-Request}, no pacote de resposta \pac{GMTP-Response}, o nó
\repasss ativa um indicador sinalizando que o referido nó \clis em processo de
conexão deverá se comportar como um nó \rel, passando a enviar relatórios
da taxa de transmissão calculada por ele. Note que este modo de transmissão deve
ser implementado com garantia de entrega, ou seja, com a confirmação de recepção
de pacotes e retransmissão caso este tipo de pacote seja perdido. Assim, um nó
\repasss poderá ter controle sobre a quantidade de nós \rels e receber
relatórios apenas dos nós \rels $\in$ \setrel.

Uma outra situação que se faz necessária a eleição de nós \rels é no
procedimento de desconexão, como explicado na Seção~\ref{subsec:desconexao}.
Para esse caso, quando o nó \repasss receber o pacote do tipo
\pac{GMTP-Close}, este deve verificar se o referido nó \clis é um nó \rel. Em
caso afirmativo, o nó \repasss deve transmitir para um dos nós \clis que
também recebe o referido fluxo de dados \setpks (se houver), um pacote do tipo
\pac{GMTP-Elect-Request} e aguardar por um \pac{GMTP-Elect-Response}. Este procedimento
deve ocorrer com garantia de entrega.






% Ao \mudccps foi incorporado um mecanismo de tolerância a desconexão que
% funciona de modo a evitar que os nós clientes deixem de receber dados da
% transmissão em questão, caso um nó relay desconecte repentinamente sem conseguir
% transmitir um pacote do tipo \mudccp-ElectAck, tal como explicado na
% Seção~\ref{subsec:mudccp-desconexao}. Considere $T$ uma variável corresponde a
% $4$ vezes o valor do tempo do RTT. Um nó relay deve transmitir no canal de
% controle um pacote do tipo \mudccp-AdvConn a cada instante de $T$, anunciando
% aos demais nós da rede que está ativo e operando corretamente. Caso um nó relay
% secundário não receba o pacote do tipo \mudccp-AdvConn durante o período de
% tempo $T$, assume-se que o relay atual foi desconectado por algum motivo
% desconhecido e o relay secundário que não recebeu o pacote do tipo
% \mudccp-AdvConn deverá transmitir um pacote do tipo \mudccp-ElectAck. Na
% prática, o nó relay secundário torna-se um nó relay primário do o grupo de
% clientes, incluindo os nós reporters, conectados ao relay que foi desconectado.
% Neste caso, o novo nó relay deve iniciar um novo processo de estabelecimento de
% conexão. Após o estabelecimento dessa conexão, como descritos na
% Seção~\ref{sec:conexaomudccp}, o novo nó relay deve criar o canal de repasse e
% começa a repassar os dados da transmissão multimídia.


% \subsection{Adaptação de Fluxo de Dados}
% \label{subsec:adapt-flow}
%
% \begin{figure}[ht]
% \begin{center}
% \includegraphics[natwidth=794,natheight=170,scale=.73]{imgs/bucket-brigade-principle-2.png}
% \end{center}
% \vspace{-0.8cm}
% \caption{Uma aplicação pode não ter recurso suficiente, adaptações devem ser realizadas.}
% \label{fig:bucket-brigade-principle-2}
% \end{figure}
%
%
% Uma funcionalidade peculiar do \mudccps é sua capacidade de permitir a
% realização de adaptação de fluxos multimídia de forma distribuída. A maioria
% das soluções para transmissão de dados multimídia, além de realizar controle
% de congestionamento no nível de aplicação, realizam adaptação de fluxo
% multimídia na fonte geradora dos dados. Em diversas soluções
% existentes, os autores consideram a transmissão de fluxos de dados multimídia
% adaptados e transmitidos em diferentes canais, sendo que em cada canal
% transmite-se os fluxos multimídia em uma determinada qualidade. Dependendo da
% qualidade desejada pelo nó receptor, o sistema cliente solicita a transmissão em
% um determinado canal. O problema dessa abordagem é que o nó transmissor,
% necessariamente deve transmitir os dados em múltiplos canais, o que aumenta a
% complexidade da aplicação e a quantidade de fluxos de dados sendo transmitidos a
% partir do servidor.
%
% No \mudccp, é possível realizar a adaptação de fluxo de dados de forma
% distribuída, na prática, em cada relay. Por exemplo, considere duas redes
% adjacentes, rede 1 e rede 2. Considere que existe um nó relay na rede 1 e entre
% a rede 1 e o nó transmissor a largura de banda de transmissão disponível seja de
% \ut{100}{Mbps}. Caso a largura de banda disponível na rede 2 seja de no
% máximo \ut{10}{Mbps}, um nó receptor na rede 2 teria que solicitar um fluxo
% multimídia em um canal diferente, considerando as soluções que adotam a
% estratégia de adaptação de fluxo com o uso de múltiplos canais de transmissão.
% No caso do \mudccps é possível que um nó na rede 2 obtenha o fluxo multimídia
% através do relay presente na rede 1, com o relay da rede 1 adaptando o fluxo
% multimídia de acordo com a capacidade do canal de transmissão disponível para a
% rede 2. Desta forma, pode-se diminuir o tráfego na rede do nó transmissor e
% ainda permitir que nós em redes com largura de banda limitada consigam obter o
% fluxo multimídia adaptado (caso mais comum para clientes residenciais).
%
%
%
%
%
%
%
%
%
%
% Com essa estratégia, fica óbvio que quanto mais requisições de
% \textit{pull} por uma parte da mídia, mais urgente é o seu conteúdo para
% reprodução. Muitas requisições via \textit{pulling} é um sinal que a rede não
% está sendo capaz de entregar \pks tão rápido quanto o suficiente para permitir
% a reprodução sem que haja interrupções. Essa informação pode ser utilizada para
% adaptar o fluxo de dados \setpk, reduzindo-se sua qualidade e consequentemente
% exigindo menos da rede.
%
%
%
%
%

% \section{Implemetação e Implantação}
% \label{sec:impl}
%
% PROVER API PARA SETAR AS INFOS DO SDP
%
% O \mudccp\space não necessita explicitamente da instalação de um nó na rede para
% encaminhar o conteúdo de uma rede externa para uma rede interna
% (\textit{proxy}). Além disso, o \mudccp\space mantém a \textit{interface} de
% programação com a camada de aplicação inalterada, apenas adicionando uma
% extensão na API padrão de socket BSD para preservar a compatibilidade
% com as aplicações multimídia existentes e, ao mesmo tempo, permitir que as
% aplicações façam uso dos novos recursos do \mudccp. Esta decisão pode ajudar em
% uma rápida adoção do GMTP nas aplicações multimídia, permitindo-se simples
% alterações das aplicações existentes e, ao mesmo tempo, a efetiva padronização
% da forma como algumas funcionalidades hoje em dia são implementadas.


% \section{Benefícios, Aplicabilidade e Justificativas}
% \label{sec:benef}


%\subsection{Seleção de Parceiros e de \textit{Chunks}}

% \subsection{Balanceamento de Carga}
%
% Um outro aspecto interessante do protocolo \mudccps é sua capacidade em
% permitir divisão de carga entre nós relays. Como os nós relays recebem e
% repassam os fluxos de dados oriundos de um servidor, obtem-se natualmente uma
% solução de distribuição de conteúdo multimídia sem sobrecarregar a fonte
% geradora de dados (geralmente o servidor). Porém, mesmo considerando o
% mecanismo atualmente empregado no \mudccps para divisão de carga entre nós
% relays, atualmente estuda-se um mecanismo complementar de balanceamento de
% carga a fim de evitar que os nós relays entre em colapso de congestionamento
% devido ao grande número de clientes conectados a um determinado nó relay.
%
% Considerando isso, está em estudo no contexto do protocolo \mudccps um
% mecanismo
% de balanceamento de carga que quando um nó relay possui muitas conexões de
% clientes permite-se que outro nó cliente seja... PROBLEMA: UM RELAY POR REDE!


% \subsection{Outra Estratégia para Descoberta de Nós Relays}
% \label{sec:arcdescorels}
%
% Um aspecto primordial do \mudccps é a capacidade de obter fluxos de
% dados multimídia através de nós relays, os quais repassam esses dados vindo de
% uma fonte geradora. No processo de conexão, esses nós relays são encontrados,
% aceitam conexões de clientes e repassam dados da aplicação como se fossem o
% nó servidor. Um gargalo no procedimento padrão adotado no \mudccps é que pode-se
% demorar até que um cliente \mudccps encontre um nó relay e comece a receber o
% fluxo de dados desejado devido ao mecanismo de busca por profundidade por nós
% relays utilizando transmissões multicast, utilizando-se valores incrementais
% para o campo de TTL presente no cabeçalho IP.
%
% Diante disso, está em estudo no contexto desse trabalho um mecanismo alternativo
% para permitir que um nó cliente encontre um nó relay mais rapidamente. Este
% mecanismo consiste em permitir que um nó cliente solicite diretamente ao nó
% servidor a lista de nós relays conectados a ele, ou seja, a lista dos nós
% relays de primeiro nível (Figura~\ref{fig:cenario-global-detailed}).
%
% O mecanismo de busca por nós relays permitirá que o cliente consulte, ao longo
% dos níveis dos nós relays, aquele nó relay que mais se adequa aos requisitos da
% aplicação, principalmente com relação ao atraso observado desde do servidor até
% um determinado relay. Um nó cliente que desejar solicitar esse tipo de
% requisição, utiliza o pacote do tipo \mudccp-RelayQuery e transmite o pedido de
% consulta ao nó servidor, o qual responde ao cliente com a lista dos nós relays
% de primeiro nível utilizando o pacote do tipo \mudccp-RelayReply. Com isto, é
% possível encontrar um melhor relay cujo atraso não ultrapasse um determinado
% limiar de tempo definido pela aplicação, o que não necessariamente será o nó
% relay mais próximo geograficamente do nó cliente.



% , dentre
% outros referenciados em~\cite{REF, REF, REF, REF, REF}.

% discutir aqui sobre o que o protocolo trás de bom para as aplicações
%
% - cloud computing
%
% - transmissão de casa
%
% - vod
%
% - youtube/copa america
%
% - twitcam

% \section{Outros Aspectos Importantes do \mudccp}
%
% \subsubsection{Uso do Campo \textit{Offset} de Dados}
%
% \subsubsection{Uso do Campo \textit{CCVal} de Dados}
%
% \subsubsection{Soma de Verificação e Validação de Pacotes}
%
% \subsection{Compatibilidade com outras recomendação da IETF}
%
% - NAT - http://www.brynosaurus.com/pub/net/p2pnat/
% - 4340
% - GERAÇÃO DO NÚMERO DE SEQUÊNCIA
% - RFC2365
% - RFC4086
% - RFC2119
% - TFMCC 4654
% - 5166
% - TFRC 3448

%\section{Considerações sobre redes de distribuição de conteúdo}

%\section{Considerações sobre a escolha do DCCP como base para o \mudccp}

% \section{Considerações sobre implementação}

\section{Sumário do Capítulo}

Neste capítulo, apresentou-se os fundamentos do \textit{Global Media
Transmission Protocol} (\mudccp), um protocolo de transporte e rede baseado em
uma arquitetura híbrida P2P/CDN para distribuição de fluxos de dados multimídia
ao vivo. Tal arquitetura é caracterizadas por um conjunto de nós servidores que
obtém o conteúdo multimídia da fonte geradora e o transmite para muitos nós
receptores (\mys). O GMTP foi proposto para operar principalmente na Internet,
permitindo a transmissão de pacotes de dados com suporte a controle de
congestionamento sem garantia de entrega, tudo ocorrendo de forma transparente
para a aplicação. O GMTP opera na camada de transporte e rede da pilha de
protocolos GMTP, realizando transmissão em modo multicast ou de múltiplos fluxos
unicast compartilhados entre os nós participantes da transmissão. Neste segundo
caso, tal ação ocorre através de uma rede de favores constituída dinamicamente
entre os roteadores da rede, evitando a relação de uma conexão por cliente ao nó
servidor.

Ao contrário de todos os outro protocolos de transporte e das soluções de
aplicação para redes P2P, o foco de definição do GMTP foi reduzir
responsabilidade dos nós clientes e aumentar a responsabilidade dos roteadores
de rede no processo para distribuição de um determinado conteúdo multimídia.
Este foco teve como principal motivação a proposta das Redes Centradas no
Conteúdo (CCN), onde o roteador passa a ter um papel com maior participação no
processo de entrega de um conteúdo para os nós interessados. Com vistas nos
aspectos da CCN, o GMTP oferece um mecanismo de conexão separado em duas fases,
quando se decide a forma como um determinado nó cliente obterá o conteúdo de
interesse, contando com o suporte dos roteadores nesse processo. Nesse interim,
uma grande peculiridade do GMTP é a função que os nós roteadores
passam a ter de realizar parcerias entre si a fim de obter um determinado
conteúdo multimídia de interesse, identificado por um nome, como especificado
pela teoria das redes centradas no conteúdo.

Diversas estratégias adotadas no GMTP e apresentadas neste capítulo discutidas
são diferenciais que permitem a disseminação mais rapidamente de um determinado
fluxo de dados originado em um nó servidor. Incorporou-se um mecanismo de
\textit{registro de participação} que, após um nó repassador se registrar em um
nó servidor, permite-se que os servidores determinem quais são os candidatos a
parceiros de um nó repassador, o que ocorre periodicamente. A vantagem é que,
\textit{a priori}, permite-se que os nós repassadores avaliem seus parceiros sem
necessariamente um nó estar recebendo um fluxo de dados de um determinado
evento. Com isto, um nó repassador pode repassar um fluxo de dados para um outro
nó repassador sem que o primeiro tenha interesse no referido fluxo, mas devido
ao seu posicionamento na rede e sua capacidade computacional e de vazão, pode
melhorar o processo de disseminação de um determinado fluxo de dados. Além
disso, como se trata de uma rede de favores e os dados são trocados de forma
distribuída, ou seja, nem sempre com a participação de um nó servidor, pode-se
empregar um mecanismo para validação dos dados transmitidos pelo servidor,
evitando-se ataques de poluição, por exemplo.

No GMTP, os responsáveis por formar as parcerias P2P são os nós repassadores e
não mais os nós clientes, como em soluções tradicionais de distribuição de
conteúdo P2P. Como consequência, melhora-se o desempenho das transmissões de
conteúdos multimídia ao vivo, pois o GMTP não é influenciado por fatores que
impactam negativamente no funcionamento da rede P2P, tais como a capacidade de
processamento, armazenamento (memória), mobilidade e dinâmica de
conexão/desconexão (\textit{churn}) dos nós clientes. Esses dois últimos
fatores são mais críticos se comparados aos demais, principalmente com a
popularização dos dispositivos móveis e usar esse tipo de cliente para
compartilhar seus recursos em uma rede P2P não é apropriado.

Um aspecto importante do GMTP são seus dois algoritmos para controle de
congestionamento de fluxos de dados sem garantia de entrega, o \mudccp-UCC e o
\mudccp-MCC. No primeiro, a ser aplicado na transmissão de fluxos de dados
unicast entre os nós roteadores, emprega-se uma solução para controle de
congestionamento assistido pela rede, onde oferta-se para cada fluxo de dados
uma taxa de transmissão igual para todos os fluxos passando por todos os
roteadores de um caminho. Nesse caso, a taxa de transmissão é determinada de
acordo com a capacidade de transmissão do menor roteador em uma determinada
rota. Já no segundo algorimo, a ser aplicado em fluxos de dados multicast,
utiliza-se um algoritmo de controle de congestionamento baseado na equação TFRC
(\textit{TCP Friend Rate Control}), fazendo-se uso de nós especiais chamados de
relatores para determinar a próxima taxa de transmissão que o roteador deverá
utilizar para distribuir o conteúdo multimídia para os nós clientes diretamente
conectados a ele.

Por fim, discutiu-se sobre outras funcionalidades do protocolo \mudccp, tais
como seu mecanismo para finalização de conexão dos tipos de nós do GMTP, eleição
de nós relatores e considerações sobre segurança. No próximo capítulo,
apresentam-se os resultados e discussões acerca do uso do protocolo GMTP para a
distribuição de conteúdos multimídia ao vivo.