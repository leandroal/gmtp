\chapter{\mudccp: Transporte de Datagramas Controlados e Não Confiáveis para
Distribuição de Conteúdos Multimídia entre Pares na Internet}
\label{cap:mudccp}

% O {\emph{Multi(Uni)cast Datagram Congestion Control Protocol}} (\mudccp) é um
% protocolo de transporte inspirado no DCCP com foco em transmissão de fluxos de
% dados multimídia com um nó transmissor e muitos nós receptores (\mys),
% desenvolvido para operar principalmente na Internet. O \mudccp\space permite a
% transmissão de pacotes de dados com suporte a controle de congestionamento de
% fluxos não confiáveis, operando em modo de transmissão multicast ou múltiplos
% fluxos unicast compartilhados entre os nós participantes da transmissão,
% através
% de uma rede de favores constituída automaticamente a fim de evitar a relação
% de uma conexão por cliente ao servidor, como na versão original do DCCP.

Neste capítulo apresenta-se o protocolo proposto neste trabalho, denominado
\textit{Global Media Transmission Protocol} (\mudccp). O \mudccps é um protocolo
de transporte baseado em uma arquitetura P2P para distribuição de fluxos de
dados multimídia de aplicações com um nó transmissor e muitos nós receptores
(\mys), desenvolvido para operar principalmente na Internet. O \mudccp\space
permite a transmissão de pacotes de dados com suporte a controle de
congestionamento de fluxos não confiáveis, operando em modo de transmissão
multicast ou múltiplos fluxos unicast compartilhados entre os nós participantes
da transmissão, através de uma rede de favores constituída dinamicamente a fim
de evitar a relação de uma conexão por cliente ao servidor, como acontece em
protocolos unicast de transporte de dados multimídia disponíveis na literatura.

FAZER UMA FIGURA APRESENTANDO UM CENÁRIO GERAL/GLOBAL SENDO CONSIDERADO

O \mudccp\space é um protocolo distribuído que funciona com a
cooperação de dois conjuntos de nós chamados de \mdrels\space e
\mdreps, eleitos automaticamente formando uma rede de sobreposição
(\textit{overlay network}) transparente para a aplicação
que o utiliza. Os nós \mdrels\space compartilham seus fluxos de dados
com um subconjunto de nós interessados pelo conteúdo multimídia, ao passo que os
nós \mdreps\space são responsáveis por enviar relatórios periódicos
sobre o estado da transmissão ao nó transmissor da mídia ao vivo ou a um
\mdrel, que os utilizam para regular a taxa de transmissão e assim impedir
que a rede entre em colapso de congestionamento.

% Ao contrário de outras soluções na camada de transporte para transmissão de
% dados multimídia ao vivo,

O \mudccp\space não necessita explicitamente da instalação de um nó na rede para
encaminhar o conteúdo de uma rede externa para
uma rede interna (\textit{proxy}). Além disso, o \mudccp\space mantém a
\textit{interface} de programação com a camada de aplicação inalterada, apenas
adicionando uma extensão na API padrão de \textit{socket} BSD para preservar a
compatibilidade com as aplicações multimídia existentes e, ao mesmo tempo,
permitir que as aplicações façam uso dos novos recursos do \mudccp. Esta
decisão pode ajudar em uma rápida adoção do GMTP nas aplicações multimídia,
permitindo-se simples alterações das aplicações existentes e, ao mesmo
tempo, a efetiva padronização da forma como algumas funcionalidades hoje em dia
são implementadas, tais como o estabelecimento de conexão, descoberta de nós e
controle de congestionamento.

% A principal motivação para o \mudccp\space está relacionada ao crescimento
% acentuado de aplicações que transmitem e recebem mídia ao vivo, mas que podem
% elevar os níveis de congestionamento da rede devido ao uso do UDP ou
% levarem estas ao fenômeno da tragédia dos comuns, no caso da utilização do TCP
% ou do DCCP (Seção~\ref{sec:problematica}). A estratégia para a
% definição do protocolo \mudccp\space baseou-se nas características dessas
% aplicações, considerando suas funcionalidades e arquiteturas discutidas na
% Seção~\ref{sec:arq_p2p_media_aovivo}, levando-se em
% conta os seguintes questionamentos:

A principal motivação para o \mudccp\space está relacionada ao crescimento
acentuado de aplicações que transmitem e recebem mídia ao vivo, mas que podem
elevar os níveis de congestionamento da rede ou levarem estas ao fenômeno da
tragédia dos comuns. A definição do protocolo \mudccp\space baseou-se nas
características dessas aplicações, considerando suas funcionalidades e
arquiteturas discutidas no Capítulo~\ref{cap:fundamentacao}, levando-se em
conta os seguintes questionamentos:

\begin{itemize}

 \item quais as funcionalidades das aplicações de transmissão de mídia ao vivo
que tiveram que ser implementadas na camada de aplicação por falta de um
protocolo de transporte de dados ideal para esse tipo de aplicação?

 \item quais dessas funcionalidades podem ser implementadas na
camada de transporte a fim de torná-las padronizadas para todas as aplicações
existentes e assim evitar o retrabalho de desenvolvimento (implementação de
controle de congestionamento, descoberta de recursos e nós etc.)?

 \item como se pode, de forma eficiente e padronizada, distribuir conteúdos
multimídia entre os nós conectados a uma rede mesmo quando diferentes
aplicações estiverem sendo utilizadas pelos usuários, mas com estes
tendo o mesmo interesse por uma determinada transmissão?

\end{itemize}

Diante dessas questões, primeiramente observou-se que os desenvolvedores de
sistemas para transmissão de conteúdo multimídia ao vivo na Internet preferem o
modelo de serviço P2P ao modelo de serviço cliente-servidor -- e diversos
trabalhos disponíveis na literatura dão suporte a esta preferência; observou-se
também que, nos sistemas desse tipo não implementam-se mecanismos para controle
de congestionamento e, quando o fazem, os desenvolvedores são forçados a
realizá-lo na camada de aplicação, sem qualquer padronização na forma como os
fluxos de dados (conexões) são controlados, com diferentes equipes de
desenvolvimento implementando, das mais variadas formas, a mesma funcionalidade
presente nesse tipo de aplicação, sem qualquer compartilhamento desse esforço;
observou-se que não há uma forma efetiva de centralizar e/ou disponibilizar as
boas soluções e práticas (algoritmos) para descoberta de recursos e nós na rede,
sobretudo soluções para inferir o estado da rede e notificar a aplicação que ela
precisa, por exemplo, adaptar o conteúdo multimídia sendo transmitido.

Sendo assim, é notório que os desenvolvedores de aplicações para transmissão de
mídia ao vivo constantemente se depararam com os mais variados problemas no
contexto de descoberta de nós e recursos; estabelecimento e finalização de
conexão; controle de congestionamento; seleção de nós parceiros; tratamento de
desconexões e busca por nós alternativos; dentre outros. Diante dessa atual
conjuntura, o \mudccps surgiu como um protocolo de transporte da pilha de
protocolos TCP/IP objetivando padronizar a forma como os desenvolvedores
implementam as principais funcionalidades dessas aplicações e, sobretudo,
permitindo que estas sejam implementadas de tal forma a promover o reúso das
soluções e utilizar-se dos recursos de rede de forma mais eficiente.

Neste capítulo, discute-se o protocolo \mudccps considerando uma visão geral,
ou seja, sem muitos detalhes técnicos, ao passo que no Capítulo seguinte, mais
detalhes técnicas são abordados. Para iniciar, apresentam-se as funcionalidades
do \mudccp, começando com a definição de
alguns termos e considerações importantes.

% Neste capítulo, discute-se o protocolo \mudccps considerando uma visão geral,
% ou seja, sem muitos detalhes técnicos, ao passo que no Capítulo seguinte, mais
% detalhes técnicas são abordados. Para iniciar, apresentam-se as funcionalidades
% do \mudccp, começando com a definição de
% alguns termos e considerações importantes.

\section{Definições, Terminologias e Convenções}

Para facilitar o entendimento das funcionalidades do \mudccp, nesta seção,
apresentam-se algumas definições, terminologias e convenções utilizadas no
restante deste documento.

\begin{description}
 \item[Nó \mudccp:] um sistema final capaz de executar o protocolo \mudccp, ou
seja, um nó de rede capaz de interpretar os cabeçalhos dos pacotes definidos
pelo \mudccp\space e realizar ações pré-definidas;
 \item[Servidor de mídia \mudccps ou Servidor \mudccp:] um programa de
computador
em execução em um nó \mudccps que captura e transmite na rede mídias ao vivo;
 \item[Cliente \mudccp:] um programa de computador em execução em um nó
\mudccps interessado em receber mídias ao vivo enviadas por um servidor \mudccp;
 \item[\mdrel:] Cliente \mudccps especial que compartilha fluxos de dados
com um subconjunto de clientes \mudccp;
 \item[\mdrep:] Cliente \mudccps especial responsável por enviar relatórios
periódicos sobre o estado da transmissão ao servidor \mudccp\space ou a um
\mdrel;
 \end{description}

COLOCAR FIGURA DE CONJUNTO: UM RELAY É UM CLIENTE E FUNCIONA COMO SERVIDOR

Na Seção~\ref{sec:tiposnosmudccp}, detalham-se as principais funcionalidades de
cada um desses tipos de nós \mudccp. Deste ponto em diante considere os termos
\textit{cliente \mudccp}, \textit{servidor \mudccp}, \textit{\mdrel} e
\textit{\mdrep} em sua forma simplificada, ou seja, \textit{cliente},
\textit{servidor}, \textit{relay} e \textit{reporters}, respectivamente, exceto
quando explicitamente mencionado de outra forma. Estes termos não serão mais
formatados em itálico.

As palavras \aspas{deve}, \aspas{não deve}, \aspas{requerido}, \aspas{pode},
\aspas{não pode}, \aspas{recomendado} e \aspas{opcional}, incluindo suas
variações morfológicas, devem ser interpretadas como descrito na RFC
2119~\cite{RFC2119}, em inglês.

Embora alguns autores considerem os termos \aspas{repasse} e
\aspas{roteamento} como conceitos distintos, neste trabalho ambos os termos são
considerados sinônimos e devem ser interpretados como a capacidade que um nó
\mudccps tem de receber dados em uma interface de rede de entrada e encaminhar
estes dados através de uma interface de rede de saída, permitindo-se que uma
mesma interface de rede seja utilizada como entrada e saída ao mesmo tempo.

Todos os bytes no \mudccp, tais como números de portas, números de seqüência e
valores para opções são transmitidos em \textit{network byte order} (primeiro os
bytes mais significativos).

Os números aleatórios no \mudccps são utilizados por razões de segurança e podem
ser escolhidos de acordo com a RFC 4086~\cite{RFC4086}.

%    We occasionally refer to the "left" and "right" sides of a bit field.
%    "Left" means towards the most significant bit, and "right" means
%    towards the least significant bit.
% 
%    All operations on DCCP sequence numbers use circular arithmetic
%    modulo 2^48, as do comparisons such as "greater" and "greatest".
%    This form of arithmetic preserves the relationships between sequence
%    numbers as they roll over from 2^48 - 1 to 0.  Implementation
%    strategies for DCCP sequence numbers will resemble those for other
%    circular arithmetic spaces, including TCP's sequence numbers [RFC793]
%    and DNS's serial numbers [RFC1982].  It may make sense to store DCCP
%    sequence numbers in the most significant 48 bits of 64-bit integers
%    and set the least significant 16 bits to zero, since this supports a
%    common technique that implements circular comparison A < B by testing
%    whether (A - B) < 0 using conventional two's-complement arithmetic.
% Reserved bitfields in DCCP packet headers MUST be set to zero by
%    senders and MUST be ignored by receivers, unless otherwise specified.
%    This allows for future protocol extensions.  In particular, DCCP
%    processors MUST NOT reset a DCCP connection simply because a Reserved
%    field has non-zero value [RFC3360].

\section{Visão Geral do \mudccp\space}

Antes de entrar em detalhe sobre o funcionamento das características do
\mudccp, nesta seção apresenta-se uma visão geral do \mudccp.

\begin{itemize}

    \item o processo de conexão acontece em três-vias (\textit{3WHS}),
porém transmite-se o pedido de conexão em modo multicast com
TTL=\{1..\textit{n}\} (com \textit{n} configurável ou limitado pelo RTT), a fim
de descobrir a existência de nós relays conectados ao mesmo destino (IP e porta)
desejado;

    \item detecção automática do modo de transmissão multicast e chaveamento
automático entre esse modo e o modo de múltiplos fluxos unicast;

    \item compartilhamento de fluxos de dados entre nós da mesma rede e com
suporte a controle de congestionamento;

    \item eleição automática de nós \mdrels\space e \mdreps;

    \item opções de negociação de parâmetros da conexão com confirmação de
recebimento, incluindo negociação do mecanismo de controle de congestionamento a
ser utilizado e notificação sobre as eleições de nós \mdrels\space e
\mdreps;

    \item controle de congestionamento com suporte a ECN (\emph{Explicit
Congestion Notification}), inclusive em modo multicast;

    \item arcabouço para descoberta de nós \mdrels, permitindo assim que
novos algoritmos para descoberta de nós sejam adicionados ao protocolo como
módulos do sistema operacional;

    \item tolerância a desconexões de \mdrels\space e \mdreps, com
reeleição automática desses conjuntos de nós;

    \item mecanismo para reduzir o atraso fim-a-fim causado por muitos níveis de
repasses entre os \mdrels. O protocolo é capaz de decidir se deve obter a
mídia ao vivo de um \mdrel\space ou se deve conectar diretamente ao nó servidor,
baseando-se em alguns critérios como o RTT, número de saltos entre o
cliente \mudccps e o servidor \mudccps etc.

\end{itemize}

COLOCAR AQUI UMA FIGURA ILUSTRANDO O CENÁRIO GERAL, COM VÁRIOS GMTPS RELAYS,
REPORTERS, SERVIDOR DE MÍDIA e CLIENTES


A fim de pôr em prática as funcionalidades descritas anteriormente, faz-se
necessário definir um conjunto de pacotes de dados que serão trocados entre
um cliente \mudccps e um servidor \mudccps ou um \mdrel. Como em qualquer
protocolo de rede, os cabeçalhos dos pacotes de dados são de grande importância
para o funcionamento do protocolo e para o \mudccps isto não é diferente. Desta
forma, na próxima seção, apresenta-se os cabeçalhos e tipos de pacotes definidos
para o \mudccp, os quais são processados por qualquer nó \mudccps com o
objetivo de realizar uma determinada ação.

\section{Cabeçalhos e Tipos de Pacotes do \mudccp}
\label{sec:tipodepacotesmudccp}

Na Figura~\ref{fig:cabecalhomudccp48}, ilustra-se o cabeçalho genérico do
\mudccp. O nome genérico é justificado porque o cabeçalho assume um
formato diferente dependendo do tipo de pacote transmitido. De acordo com o
tipo de pacote transmitido, o \mudccps poderá utilizar até $48$ bits para
diferentes finalidades e, nesses casos, o tamanho total do cabeçalho passa a ser
de $20$ bytes.

\begin{figure}[h]
    \begin{center}
        \includegraphics[scale=0.5]{imagens/mudccp-generic-header.pdf}
    \end{center}
    \vspace{-1.2cm}
    \caption{Cabeçalho Genérico do protocolo \mudccp.}
    \label{fig:cabecalhomudccp48}
\end{figure}

Os campos do cabeçalho são definidos como segue:

\begin{description}
  \item[Porta de origem e destino:] cada porta possui um tamanho de $16$ bits.
Estes campos identificam a conexão, como acontece com os protocolos TCP, UDP e
o DCCP;
  \item[\emph{\textit{Offset} de dados}:] ou simplesmente \emph{offset},
determina o tamanho do cabeçalho DCCP, contando do início do cabeçalho até o
início de onde estão os dados da aplicação. Este campo tem o tamanho de $8$
bits;
  \item[CCVal:] é utilizado pelo controle de congestionamento do sistema
transmissor. O tamanho desse campo é de $4$ bits. Em uma transmissão \mudccps
entre um cliente e um servidor \mudccps ou de um \mdrel, o CCID de cada lado
pode enviar $4$ bits de informação para o lado oposto, sendo estes bits
armazenados em CCVal;
  \item[Tipo do pacote:] tamanho de $4$ bits. Este campo determina o tipo de
pacote que está sendo transmitido/recebido. Os possíveis valores desse campo
serão apresentados na Seção~\ref{subsec:tipopacote-mudccp};
  \item[\emph{Checksum}:] tamanho de $16$ bits. Este campo é utilizado para
checagem de erro, tradicionalmente como acontece em outros protocolos como o TCP
e o UDP;
  \item[Número de seqüência:] número de seqüência com $32$ bits utilizado para
transmitir requisições, podendo ser estendido para $48$ bits ao utilizar-se dos
próximos $16$ bits de conteúdo variável, o que dependerá do tipo de pacote a ser
transmitido. Como em outros protocolos, este campo identifica unicamente um
pacote transmitido na rede por um sistema final. O valor deste campo aumenta-se
em $1$ a cada pacote transmitido;
  \item[Opção:] tamanho de $4$ bits. Este campo é utilizado para sinalizar a
ativação ou não de alguma opção do \mudccp, por exemplo, para sinalizar se a
conexão entre um cliente e um relay \mudccps deve ser unicast ou multicast;
  \item[Reservado:] tamanho de $12$ bits. Campo reservado para utilizações
futuras;
  \item[Conteúdo variável:] tamanho de $48$ bits. Campo reservado para uso em
mecanismos específicos do \mudccps como, por exemplo, especificar o endereço IP
e número da porta do servidor \mudccps no momento de uma conexão
multicast.
\end{description}

\subsection{Tipos de Pacotes}
\label{subsec:tipopacote-mudccp}

Como discutido anteriormente, o cabeçalho do protocolo \mudccps apresenta um
campo denominado \emph{tipo do pacote}. Este campo determina que informação está
contida em um determinado pacote \mudccps e permite que um nó \mudccp\space
execute uma determinada ação. Na Tabela~\ref{tab:tipospacotemudccp} são
apresentados os possíveis valores desse campo, nome do pacote e sua respectiva
descrição.

\begin{table}[h]
        \caption{Tipos de Pacotes do protocolo \mudccp.}
        \label{tab:tipospacotemudccp}
    \begin{center}
	\vspace{-0.8cm}
        \begin{tabular}{|p{1.0cm}|p{1.5cm}|p{1.5cm}|}
            \hline

\multicolumn{1}{|>{\columncolor[rgb]{0.05,0.2,0.43}}c}{\textcolor{white}{\textbf
{\#}}} &
\multicolumn{1}{|>{\columncolor[rgb]{0.05,0.2,0.43}}c|}{\textcolor{white}{
\textbf{Tipo}}} &
\multicolumn{1}{>{\columncolor[rgb]{0.05,0.2,0.43}}c|}{\textcolor{white}{\textbf
{Descrição}}}
	    \\
	    \hline
	    \hline
            \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c}{\textbf{0}}
& \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c|}{Request} &
\multicolumn{1}{>{\columncolor[rgb]{0.66,0.7,0.759}}l|}{Pedido de
estabelecimento de conexão multicast}
	    \\

\multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c}{\textbf{1}} &
\multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c|}{Response} &
\multicolumn{1}{>{\columncolor[rgb]{0.913,0.929,0.957}}l|}{Resposta ao pedido de
estabelecimento de conexão multicast}
	    \\
            \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c}{\textbf{2}}
& \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c|}{Data} &
\multicolumn{1}{>{\columncolor[rgb]{0.66,0.7,0.759}}l|}{Contém dados da
aplicação}
	    \\

\multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c}{\textbf{3}} &
\multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c|}{Ack} &
\multicolumn{1}{>{\columncolor[rgb]{0.913,0.929,0.957}}l|}{Confirmação de
recebimento de pacote}
	    \\

            \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c}{\textbf{4}}
& \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c|}{DataAck} &
\multicolumn{1}{>{\columncolor[rgb]{0.66,0.7,0.759}}l|}{Dados da aplicação e
confirmação de recepção}
	    \\

\multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c}{\textbf{5}} &
\multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c|}{Elect} &
\multicolumn{1}{>{\columncolor[rgb]{0.913,0.929,0.957}}l|}{Inicia o processo de
eleição de um nó em relay ou reporter}
	    \\

\multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c}{\textbf{6}}
& \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c|}{ElectReply} &
\multicolumn{1}{>{\columncolor[rgb]{0.66,0.7,0.759}}l|}{Sinaliza o interesse de
um nó em se transformar em relay ou reporter}
	    \\

\multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c}{\textbf{7}} &
\multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c|}{ElectAck} &
\multicolumn{1}{>{\columncolor[rgb]{0.913,0.929,0.957}}l|}{Confirmação do nó
eleito para relay ou reporter}
	    \\

\multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c}{\textbf{8}}
& \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c|}{RelayQuery} &
\multicolumn{1}{>{\columncolor[rgb]{0.66,0.7,0.759}}l|}{Transmitido por um nó
para consultar a lista de relays}
	    \\

\multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c}{\textbf{9}} &
\multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c|}{RelayReply} &
\multicolumn{1}{>{\columncolor[rgb]{0.913,0.929,0.957}}l|}{Resposta ao pedido
de consulta da lista de relays}
	    \\

\multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c}{\textbf{10}}
& \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c|}{AdvConn} &
\multicolumn{1}{>{\columncolor[rgb]{0.66,0.7,0.759}}l|}{Utilizado por um nó
relay ou reporter para anunciar que está ativo na rede}
	    \\

\multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c}{\textbf{11}} &
\multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c|}{Reservado} &
\multicolumn{1}{>{\columncolor[rgb]{0.913,0.929,0.957}}l|}{Uso futuro e ignorado
pelo receptor}
	    \\

\multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c}{\textbf{12}} &
\multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c|}{Reservado} &
\multicolumn{1}{>{\columncolor[rgb]{0.66,0.7,0.759}}l|}{Uso futuro e ignorado
pelo receptor}
	    \\

\multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c}{\textbf{13}} &
\multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c|}{CloseReq} &
\multicolumn{1}{>{\columncolor[rgb]{0.913,0.929,0.957}}l|}{Servidor ou
Relay solicita término de conexão sem TIMEWAIT}
	    \\

            \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c}{\textbf{14}}
& \multicolumn{1}{|>{\columncolor[rgb]{0.66,0.7,0.759}}c|}{Close} &
\multicolumn{1}{>{\columncolor[rgb]{0.66,0.7,0.759}}l|}{Servidor/Cliente/Relay
solicita término da conexão}
	    \\
\multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c}{\textbf{15}} &
\multicolumn{1}{|>{\columncolor[rgb]{0.913,0.929,0.957}}c|}{Reset} &
\multicolumn{1}{>{\columncolor[rgb]{0.913,0.929,0.957}}l|}{Determina,
incondicionalmente, o final da conexão}
	    \\
            \hline
        \end{tabular}
    \end{center}
% 	\scriptsize
% 	$^1$ O tipo de pacote \textbf{\mudccp-Reset} é utilizado com este
% propósito, porém utiliza-se também para outros motivos: para sinalizar número de
% porta incorreto; comportamento inapropriado de opções; desconexão prevista de um
% \mdrel\space etc.
\end{table}

\normalsize

\subsubsection{\mudccp-Request}

O pacote do tipo \mudccp-Request, número 0 (0000$_2$), é utilizado pelo cliente
\mudccps para enviar um pedido de estabelecimento de conexão em modo multicast.
Quando transmitido na rede, um nó \mdrel\space captura esse tipo de pacote e
responde ao cliente \mudccp, notificando-o a respeito do fluxo de interesse e
que este é um dos \mdrels\space do servidor de mídia \mudccp. Considerando o
cabeçalho genérico do \mudccps ilustrado na
Figura~\ref{fig:cabecalhomudccp48}, os dois campos variáveis desse cabeçalho
são utilizados. Como pode-se observar na
Figura~\ref{fig:cabecalhomudccp-request}, o campo variável de $16$ bits é
utilizado para armezenar o número da porta do servidor de mídia \mudccps e o
segundo campo de $32$ bits é utilizado para armazenar o endereço IP desse
servidor. No processo de conexão, esses dois campos variáveis são lidos por um
\mdrel\space a fim de identificar o fluxo de mídia desejado pelo usuário e, caso
exista algum \mdrel\space recebendo o fluxo de mídia de interesse, o mesmo
responde pelo pedido de conexão como se fosse o servidor de mídia \mdrel\space
original, utilizando-se do pacote \mudccp-Response, descrito a seguir. Na
Seção~\ref{sec:conexaomudccp}, discutem-se detalhes do processo de
estabelecimento de conexão do \mudccp.

\begin{figure}[h]
    \begin{center}
        \includegraphics[scale=0.5]{imagens/mudccp-header-request.pdf}
    \end{center}
    \vspace{-1.2cm}
    \caption{Cabeçalho do pacote \mudccp-Request.}
    \label{fig:cabecalhomudccp-request}
\end{figure}

\subsubsection{\mudccp-Response}

O pacote do tipo \mudccp-Response, número 1 (0001$_2$), é utilizado pelo
\mdrel\space para enviar uma resposta a um pedido de estabelecimento de conexão
enviado por um cliente \mudccps em modo multicast. Quando um nó \mdrel\space
recebe um pacote \mudccp-Request, este cria um pacote do tipo \mudccp-Response
para informar ao cliente \mudccps sobre o estabelecimento de conexão.
Neste caso e considerando o cabeçalho genérico do \mudccps ilustrado na
Figura~\ref{fig:cabecalhomudccp48}, os dois campos variáveis desse cabeçalho
são utilizados. Como pode-se observar na
Figura~\ref{fig:cabecalhomudccp-response}, o campo variável de $16$ bits é
utilizado para armezenar o número da porta do \mdrel\space e o segundo campo de
$32$ bits é utilizado para armazenar o endereço IP desse Relay. Desta forma, um
cliente \mudccps é capaz de ler pacotes do tipo \mudccp-Data transmitidos por um
\mdrel\space via multicast na rede e reproduzir a mídia de interesse. O tipo de
pacote \mudccp-Data e \mudccp-DataAck são descritos a seguir.

\begin{figure}[h]
    \begin{center}
        \includegraphics[scale=0.5]{imagens/mudccp-header-response.pdf}
    \end{center}
    \vspace{-1.2cm}
    \caption{Cabeçalho do pacote \mudccp-Response.}
    \label{fig:cabecalhomudccp-response}
\end{figure}

\subsubsection{\mudccp-Data e \mudccp-DataAck}

Os pacotes do tipo \mudccp-Data e \mudccp-DataAck, números 2 e 4 (0010$_2$ e
0100$_2$), respectivamente, são utilizados por um \mdrel\space para enviar dados
em modo multicast a todos os clientes \mudccps interessados pelo fluxo por ele
transmitido. A partir do momento que um nó \mudccps se torna um nó \mdrel,
através do processo de eleição de nós \mdrels, descrito na
Seção~\ref{subsec:electrelsreps}, este começa a retransmitir, em modo multicast,
os dados vindos do servidor de mídia \mudccps ou de outro \mdrel,
utilizando pacotes dos tipos \mudccp-Data ou \mudccp-DataAck para este fim.
Neste caso, o cabeçalho genérico do \mudccps ilustrado na
Figura~\ref{fig:cabecalhomudccp48}, passa a ter a forma dos cabeçalhos
ilustrados nas Figuras~\ref{fig:cabecalhomudccp-data}
e~\ref{fig:cabecalhomudccp-dataack}, respectivamente. Note que ambos pacotes não
possuem os campos endereço IP e porta relacionados ao servidor de mídia \mudccp.
Esta decisão foi intencional para forçar que um cliente \mudccps realize o
pedido de conexão enviando o pacote \mudccp-Request, caso contrário um cliente
\mudccps poderia capturar um pacote \mudccp-Data sem que um \mdrel\space
soubesse de sua existência.

\begin{figure}[h]
    \begin{center}
        \includegraphics[scale=0.5]{imagens/mudccp-header-data.pdf}
    \end{center}
    \vspace{-1.2cm}
    \caption{Cabeçalho do pacote \mudccp-Data.}
    \label{fig:cabecalhomudccp-data}
\end{figure}

\begin{figure}[h]
    \begin{center}
        \includegraphics[scale=0.5]{imagens/mudccp-header-dataack.pdf}
    \end{center}
    \vspace{-1.2cm}
    \caption{Cabeçalho do pacote \mudccp-DataAck.}
    \label{fig:cabecalhomudccp-dataack}
\end{figure}

\subsubsection{\mudccp-Ack}

O pacote do tipo \mudccp-Ack, número 3 (0011$_2$), é utilizado por um nó
\mudccps para enviar confirmações de recepção de pacotes contendo dados
enviados com garantia de entrega. Por exemplo, um pacote \mudccp-Ack pode ser
enviado por um \mdrel\space para confirmar pacotes de definições de opções de
uma conexão \mudccps ou por um nó \mudccps ao aceitar ser eleito para ser
um \mdrep.

\begin{figure}[h]
    \begin{center}
        \includegraphics[scale=0.5]{imagens/mudccp-header-ack.pdf}
    \end{center}
    \vspace{-1.2cm}
    \caption{Cabeçalho do pacote \mudccp-Ack.}
    \label{fig:cabecalhomudccp-ack}
\end{figure}

\subsubsection{\mudccp-Elect, \mudccp-ElectReply e \mudccp-ElectAck}

Os pacotes do tipo \mudccp-Elect, \mudccp-ElectReply e \mudccp-ElectAck, números
5, 6 e 7 (0101$_2$, 0110$_2$ e 0111$_2$), respectivamente, são utilizados por um
\mdrel\space ou por um cliente \mudccps para tratar do processo de eleição de
nós \mdreps\space ou de promoções de clientes \mudccps para se tornarem \mdrel.
Quando um \mdrel\space assume seu papel de repassar o fluxo de dados em modo
multicast para os clientes \mudccps interessados, o mesmo precisa obter
informações sobre o estado da rede. Para isto, um \mdrel\space cria um pacote do
 tipo \mudccp-Elect e transmite no canal multicast. Quando um cliente \mudccps
recebe um pacote deste tipo, o mesmo pode se candidatar a um \mdrep, enviando um
pacote do tipo \mudccp-ElectReply para o nó \mdrel\space que enviou o pacote
\mudccp-Elect. Como muitos nós \mudccps podem receber um pacote \mudccp-Elect, o
nó \mdrel\space utiliza o pacote do tipo \mudccp-ElectAck para confirmar a
eleição apenas de um subconjunto de clientes \mudccp.

Neste caso, para os pacotes \mudccp-Elect, \mudccp-ElectReply e
\mudccp-ElectAck, o cabeçalho genérico do \mudccps ilustrado na
Figura~\ref{fig:cabecalhomudccp48} passa a ter a forma dos cabeçalhos ilustrados
nas Figuras~\ref{fig:cabecalhomudccp-elect},
\ref{fig:cabecalhomudccp-electreply} e \ref{fig:cabecalhomudccp-electack},
respectivamente. Note que no pacote \mudccp-Elect, os campos variáveis de $16$ e
$32$ bits são utilizados para o \mdrel\space especificar um número de porta e
um endereço IP para o qual um cliente \mudccps enviará um pacote do tipo
\mudccp-ElectReply.

\begin{figure}[h]
    \begin{center}
        \includegraphics[scale=0.5]{imagens/mudccp-header-elect.pdf}
    \end{center}
    \vspace{-1.2cm}
    \caption{Cabeçalho do pacote \mudccp-Elect.}
    \label{fig:cabecalhomudccp-elect}
\end{figure}

\begin{figure}[h]
    \begin{center}
        \includegraphics[scale=0.5]{imagens/mudccp-header-electreply.pdf}
    \end{center}
    \vspace{-1.2cm}
    \caption{Cabeçalho do pacote \mudccp-ElectReply.}
    \label{fig:cabecalhomudccp-electreply}
\end{figure}

\begin{figure}[h]
    \begin{center}
        \includegraphics[scale=0.5]{imagens/mudccp-header-electack.pdf}
    \end{center}
    \vspace{-1.2cm}
    \caption{Cabeçalho do pacote \mudccp-ElectAck.}
    \label{fig:cabecalhomudccp-electack}
\end{figure}

\subsubsection{Outros pacotes: \mudccp-RelayQuery,
\mudccp-RelayReply, \mudccp-AdvConn, \mudccp-CloseReq, \mudccp-Close
e \mudccp-Reset}

Os pacotes \mudccp-RelayQuery, \mudccp-RelayReply, \mudccp-AdvConn,
\mudccp-CloseReq, \mudccp-Close e \mudccp-Reset tem funções e formatos
similares aos outros pacotes anteriormente discutidos. O uso de cada um desses
pacotes será explicado ao longo das próximas seções deste capítulo.

\section{Tipos de Nós do \mudccp}
\label{sec:tiposnosmudccp}

\subsection{Cliente}

Um nó cliente \mudccps funciona apenas de forma passiva, recebendo o fluxo de
dados transmitido na rede e reproduzindo o conteúdo multimídia através da
aplicação em execução.

\subsection{Servidor}

O nó servidor \mudccps é aquele que transmite na rede o fluxo de dados
multimídia desejado, sendo geralmente o nó gerador do conteúdo multimídia. O nó
servidor mantém conexões de nós relays.

\subsection{Relay e Reporter}

O nó relay \mudccps sempre funcionará com o uso de três \textit{sockets}. O
primeiro é um \textit{socket} através do qual o relay recebe o fluxo de
dados vindo do servidor (ou de outro relay); o segundo \textit{socket}
corresponde ao canal multicast de comunicação utilizado pelo protocolo \mudccps
para trocar mensagens de controle; e o terceiro \textit{socket} é utilizado para
repassar os dados recebidos pelo relay para a rede local em modo multicast. A
principal responsabilidade de um nó relay é repassar os fluxos de dados vindo do
nó servidor ou de um outro nó relay para os clientes conectados a ele.

O nó reporter \mudccps é responsável por enviar relatórios de congestionamento
para o nó relay. O nó relay utiliza esse relatório para definir suas próximas
taxas de transmissão. Note que tanto o relay quanto o reporter são nós clientes.

\section{Canais de Comunicação do \mudccp}
\label{sec:canaiscommudccp}

No protocolo \mudccp, utilizam-se três canais de comunicação para implementar
suas funcionalidades. Esses três canais são, na prática, \textit{sockets}
criados pelo \mudccp, na camada de transporte, sem que a aplicação tenha
influência direta sobre eles.

\subsection{Canal de Controle}

Como já foi dito anteriormente, o protocolo \mudccps constrói uma rede de
sobreposição para fazer com que os nós participantes enviem e recebam dados
multimídia através da rede. No contexto do \mudccp, para que uma rede de
sobreposição seja constituída, é necessário executar alguns procedimentos,
tais como estabelecimento de conexão entre os nós participantes da rede,
descoberta e notificações de desconexões dos nós, eleição de nós relays e nós
reporters, envio e recebimento de relatórios para controle de congestionamento,
entre outros. Tais recursos são fundamentais para o funcionamento do \mudccp,
fazendo-o um protocolo original e diferente dos demais encontrados na
literatura. Dois ou mais nós utilizam o canal de controle do \mudccps a fim de
executar as funcionalidades supracitadas.

Desta forma, é obrigatório que todo nó \mudccps ao iniciar uma instância do
protocolo \mudccps deve criar um \emph{socket} multicast no endereço IP
238.255.255.250 e na porta $1900$. Através desse \textit{socket}, um nó \mudccps
é capaz de enviar e receber pacotes de controle utilizados para implementar as
funcionalidades apresentadas anteriormente. Este \textit{socket} multicast é de
suma importância no processo de conexão do \mudccps e na execução das suas
demais funcionalidades. Desse ponto em diante, este \textit{socket} multicast
será chamado de \textit{canal de controle de uma conexão \mudccp} ou
simplesmente \textit{canal de controle}.

Na prática, como o \mudccps é um protocolo de transporte e portanto implementado
no sistema operacional, o ciclo de vida do \textit{socket} do canal de controle
se inicia quando a primeira aplicação cria um socket \mudccps e termina quando
nenhuma aplicação estiver utilizando um \textit{socket} \mudccp.

A decisão do uso do endereço IP multicast 238.255.255.250 foi baseada na RFCs
2365~\cite{RFC2365}, que define o escopo administrativo do uso dos endereços
IPv4 multicast entre 239.0.0.0 e 239.255.255.255. O endereço 238.255.255.255 é
definido no escopo de uso global e por este motivo esse endereço foi o
escolhido. Com a padronização do protocolo \mudccps e a publicação da sua RFC,
será necessário solicitar registro do uso desse endereço IP multicast por parte
do protocolo \mudccps através da \textit{Internet Assigned Numbers Authority} -
IANA\footnote{IANA: http://www.iana.org/}.

FIGURA COM O CANAL DE CONTROLE

\subsection{Canal de Repasse}

Além do canal de controle, define-se no protocolo \mudccps um canal de repasse
utilizado por um nó relay para repassar os dados vindos de um servidor ou de
outro relay para a rede local. Esse canal de repasse, na prática, é um
\textit{socket} multicast criado pelo relay para transmitir dados para os
clientes localizados em sua rede local e que tem interesse em reproduzir o mesmo
fluxo de dados recebido pelo nó relay.

O \textit{socket de repasse dos dados} deve ser criado quando um cliente se
promove a relay. Na prática, quando isto acontece, o relay deve criar um
\textit{socket} multicast em um endereço IP e número de porta escolhida
aleatoriamente para repassar os dados vindos do servidor ou de outro relay para
dentro da rede local do relay. Isto permitirá que outros clientes recebam os
dados vindo do servidor através do seu relay local. A faixa de endereços IP
multicast que um cliente deve utilizar para criar seu \textit{socket} de repasse
é a de escopo local 239.192.0.0/14, definida também na RFC 2365~\cite{RFC2365}.

No caso de ocorrer a padronização do protocolo \mudccps e a publicação da sua
RFC, não será necessário solicitar registro do uso dessa faixa de endereços IP
multicast por se tratar de uma faixa de domínio local.

Um outro canal de repasse pode ser criado por um relay caso um cliente
interessado em seu conteúdo esteja localizado em outra rede que não seja a
mesma do relay. Nesse caso, o relay deve criar um canal de repasse unicast
utilizando o protocolo DCCP padrão e informar ao cliente o endereço IP e porta
que este deve se conectar para obter os dados.

FIGURA COM O CANAL DE REPASSE

\subsection{Canal de Recepção de Dados}

O canal de recepção de dados é um \textit{socket} multicast criado por um
cliente quando o mesmo encontra um relay transmitindo o fluxo de dados de
interesse dele em algum endereço IP da faixa 239.192.0.0/14. Nesse caso, os
dados transmitidos por um relay devem ser recebidos por um cliente através
desse relay.

Alternativamente, um canal de recepção de dados será um \textit{socket} unicast
quando um cliente não encontra nenhum relay em sua rede local e terá que se
conectar a outro relay localizado fora da sua rede. O endereço IP e o número de
porta que o cliente deve se conectar é determinado pelo relay no momento da
conexão através do pacote do tipo \mudccp-Response, como será discutido mais
adiante.

FIGURA COM O CANAL DE RECEPÇÃO DE DADOS

Uma vez discutido sobre o que é e para que servem os canais de comunicação
definidos no protocolo \mudccp, a seguir discute-se o processo de
estabelecimento de conexão e de que forma os canais de comunicação são
utilizados nesse processo.

% \section{Fluxograma de Estados do \mudccp}
% 
% Após o processo de estabelecimento de conexão do \mudccp, o protocolo entra no
% estado de transmissão de dados, se o nó for um servidor ou um relay, ao passo
% que o protocolo entra no estado de recepção de dados, se o nó for um cliente.
% 
% Um servidor ou um relay começa a transmitir os dados após o processo de
% estabelecimento de conexão e até quando o fluxo de dados no servidor se
% encerrar ou quando o relay não desejar mais receber o fluxo de dados.

\section{Conexão \mudccp}
\label{sec:conexaomudccp}

O processo de conexão do protocolo \mudccps é separado em duas fases. A primeira
fase acontece quando um cliente deseja obter um conteúdo multimídia transmitido
por um servidor e não existe nenhum outro cliente em sua rede local conectado a
tal servidor. Já a segunda fase acontece quando um cliente A qualquer inicia uma
conexão a um servidor e um outro cliente B já está recebendo o fluxo de dados
desejado. Neste caso, o cliente B é um \mdrel\space do servidor em questão,
cuja principal responsabilidade é repassar, em modo multicast, para a rede
local, os dados vindos do servidor para o cliente A e para quaisquer outros
novos clientes interessados pelo referido fluxo de dados. Considerando isto, só
pode existir $1$ \mdrel\space por rede para uma dada conexão a um servidor,
sendo este eleito na primeira fase de uma conexão \mudccp.

Os passos do processo de conexão do \mudccps executados na primeira e na segunda
fase são apresentados a seguir.

\subsection{Fase 1: conexão sem \mdrel\space disponível na rede local}

Para estabelecer uma conexão \mudccp, o cliente inicia o \textit{socket} do
canal de controle e envia um pacote do tipo \mudccp-Request, onde são
especificadas duas informações no cabeçalho de transporte, o endereço IP e o
número da porta do servidor. Estas informações devem ser preenchidas nos campos
endereço IP e porta do servidor de mídia disponíveis no cabeçalho do pacote
\mudccp-Request (Figura~\ref{fig:cabecalhomudccp-request}). O pacote
\mudccp-Request deve ser transmitido com o campo endereço IP de destino do
cabeçalho IP correspondendo ao endereço IP e número de porta do canal de
controle definido anteriormente. Nessa fase, o valor para o campo TTL do
cabeçalho IP deve ser igual a $1$, objetivando encontrar algum relay na rede
local recebendo o fluxo de dados desejado pelo cliente que está solicitando a
conexão.

Como na fase $1$ assume-se que não existe nenhum \mdrel\space disponível na rede
local do cliente, o envio do pacote do tipo \mudccp-Request não surtirá efeito,
ou seja, nenhum nó \mudccps enviará o pacote do tipo \mudccp-Response para
confirmar o pedido de conexão. Neste caso, o cliente \mudccps deve iniciar uma
conexão unicast com o servidor desejado utilizando o processo de conexão
tradicional em três via, como se faz em protocolos como o TCP e o DCCP. Ao
estabelecer a conexão, o cliente \mudccps se promove a relay e passa a aguardar
solicitações de conexão vindas de outros clientes, preferencialmente localizados
na sua rede local, utilizando o pacote do tipo \mudccp-Request, o que habilitará
a fase $2$ do processo de conexão do protocolo \mudccp, a ser discutida mais
adiante.

Um aspecto importante a ser considerado nessa primeira fase do processo de
conexão do protocolo \mudccps é o tempo que um cliente deve esperar para receber
um pacote do tipo \mudccp-Response. Baseando-se em simulações de rede
realizadas no contexto desse trabalho e considerando os padrões de tecnologia
de rede atualmente difundidas, como o padrão \textit{ethernet}, constatou-se ser
suficiente que um cliente espere por um \mudccp-Response até no máximo
\ut{300}{ms}. Como se considera uma rede local, este tempo é suficiente
para que um relay receba um pacote \mudccp-Request, processe-o e em seguida crie
e envie um \mudccp-Response de volta para o cliente.

Mesmo com este procedimento, é possível que no final do processo existam
dois nós relays presentes na mesma rede local, o que significa duas
conexões na mesma rede local recebendo o mesmo conteúdo de dados. Como discutido
na Seção~\ref{sec:problematica}, este tipo de situação deve ser evitada ao
utilizar protocolos orientados a conexão a fim de evitar o problema da
tragédia dos comuns, principalmente considerando os cenários de aplicações
estudados neste trabalho. Dito isto, deve-se garantir que existirá apenas um
relay na rede local e, para garantir esta premissa, outra decisão foi tomada.
Caso um cliente inicie uma conexão unicast com o servidor DCCP, mas receba um
pacote \mudccp-Response durante este tempo ou após o estabelecimento da conexão
com o servidor DCCP, o mesmo deve encerrá-la e obter os dados da conexão
multicast transmitidos pelo relay que o enviou o pacote \mudccp-Response. Se
preferir, um cliente nessa situação pode encerrar a conexão unicast com o
servidor só depois que este passar a receber os dados através do relay. Além
disso, como o cliente já havia estabelecido uma conexão com um servidor DCCP e
por este motivo se promoveu para relay, este deve funcionar apenas como cliente.

No contexto deste trabalho, atualmente estão sendo avaliadas outras propostas
para definição do tempo que um cliente deve esperar por uma resposta ao pedido
de conexão enviado por ele. Porém, ao que tudo indica, de acordo com uma série
de simulações previamente realizadas, o uso de um tempo fixo de \ut{300}{ms} é
suficiente e ao mesmo tempo simples de se implementar, pois não requer quaisquer
calculos extras, como por exemplo, cálculos baseados no valor do RTT ou na
quantidade de saltos entre o cliente e o servidor, práticas bastante adotadas
por outros protocolos de transporte, como o TCP. Independente disto, o protocolo
\mudccps permite que uma aplicação cliente altere o tempo de espera padrão por
um \mudccp-Response através da própria API de \textit{sockets} padrão BSD. Para
isto, o desenvolvedor da aplicação deve utilizar a função \textit{setsockopt} e
alterar o valor da opção SO\_SNDTIMEO, aumentando ou diminuindo o tempo padrão
de espera como desejado.

Como o pacote \mudccp-Request é transmitido na rede local com TTL igual a 1,
este pacote não será roteado para a rede externa e apenas os nós da rede
local o receberá. Se houvesse um \mdrel\space na rede local, este responderia
com um pacote do tipo \mudccp-Response, notificando o cliente de que o mesmo
passará a transmitir dados multimídia em modo multicast relacionado à conexão
desejada. Este não é o caso, pois neste momento está sendo considerado o
funcionamento do processo de conexão da fase $1$ do protocolo \mudccp. Este
procedimento está relacionado com a fase $2$ do processo de estabelecimento
de conexão do protocolo \mudccp.

Como exemplo de uma conexão \mudccps na fase $1$, suponha que um servidor
(\mudccps ou DCCP) esteja respondendo por conexões \textit{sockets} através do
endereço IP 200.200.211.5 e porta $8900$. Suponha também que um cliente com
endereço IP 200.200.200.1 e número de porta de origem $53900$ esteja interessado
pelo fluxo de dados enviado por este servidor. Neste caso, o cliente deve enviar
um pacote do tipo \mudccp-Request para o canal de controle do \mudccps com os
campos endereço IP e número de porta do servidor de mídia preenchidos com os
dados do \textit{socket} do servidor em questão, ou seja, endereço IP
200.200.211.5 e número de porta $8900$. Na
Figura~\ref{fig:cabecalhomudccp-request-exemplo}, ilustra-se como os campos
mais relevantes do cabeçalho do pacote \mudccp-Request devem ser preenchidos
para o caso do exemplo supracitado.

Note que os valores estão preenchidos em decimal para facilitar o entendimento,
mas na prática esses valores devem estar representados em binário. Note também
que o campo IPPROTO do cabeçalho do IP deve ser preenchido com o valor $253$. O
valor para este campo é também regulado pela IANA, que definiu o valor $253$
para protocolos experimentais, como é o caso do \mudccp~\cite{protonum2008}.

\begin{figure}[h]
    \begin{center}
        \includegraphics[scale=0.5]{imagens/mudccp-header-request-exemplo.pdf}
    \end{center}
    \vspace{-1.2cm}
    \caption{Exemplo do Cabeçalho do \mudccp-Request e do IP.}
    \label{fig:cabecalhomudccp-request-exemplo}
\end{figure}

Como já foi dito, na primeira fase quando um cliente detecta que não existe um
relay na sua rede local, este se conectado ao servidor \mudccps e se promove
para relay. Neste ponto, um novo procedimento deve ser executado pelo relay.
Após estabelecer a conexão, o relay já começa a receber o fluxo de dados, mas
em segundo plano, o relay deve continuar em busca de outro nó relay mais
próximo a ele. O objetivo desse procedimento é sempre evitar a sobrecarga no
servidor e assim evitar a tragédia dos comuns.

Para encontrar outros relays mais próximos enquanto recebe o fluxo de dados
multimídia, um relay deve enviar um pacote do tipo \mudccp-Request com TTL igual
a 2 em diante. Para encontrar um relay em outras redes, um cliente deve enviar o
pedido de conexão utilizando o pacote do tipo \mudccp-Request, da mesma forma
que da primeira tentativa, porém com o valor de TTL igual a 2. Neste caso, se o
roteador da rede do cliente estiver participando do grupo multicast do canal de
controle do \mudccp, o mesmo deverá repassar o pacote \mudccp-Request para suas
interfaces de rede de saída. Se houver algum relay correspondente ao pedido de
conexão do cliente, este deverá responder ao cliente em modo unicast, através do
endereço IP e porta do \textit{socket} do cliente.

Note que o procedimento para descoberta de novos relays discutido anteriormente
não funcionará em redes que utilizam NAT~\cite{RFC1631} e, para a atual versão
do \mudccp, este assunto está fora do escopo deste trabalho. Como o procedimento
de encontrar um relay é baseado em busca por profundidade e de forma
oportunista, não se pode conhecer facilmente o limite de saltos até encontrar um
relay correspondente a conexão desejada pelo cliente. Desta forma, para não
sobrecarregar a rede, este procedimento deve ser limitado há, no máximo, $5$
saltos, ou seja TTL igual a $5$.

Com a padronização do \mudccps e o consequente registro de endereço multicast do
canal de controle do \mudccp, espera-se que os roteadores passem a rotear
pacotes de controle do \mudccps para as suas redes adjacentes, passando a
ser possível encontrar nós relays mais facilmente em redes de salto 2 em
diante, considerando a rede local do cliente como ponto de partida. Embora este
tipo de funcionadade possa demorar a ser adotado pelas empresas, espera-se que
isto aconteça quando a RFC do protocolo \mudccps seja aprovada. Ao longo dos
anos, ocorreram casos parecidos com este, como é o caso do padrão
UPnP~\cite{REF}, hoje em dia implementado na maioria dos roteadores de rede,
inclusive roteadores de pequeno porte, de uso residencial.

Uma questão fundamental que pode levar a um impasse por parte do cliente é
como este detecta se seu pacote \mudccp-Request, com TTL igual a 2
em diante, está sendo roteado para uma rede adjacente, mas nenhum relay foi
encontrado ou se simplesmente seu pacote \mudccp-Request não foi roteado para
uma rede adjante. Em ambos os casos, o comportamento será o mesmo, ou seja,
nenhum pacote do tipo \mudccp-Response será recebido. Saber diferenciar esses
dois casos é muito importante para evitar que o cliente continue tentando enviar
pacotes \mudccp-Request com TTL acima de 2 quando se detecte que o roteador não
está repassando este tipo de pacote para redes adjacentes. Na
Seção~\ref{subsec:detectmulticast}, discute-se como o \mudccps lida com esta
questão, onde serão apresentadas algumas estratégias para evitar este impasse.

Como o processo de busca em profundidade adotada no protocolo \mudccps pode ser
bastante oneroso, está em estudo uma estratégia alternativa caso nenhum relay
seja encontrado utilizando o procedimento descrito anteriormente. Sendo assim,
quando um cliente A não consegue encontrar nenhum relay, o mesmo pode enviar
uma requisição da lista de relays de nível $1$ ao servidor que ele está
conectado em modo unicast, ou seja, o cliente solicita a lista de todos os
clientes conectados diretamente ao servidor, pois estes podem ser potenciais
relays e estarem localizados mais próximos a ele. Na
Seção~\ref{sec:arcdescorels}, discute-se como este processo funciona no
protocolo \mudccp.

%  Este
% procedimento pode ser oneroso por dois motivos: (1) pode-se demorar para
% encontrar um relay e (2) mais dados de controle serão transmitidos sem a
% garantia de encontrar um relay, consumindo recursos de rede desnecessariamente.



COLOCAR PSEUDO-ALGORITMO E UMA IMAGEM

\subsection{Fase 2: conexão através de um \mdrel\space}

A segunda fase de uma conexão inicia quando já existe um cliente A na rede
recebendo um fluxo de dados de interesse de um conjunto de clientes, supondo-se
um cliente B desse conjunto. Neste caso, o cliente B envia um pacote do tipo
\mudccp-Request para o canal de controle e um relay deve responder com um pacote
do tipo \mudccp-Response. O relay pode está localizado na rede local do cliente
A ou em outra rede externa. O melhor caso é quando já existe um relay na rede
local, pois evita-se esforços para descobrir relay(s), uma vez que todo o
trabalho para isto já foi realizado pelo atual relay, outrora apenas um cliente
A qualquer, interessado pelo mesmo fluxo de dados que o cliente B tem interesse.

Na Figura~\ref{fig:relayforwardclient}, ilustra-se o processo de conexão
\mudccps na fase $2$. Quando o cliente B envia um pedido de conexão
utilizando o pacote do tipo \mudccp-Request, deve-se preencher os campos
endereço IP e o número da porta do servidor da mesma forma que na fase $1$. Ao
receber o pacote \mudccp-Request, o relay examina os valores desses dois campos
e compara-os com todas as conexões que este tem com os servidores externos,
mesmo que seja com outros relays. Se o relay possuir alguma conexão estabelecida
com o servidor informado pelo cliente B, o mesmo cria um pacote do tipo
\mudccp-Response e preenche os campos endereço IP e número de porta do relay de
mídia (Figura~\ref{fig:cabecalhomudccp-response}) com os valores do seu endereço
IP e do número de porta correspondente ao socket de repasse dos dados
vindos do servidor para a rede local do cliente B, em modo multicast. Nesse
momento, o relay aguarda do cliente B um pacote do tipo \mudccp-Ack de
confirmação, informando que recebeu o pacote \mudccp-Response, o
que caracteriza um processo de conexão em 3 vias. Após o estabelecimento de
conexão, os relay utiliza o pacote do tipo \mudccp-Data e \mudccp-DataAck para
enviar dados em modo multicast para a sua rede local.

\begin{figure}[h]
    \begin{center}
        %\includegraphics[scale=0.5]{imagens/mudccp-header-request-exemplo.pdf}
    \end{center}
    \vspace{-1.2cm}
    \caption{\textit{Socket} de repasse de dados de um relay para um cliente
\mudccp.}
    \label{fig:relayforwardclient}
\end{figure}

Por exemplo, o relay pode criar um \textit{socket de repasse} multicast no
endereço IP 239.255.255.252 e número de porta $23456$, iniciando-se o repasse
quando receber o \mudccp-Ack de confirmação de conexão enviado por um cliente B.
Desta forma, para este exemplo, o relay deve preencher o pacote do tipo
\mudccp-Response com os campos endereço IP e o número de porta do relay com os
valores 239.255.255.252 e $23456$, respectivamente, como ilustrado na
Figura~\ref{fig:cabecalhomudccp-response-exemplo}. Esse par endereço IP e
número de porta constitui o canal de repasse do relay para os cliente da rede
local, como explicado na Seção~\ref{sec:canaiscommudccp}. Note que o pacote
\mudccp-Response é enviado para o cliente B em modo unicast, neste caso para o
endereço IP 200.200.200.1 e na porta $53900$. Neste exemplo, o endereço IP do
relay é o 200.200.200.2.

\begin{figure}[h]
    \begin{center}
        \includegraphics[scale=0.5]{imagens/mudccp-header-response-exemplo.pdf}
    \end{center}
    \vspace{-1.2cm}
    \caption{Exemplo do Cabeçalho do \mudccp-Response.}
    \label{fig:cabecalhomudccp-response-exemplo}
\end{figure}

Um aspecto importante nesse processo é que todos os pacotes \mudccp-Response e
\mudccp-Ack utilizados no processo de conexão do \mudccp, transmitidos através
do canal de controle, devem ser transportados de forma confiável, ou seja, com o
uso de confirmação de recebimento utilizando o pacote do tipo \mudccp-Ack. Caso
pacotes desse tipo sejam perdidos, estes devem ser retransmitidos. As regras de
implementação desse mecanismo confiável de transmissão são as mesmas adotadas no
protocolo DCCP, descritos nas seções 6, 7 e 11 da RFC 4340~\cite{RFC4340}.

Para os casos em que um cliente encontre um relay localizado fora da sua rede
local, o relay deve iniciar um \textit{socket} DCCP unicast e repassar os dados
recebidos do servidor para o cliente em questão. Este \textit{socket} passará a
ser considerado um canal de repasse. Para que o cliente saiba dessa decisão, o
relay deve enviar um pacote do tipo \mudccp-Response com os campos endereço IP
e número de porta do relay preenchidos com as informações do canal de repasse,
como ilustrado na Figura~\ref{fig:cabecalhomudccp-response-externo-exemplo}.
Nesse pacote, o primeiro bit do campo \textit{opção} deve está ativado para
sinalizar ao cliente que a transmissão é unicast e não multicast. O processo de
conexão unicast e todo o seu ciclo de vida deve seguir as normas estabelecidas
na RFC 4340~\cite{RFC4340}, porém quando o cliente desconectar, o relay pode
manter o \textit{socket} unicast ativo e utilizá-lo para outro cliente.

\begin{figure}[h]
    \begin{center}

\includegraphics[scale=0.5]{imagens/mudccp-header-response-externo-exemplo.pdf}
    \end{center}
    \vspace{-1.2cm}
    \caption{Exemplo do Cabeçalho do \mudccp-Response quando o relay não está
na mesma rede do cliente.}
    \label{fig:cabecalhomudccp-response-externo-exemplo}
\end{figure}

COLOCAR PSEUDO-ALGORITMO E UMA IMAGEM

\subsection{Conexão Rápida}
\label{subsec:fasccommudccp}

O processo de conexão do \mudccps requer que o cliente envie um pacote do tipo
\mudccp-Request para o canal de controle. Este procedimento objetiva fazer com
que o relay tenha conhecimento dos nós \mudccps interessados em receber o fluxo
de dados repassado pelo relay e, com este conhecimento, permitir que o relay
regule a taxa de transmissão a fim de controlar o congestionamento da rede.

O problema é que o processo de conexão do \mudccps pode demorar devido as
tentativas de busca para encontrar um nó relay. Sabendo disso, no \mudccps
adicionou-se um mecanismo que permite um cliente estabelecer uma
conexão de forma mais rápida.

A conexão rápida do \mudccps é opcional e funciona da seguinte forma.
Quando um cliente \mudccps se torna um nó relay e começa a enviar dados
utilizando o pacote do tipo \mudccp-Data, o mesmo pode anunciar no canal de
controle suas conexões ativas e qual canal de repasse está sendo utilizado.
Neste caso, o relay utiliza o pacote do tipo \mudccp-AdvConn para anunciar,
através do canal de controle, suas conexões de repasse ativas e clientes
interessados em obter o conteúdo multimídia correspondente pode passar a
receber pacotes de dados no canal especificado no anúncio do relay. O anúncio
do conexão de repasse deve ser enviado a cada \ut{30}{s}.

Na Figura~\ref{fig:anuncio-advconn}, ilustra-se o cabeçalho do pacote
\mudccp-AdvConn para o caso em que um nó relay tem uma conexão de repasse na
porta $32231$ através do endereço IP 200.200.200.2.

\begin{figure}[h]
    \begin{center}

\includegraphics[scale=0.5]{imagens/mudccp-header-advconn-exemplo.pdf}
    \end{center}
    \vspace{-1.2cm}
    \caption{Exemplo do Cabeçalho do \mudccp-AdvConn para anúncio de conexão
de repasse.}
    \label{fig:anuncio-advconn}
\end{figure}

\section{Troca de Dados no \mudccp}
\label{sec:trocadadosmudccp}

Após o processo de estabelecimento de conexão, o \mudccps entra no
estado de transmissão de dados. Se o \mudccps estiver em funcionamento em
servidor ou em um relay, o estado é o de \textit{transmitindo dados}, ao passo
que quando executado em um cliente o estado é o de \textit{recepção de dados}.
Nesta seção, discute-se o funcionamento do mecanismo de trasmissão e recepção de
dados no \mudccp.

Para transportar dados da aplicação, um servidor ou um relay deve criar um
pacote do tipo \mudccp-Data ou o \mudccp-DataAck e enviá-lo ao cliente através
do \textit{socket} informado no pacote do tipo \mudccp-Response. Embora o
protocolo \mudccps transmite dados de forma não confiável, em
alguns casos, dados de controle podem ser transmitidos de forma confiável.
Durante a transmissão de dados, um nó \mudccps utiliza-se do pacote do
tipo \mudccp-Data para enviar dados, ao passo que utiliza-se do
pacote \mudccp-Ack para confirmar a recepção de pacotes e o \mudccp-DataAck para
enviar pacotes de dados e ao mesmo tempo confirmar a recepção de pacotes de
dados vindos da direção oposta, processo conhecido como \textit{piggyback}.

Um relay cria um \textit{socket} de repasse a partir do momento que há a
confirmação da primeira conexão por parte de um cliente. Dependendo da sua
posição na rede com relação ao cliente, o relay cria um \textit{socket}
multicast ou unicast. Neste caso, o termo \aspas{\textit{posição}} empregado
aqui está relacionado com a posição lógica do relay na perspectiva da rede, ou
seja, se estes estão na mesma rede do cliente ou não. Caso o relay esteja na
mesma rede do cliente, o \textit{socket} deve ser do tipo multicast, caso
contrário o \textit{socket} deve ser unicast. Isso quer dizer que, caso o
relay precise repassar dados \mudccp-Data para um cliente localizado em sua
rede ao mesmo tempo que precise repassara para outro cliente localizado em uma
rede externo qualquer, dois \textit{sockets} de repasse devem ser criados, um
multicast e outro unicast. Ao receber pacotes de dados vindos de um relay
através de um canal de repasse unicast, um cliente deve se promover a relay da
sua rede local.

\subsection{Modos de Transmissão do \mudccp}

O \mudccps pode operar em dois modos de transmissão: (i) multicast; e (ii)
multi-unicast. O modo multicast sempre é utilizado, porém quando este modo não é
suportado pela rede, o modo multi-unicast do protocolo é executado. É
requerido que o modo multicast seja utilizado para transmissões de um salto, ou
seja, em redes locais. O modo unicast é utilizado para que um cliente estabeleça
uma conexão com um servidor ou um relay e distribua o conteúdo na sua rede
local.

Como mencionado anteriormente, a mensagem de resposta de conexão enviada por um
servidor ou relay é cruscial para que o cliente entenda qual modo de
transmissão está sendo utilizado. Três campos são utilizados para isto, são
eles: (i) o bit de \emph{multicast}, que indicará se a transmissão será em modo
multicast (bit ativado) ou unicast (bit desativado); (ii) o campo endereço IP,
que especificará qual endereço IP o relay passará a transmitir os dados (canal
de repasse); e (iii) o campo número de porta (16 bits), que especifica a porta
correspondente ao canal de repasse.

No modo de transmissão unicast, o protocolo \mudccps funciona com o auxílio da
versão padrão do protocolo DCCP. Quando um cliente percebe que um relay de
interesse dele está localizado fora da sua rede local, o mesmo estabelece uma
conexão unicast com este relay de acordo com todas as diretrizes definidas no
protocolo DCCP segundo a RFC 4340. Por outro lado, quando a transmissão é na
rede local ou quando se detecta que a rede suporta transmissão multicast,
utiliza-se o mecanismo de canal de repasse discutido anteriormente.

Um ponto primordial é como o \mudccps realiza suas funções para controle de
congestionamento. Algoritmos de controle de congestionamento em modo
\emph{multicast} são mais complexos porque geralmente estes
utilizam o \textit{feedback} dos receptores para tomar decisões na
definição da sua taxa de transmissão. Neste caso, nenhum CCID
existente para DCCP foi projetado para funcionar neste modo, sendo
necessário trabalhar em um novo CCID capaz de tratar todas as
características de transmissão de dados de fluxo não confiável em
modo \emph{multicast}. No contexto deste trabalho, definiu-se o
CCID-5, um algoritmo para controle de congestionamento de fluxos de
dados não confiável em transmissões \emph{multicast} utilizando o
protocolo \mudccp.

\section{Controle de Congestionamento do \mudccp}

No protocolo \mudccp, definiu-se um algoritmo para controle de
congestionamento híbrido, cujo comportamento dependerá se o nó que o
executa está transmitindo em modo unicast ou em multicast. Em transmissões
unicast, para definir a taxa de transmissão da conexão um nó \mudccps executa
um algoritmo de janela deslizante baseado em uma equação cúbica, ao passo que
em modo multicast o \mudccps executa um algoritmo baseado em relatórios
transmitidos pelos nós receptores. Para a parte do algoritmo que funciona em
modo unicast, dá-se o nome de \textit{\mudccps Unicast Congestion Control}
(\mudccp-UCC), ao passo que para a parte do algoritmo que funciona em modo
multicast, dá-se o nome de \textit{\mudccps Multicast Congestion Control}
(\mudccp-MCC).

FIGURA COM O ESQUEMA DE ONDE CADA UM DESSES ALGORITMOS FUNCIONAM

%\subsection{Controle de Congestionamento Unicast}

O \mudccp-UCC funciona da mesma forma que o algoritmo de controle de
congestionamento TCP Cubic~\cite{Sangtae2008}, com uma diferença primordial se
comparado ao algoritmo executado no protocolo TCP. Uma das responsabilidades do
TCP é computar os pacotes que alcançam e os que não alcançam o sistema de
destino, uma vez que se trata de um protocolo com suporte a garantia de entrega
cujo mecanismo funciona com base na retransmissão de cada pacote perdido. Na no
caso de protocolos como o \mudccp, a responsabilidade de computar os pacotes
recebidos e perdidos pelo nó receptor é de responsabilidade do algoritmo de
controle de congestionamento. Isto também acontece no protocolo DCCP.
Considerando isto, no \mudccp-UCC utiliza-se um mecanismo de vetores de ACKs,
computado pelo nó receptor e transmitido para o nó transmissor, que
então alimentar o algoritmo Cubic a fim de definir a próxima taxa de
transmissão. Os vetores de ACKs contém informações sobre pacotes perdidos ou
pacotes marcados com ECN. Para maiores detalhes de como funciona o mecanismo de
vetores de ACKs o leitor pode consultar a RFC4341~\cite{RFC4341}.

Por se tratar de um algoritmo já consolidado e utilizado como padrão no
\textit{kernel} do sistema operacional Linux, decidiu-se omitir explicações
detalhadas do funcionamento do algoritmo Cubic no \mudccp. Embora não será
apresentada uma explicação detalhada do algoritmo TCP Cubic, considera-se de
suma importância justificar os motivos que levaram a escolha do TCP Cubic para
transmissões unicast no \mudccp.

O primeiro motivo está relacionado com os diversos resultados de pesquisas
anteriores, incluindo uma série de resultados obtidos no contexto deste
trabalho. Nos últimos anos diversas pesquisas científicas constantam a eficácia
do TCP Cubic em termos da sua equidade para com outros fluxos TCP e, ao
mesmo tempo, para com fluxos de dados TCP transmitidos utilizando outras
variantes do TCP, como o TCP Vegas~\cite{Low:2002:UTV:506147.506152}, TCP
HSTCP\cite{RFC3649} e o recém lançado TCP Compound~\cite{4146841,5472999},
utilizado a partir do sistema operacional Windows Vista. O TCP Cubic não degrada
os fluxos de dados transmitidos utilizando estas variantes do TCP e também não é
degradado quando em disputa com fluxos de dados não-controlados, como os
transmitidos utilizando o protocolo UDP.

O segundo motivo é que o TCP Cubic tem sido utilizado pela maioria dos sistemas
em execução na Internet da atualidade, uma vez que este é o algoritmo para
controle de congestionamento utilizado por padrão do sistema operacional Linux.
Diante disto, desenvolver um protocolo cujo mecanismo para controle de
congestionamento seja compatível com a maioria dos fluxos de dados é uma decisão
primordial para o correto funcionamento e aproveitamento dos recursos de rede,
em especial na Internet.

%\subsection{Controle de Congestionamento Multicast}
%\label{subsec:mudccp-mcc}

Da mesma forma que no \mudccp-UCC, o objetivo principal do \mudccp-MCC é manter
a equidade entre os fluxos de dados transmitidos pelo \mudccps e os fluxos
transmitidos pelo TCP, porém considerando o modo de transmissão multicast do
\mudccp.

O \mudccp-MCC foi inspirado em um protocolo publicado pela IETF e conhecido pelo
nome de \textit{TCP-friendly Rate Control protocol (TFRC)} (RFC
3448~\cite{RFC3448}). O TFRC é um mecanismo para controle de congestionamento
de fluxos unicast que tenta prevê a taxa de transmissão de um fluxo TCP e
utilizá-la em protocolos diferentes do TCP~\cite{CONG:Floyd00:TFRC:art}.
Trata-se de uma abordagem diferente da utilizada em algoritmos baseados em
janela deslizante e que utilizam pacotes de confirmação para determinar a taxa
de transmissão de uma conexão, como acontece no TCP. No TFRC, o receptor envia
para o transmissor relatórios sobre as perdas observadas por ele, o que ficou
conhecido como algoritmos de controle de congestionamento baseados em equação
(\textit{Equation Based Congestion Control}). Algoritmos desse tipo são adotados
em diversos protocolos, como no CCIDs 3 e 4 do DCCP. Em linhas gerais, o
algoritmo TFRC funciona da seguinte forma:

\begin{enumerate}[{\tab}1$^{\circ}$]
 \item o receptor mede a taxa de perda de pacotes e envia essa informação para o
transmissor;
 \item o transmissor usa esse relatório para medir o RTT até o
receptor;
 \item o transmissor utiliza a Equação~\ref{eq:trfcmudccp} para determinar qual
será a sua próxima taxa de transmissão em função do relatório de perdas e o
RTT obtidos anteriormente;
 \item o transmissor então ajusta sua taxa de transmissão para o valor
calculado no passo anterior.
\end{enumerate}

\begin{equation}
T = \frac{s}{t_{rtt} \times (\sqrt{\frac{2 \times p}{3}} + (12 \times
\sqrt{\frac{3 \times p}{8}}) \times p \times (1 + 32 \times p^2))}
\label{eq:trfcmudccp}
\end{equation}

\vspace{0.5cm}

Na Equação~\ref{eq:trfcmudccp}~\cite{Padhye98model}, $T$ é a taxa de transmissão
medida em bytes/segundo definida em função de \textit{s}, que é o tamanho do
pacote medido em bytes; $t_{rtt}$, que é o RTT entre o nó transmissor e o
receptor, medido em segundos e \textit{p}, que é a taxa de perda de pacotes
observado pelo nó receptor.

Apesar de ser uma estratégia interessante e funcionar em conexões unicast, em
transmissões multicast o algoritmo descrito anteriormente não é eficiente. O
algoritmo é limitado devido a um problema conhecido por \textit{explosão de
retorno} (\textit{feedback implosion}). O problema da \textit{explosão de
retorno} acontece devido a muitos receptores enviarem para o transmissor seus
relatórios de perdas, o que resulta em uma inundação de relatórios os quais o
transmissor é incapaz de processá-los em tempo hábio, além de onerar recursos de
rede com dados de controle.

Embora existe essa limitação do TFRC, as idéias utilizadas no algoritmo
inspirou a criação do \mudccp-MCC. Como o \mudccps foi desenvolvido para operar
em cenários onde existe apenas um nó transmissor (servidor ou relay) e diversos
nós clientes, receber relatórios sobre a taxa de recepção de todos os nós
receptores pode sobrecarregar o nó transmissor \mudccps com demasiados pacotes
de relatórios. Por este motivo, determinou-se que apenas alguns nós especiais
chamados de \mdreps\space são obrigados a enviar tais relatórios ao nó
transmissor. Estes nós prestam uma papel fundamental para o \mudccp-MCC,
determinando algumas diferenças entre o \mudccp-MCC e o TFRC, descritas a
seguir.

\begin{enumerate}[{\tab}1$^{\circ}$]
 \item O \mdreps\space são responsáveis por calcular a taxa de transmissão
utilizando a Equação~\ref{eq:trfcmudccp} do transmissão, ao invés do transmissor
realizar este cálculo;
 \item O \mdreps\space são responsáveis por determinar os eventos de perda, e
não mais todos os receptores do grupo multicast;
 \item Cada \mdrep\space é responsável por calcular o RTT entre ele e o nó
transmissor, ao invés do transmissor realizar este cálculo;
 \item A taxa de transmissão a ser utilizada pelo nó transmissor é a média
aritmética de todas as taxas enviadas pelos \mdreps.
\end{enumerate}

Note que é de fundamental importância eleger os nós \mdreps\space para que o
algoritmo descrito funcione. O processo de eleição dos nós
\mdreps\space é descrito na Seção~\ref{sec:electrelsreps}.

Diante das adaptações no algoritmo original do TFRC mencionadas
anteriormente, para definir um algoritmo de controle de congestionamento em
transmissões multicast, deve-se considerar alguns requisitos que serão
discutidos a seguir.

\begin{enumerate}[{\tab}1.]
 \item Uma equação para controle de congestionamento deve ser definida em
função de parâmetros obtidos sobre a rede, tais como a taxa dos eventos de
perda e o RTT.
 \item Como cada receptor deve medir a taxa dos eventos de perda, deve-se
definir um filtro que represente uma medição estável da taxa de transmissão para
as condições atuais da rede, mas que o algoritmo seja sensível quando tais
condições mudarem.
 \item Como cada receptor deve estimar o RTT entre ele e o transmissor, deve-se
elaborar uma forma efetiva de calcular este parâmetro sem excessivas trocas de
dados de controle.
 \item Como cada receptor deve calcular a taxa de transmissão e enviá-la para o
transmissor, deve-se definir um filtro para determinar qual é a melhor taxa de
transmissão dentre as diversas taxas de transmissão enviadas pelos nós
receptores.
 \item Como cada receptor deve enviar o cálculo da sua taxa de transmissão,
deve-se determinar a frequência de envio desse relatórios para o nó transmissor.
Essa taxa não pode ser muito alta para não causar o problema da \textit{explosão
de feedbacks}, porém, se essa taxa for muito baixa, o \mudccp-MCC irá demorar
para reagir às mudanças do estado da rede.
\end{enumerate}

Diante dessas considerações, a seguir, discute-se como cada uma delas é tratada
no contexto do \mudccp-MCC, iniciando-se com algumas definições.

\subsubsection{Considere:}

\begin{enumerate}

 \item $\hat{c}$, uma transmissão \mudccp;

 \item $\hat{s}$, o nó servidor de $\hat{c}$;

 \item \textit{count(X)}, uma função que determina a quantidade de elementos de
um conjunto X;

 \item \textit{link($e_1$, $e_2$)}, uma função que relaciona o elemento $e_1$ a
um $e_2$, com $e_1$ e $e_2$ pertencente a dois conjuntos diferentes e $e_1$ não
podendo estar relacionado com mais de um elemento;

 \item $C$, o conjunto de clientes tal que $C = \{c_{i}/c_{i}$ é um cliente
\mudccps participante de $\hat{c}\}$;

 \item $S$, o conjunto de relays tal que $S = \{s_{i}/s_{i}$ é um \mdrel$\}$ e
$S \subset C$;

 \item $W$, o conjunto de todos os clientes não relays, ou seja, $W = C-S$;

 \item $W_i$, um subconjunto $i$ de $W$ tal que $W_i = \{\hat{w}_i /$
\textit{link($\hat{w}_{i}$, $s_i$)}$\}$. Ou seja, $\bigcap_{i=1}^{n} W_i$ =
{$\emptyset$}, para $n$ correspondendo a quantidade de subconjuntos derivados
de $W$. Isto significa que um cliente $\hat{w}_i$ não pode pertencer a dois
subconjuntos $W_i$ e $W_j$, com $i \neq j$, $ 1 \leq i \leq $ \textit{n} e $ 1
\leq j \leq $ \textit{n}. Na prática, um subconjunto $W_i$ é um grupo multicast
e um cliente $\hat{w}_i$ não pode pertencer a dois grupos multicast distintos
para receber o mesmo conteúdo, uma vez que cada grupo multicast está
relacionados apenas com um relay $s_i$;

 \item $R$, o conjunto de todos os clientes reporters em uma transmissão
$\hat{c}$;

 \item $R_i$, um subconjunto $i$ de $R$ tal que $R_i =
\{\hat{r}_{i}/$ link($\hat{r}_{i}$, $s_i$)$\}$ e $R_i \subset W_i$ ou $R_i
\subseteq W_i$. Ou seja, $\bigcap_{i=1}^{n} R_i$ = {$\emptyset$}, para $n$
correspondendo a quantidade de subconjuntos derivados de $R$. Isto significa
que um reporter $\hat{r}_i$ não pode pertencer a dois subconjuntos $R_i$ e
$R_j$, com $i \neq j$, $ 1 \leq i \leq $ \textit{n} e $ 1 \leq j \leq $
\textit{n}. Na prática, isto quer dizer que um reporter $\hat{r}_i$ não pode
enviar relatórios sobre congestionamento para mais de um relay $s_i$.
 \label{i:cons-mcc-ri}

\end{enumerate}

\subsection{Determinando a Taxa de Transmissão para $s_i$}

A taxa de transmissão de um nó $s_i$ é definida por $T_{s_{i}}$ e calculada
através da Equação~\ref{eq:srtx} em função de $T_{\hat{r}_i}$. No \mudccp-MCC,
cada elemento de $R_i$, ou seja, cada reporter $\hat{r}_i$ deve calcular seu
valor para $T_{\hat{r}_{i}}$ e enviá-lo para seu $s_i$ correspondente. O relay
$s_i$, por sua vez, utiliza-se da Equação~\ref{eq:srtx} para calcular sua taxa
de transmissão e a utilizará para transmitir dados em modo multicast para
um grupo de clientes $W_i$. O cálculo para $T_{\hat{r}_{i}}$ é
feito através da Equação~\ref{eq:trfcmudccp}, em função da taxa de perda $p$
percebida em $\hat{r}_{i}$ e pelo valor do RTT $t_{rtt}$ entre um certo
$\hat{r}_{i}$ e seu respectivo $s_{i}$.

\begin{equation}
T_{s_{i}} = \frac{\sum_{i=1}^{n} T_{\hat{r}_{i}}}{n}
\label{eq:srtx}
\end{equation}

No caso do \mudccp-MCC, a estratégia é que o valor da taxa de transmissão para
um $s_i$ seja tão próximo ao valor de $T$ quanto possível, tornando-o um
algoritmo \textit{TCP-Friendly}. Um fluxo de dados é considerado
\textit{TCP-Friendly} quando este não degrada a taxa de transmissão de um fluxo
de dados TCP mais do que outro fluxo TCP degradaria quando começasse a ser
transmitido na rede.

Como o valor para $T$ é uma aproximação da taxa de transmissão que um fluxo de
dados TCP obteria e $s_i$ segue esta condição, então se estiverem sendo
transmitidos fluxos de dados TCP concorrentes com fluxos de dados \mudccp, o
valor calculado para a taxa de transmissão de um fluxo de dados $s_i$ será
equivalente aos valores das taxas de transmissão dos fluxos de dados
transmitidos através do TCP. Essa preocupação é muito importante no contexto do
\mudccps porque atualmente o TCP é o protocolo mais utilizado na Internet,
sendo de fundamental importância tornar os fluxos de dados transmitidos com o
\mudccps equinimes com relação aos fluxos de dados transmitidos com TCP.

Desta forma, seja $T_{\hat{r}_{max}}$ o valor da maior taxa de transmissão 
recebida por um $s_i$ e enviada por algum $\hat{r}_i$, pertencente a $R$ em
uma transmissão $\hat{c}$. No \mudccp-MCC, partiu-se do pressuposto de
que se nenhum nó $s_i$ ou $\hat{s}$ exceder o valor de $T_{\hat{r}_{max}}$ em
uma conexão $\hat{c}$, então o fluxo \mudccps será \textit{TCP-Friendly}.

Teoricamente, o \mudccps seria um protocolo \textit{TCP-Friendly} se 
$T_{\hat{r}_{max}} = T_{s_{i}}$ em $s_i$. Porém, optou-se por utilizar a média
aritimética dos valores
$T_{\hat{r}_i}$ (Equação~\ref{eq:srtx}) porque na prática diversos fatores podem
alterar drasticamente o estado da rede
no instante em que se utilizar $T_{\hat{r}_{max}}$. Com esta decisão,
define-se uma margem de segurança evitando que o \mudccp-MCC alcance o limite
superior para o valor da taxa de transmissão de um fluxo transmitido com TCP.
Além disso, a média aritimética suaviza os valores subsequentes para $s_i$,
mesmo se algum $\hat{r}_x$ envie para $s_i$ um valor $T_{\hat{r}_x}$ muito alto
ou muito baixo com relação aos demais valores $T_{\hat{r}_i}$.

\subsection{Ajuste da Taxa de Transmissão}

O ajuste da taxa de transmissão $T_{s_{i}}$ de um relay $s_i$ ocorre
periodicamente de acordo com os valores de cada taxa de transmissão
$T_{\hat{r}_i}$ calculada por um nó $\hat{r}_i$. Todo nó $\hat{r}_i$ deve enviar
ao nó transmissor o cálculo de $T_{\hat{r}_i}$ e $s_i$ deve ajustar sua taxa de
transmissão para o valor obtido através da Equação~\ref{eq:srtx}.

% Cada nó $T_{\hat{r}_i}$ deve enviar seu valor para $T_{\hat{r}_i}$ em uma
% frequência determinada pela Equação~\ref{eq:freqsendtx} em função do valor de
% $p$ e do $RTT$. A Equação~\ref{eq:freqsendtx}
% 
% \begin{equation}
% F(rtt) = \frac{1}{p\times\log{rtt}}
% \label{eq:freqsendtx}
% \end{equation}
% Na
% Seção~\ref{subsec:freqenvrel}, descreve-se como é calculada a frequência que
% um
% reporter $\hat{r}_i$ deve enviar para $s_i$ seu valor de $T_{\hat{r}_i}$.

Sendo assim, a frequência que $s_i$ deve ajustar sua taxa de transmissão
$T_{s_{i}}$ é determinada por cada nó em $R_i$. Toda vez que $\hat{r}_x$ enviar
para $s_i$ seu novo valor $T_{\hat{r}_x}$, $s_i$ deve recalcular sua taxa de
transmissão $T_{s_{i}}$ utilizando a Equação~\ref{eq:srtx}, utilizando o
restante dos valores inalterados de $T_{\hat{r}_i}$ neste cálculo.

Note que um nó $\hat{r}_x$ deve enviar um novo valor para $T_{\hat{r}_x}$ todas
as vezes que um novo intervalo de perda for determinado. Um intervalo de perda
é determinado por consecutivas perdas de pacotes, desde do primeiro pacote
perdido até o último pacote perdido seguido de um pacote recebido com sucesso.
Na Seção~\ref{subsec:mcclossevent}, explica-se com mais detalhes como funciona
o processo que determina um intervalo de perda.

Uma outra observação com relação ao ajuste da nova taxa de transmissão de $s_i$
está relacionado ao fato de um nó $\hat{r}_i$ se desconectar ou perder
repentinamente sua conexão. Caso isto aconteça com algum nó $\hat{r}_x$, seu
valor $T_{\hat{r}_x}$ deverá ser desconsiderado no cálculo da nova taxa de
transmissão $T_{s_{i}}$. Existem duas formas que um relay $s_i$ pode perceber a
desconexão de um ou mais nós $\hat{r}_i$. A primeira forma é quando um nó
$\hat{r}_x$ envia explicitamente um pedido de desconexão para $s_i$,
tal processo é discutido na Seção~\ref{subsec:mudccp-desconexao}, ao passo que a
segunda forma é quando um contador de tempo de manutenção de conexão, mantido
pelo relay $s_i$ se expira, tal processo é discutido na
Seção~\ref{subsec:electrelsreps}. Com esta medida, evita-se utilizar um taxa de
transmissão $T_{s_{i}}$ incorreta, evitando correr o risco de utilizar uma
taxa de transmissão não condizente com o estado atual da rede.

\subsection{Taxa de Eventos de Perda $p$}
\label{subsec:mcclossevent}

A taxa de eventos de perda $p$, definido na Equação~\ref{eq:trfcmudccp}, é
determinada por cada \mdrep\space $\hat{r}_i$ de forma similar ao TFRC. No caso
do \mudccp-MCC, cada $\hat{r}_i$ agrega as perdas de pacotes que
ocorrem dentro de um evento de perda, definido por uma ou mais perdas de pacotes
no espaço de tempo de um RTT. O número de pacotes entre eventos de perdas
consecutivos é chamado de intervalo de perda. Para o cálculo de $p$, utiliza-se
a média dos tamanhos dos intervalos de perda, calculada através da média
ponderada dos $m$ mais recentes intervalos de perdas $l_k, \dots, l_{k-m+1}$
seguindo a Equação~\ref{eq:losseventmean}. O conjunto de todos os intervalos de
perda é chamado de \textit{histórico de perdas}.

\begin{equation}
l_{avg} = \frac{\sum_{i=0}^{m} w_i \times l_{k-i}}{\sum_{i=0}^{m} w_i}
\label{eq:losseventmean}
\end{equation}

Os pesos $w_i$ são escolhidos de tal forma que os intervalos de perdas mais
recentes recebem pesos mais altos, decrescendo-os gradualmente até $1$
para os intervalos de perdas mais antigos. Por exemplo, para $8$ intervalos de
perda, pode-se utilizar os pesos $w = [5, 5, 5, 5, 4, 3, 2, 1]$. Ao utilizar-se
da média ponderada para o cálculo da média dos tamanhos dos intervalos de
perda, obtem-se mudanças mais suaves para o valor de $l_{avg}$ à medida que
os tamanhos dos intervalos de perdas se tornam mais antigos. Para grandes
valores de $m$, obtem-se mudanças mais suaves para $p$ ao longo do tempo, porém
isto também reduz a capacidade de resposta e portanto a equidade do protocolo.
No TFRC, recomenda-se utilizar valores de $m$ entre $8$ e $32$ e por este
motivo no \mudccps é considerada esta recomendação.

Uma vez definido como determina-se a média dos tamanhos dos intervalos de
perda, a taxa dos eventos de perda $p$ é definido pelo inverso de $l_{avg}$,
definido na Equação~\ref{eq:losseventrate}. Como um intervalo de perda é
definido em função do número de pacotes entre de eventos de perdas consecutidos,
o mais recente evento de perda não pode influenciar na taxa do evento de perda,
por isto utilizou a função \textit{max} no denominador da
Equação~\ref{eq:losseventrate}.

\begin{equation}
l_{avg} = \frac{1}{max(l_{avg}(k), l_{avg}(k-1))}
\label{eq:losseventrate}
\end{equation}

% Para mais discussões acerca de como funciona o mecanismo para medição dos
% intervalos de perda, consulte a referência~\cite{CONG:Floyd00:TFRC:art}.

% Um aspecto importante no cálculo do valor de $p$ é determinar o seu valor
% inicial.

\subsection{Cálculo do RTT}
\label{subsec:mccrtt}

O cálculo do RTT no contexto do \mudccp-MCC é feito apenas pelos nós
\mdreps\space e funciona da seguinte forma. Um nó $\hat{r}_i$ transmite ao seu
respectivo relay $\hat{s}_i$ um pacote de controle especial e inicia um
marcador de tempo. Ao receber uma resposta do nó relay $\hat{s}_i$, o nó
reporter $\hat{r}_i$ pára o marcador de tempo e utiliza este tempo chamado de 
$RTT_{instant}$ para calcular o valor do próximo $RTT$ de acordo com a
Equação~\ref{eq:calcrtt}.

\begin{equation}
RTT = \beta \times RTT_{instant} + (1 - \beta) \times RTT
\label{eq:calcrtt}
\end{equation}

Note que no \mudccp-MCC não se utiliza o valor de $RTT$ instantâneo
($RTT_{instant}$) como o valor do $RTT$, mas sim utiliza-se de um mecanismo 
para suavizar as mudanças do $RTT$ ao longo do ciclo de vida de uma conexão.
Desta forma, procura-se evitar que valores absurdos -- muito baixos ou muito
altos com relação aos valores medidos anteriormente -- de $RTT_{instant}$
influenciem demasiadamente na taxa de transmissão $T_{\hat{s}_i}$.

O mecanismo mencionado anteriormente para suavizar as medições do valor de
$RTT$ é chamado de Médias Móveis Exponencialmente Ponderadas ou Exponentially
Weighted Moving Average (EWMA). O EWMA foi primeiramente utilizado para
índices financeiros de medição de risco, onde a série de retornos diários com
$n$ observações é ponderada por um fator de decaimento. As observações mais
recentes no tempo são ponderadas com um peso maior que as observações mais
antigas. O peso de uma observação decai exponencialmente com $n$. Em seguida,
utilizou-se EWMA em medições de tempo do $RTT$ em protocolos como o TCP. Como
trata-se de uma estratégia conhecida para medição de RTT, no \mudccp-MCC
manteve-se o mesmo mecanismo, principalmente por já ter sido exaustivamente
testado e utilizado. Tanto no TCP quanto no caso do \mudccp, utiliza-se $\beta =
0.25$ para o cálculo do valor de $RTT$ através da
Equação~\ref{eq:calcrtt}~\cite{kurose2006}.

Porém, diferentemente do mecanismo de medição de $RTT$ no TCP e no TFRC, os nós
reporters $\hat{r}_i$ são os responsáveis pela medição do $RTT$ e não o nó
transmissor. Um aspecto importante na medição do RTT está relacionado com o
início de uma conexão \mudccp, pois até o final do processo de
estabelecimento de uma conexão, não se sabe o valor para $RTT_{instant}$. Nesse
caso, deve-se utilizar um valor
consideravelmente alto para evitar taxas de transmissões $T_{\hat{s}_i}$ muito
maiores do que a rede tem capacidade de suportar. No \mudccp, utiliza-se o
valor inicial de $RTT_{instant}$ igual a \ut{150}{ms}. Quando um nó $\hat{r}_i$
enviar um pedido de conexão utilizando o pacote do tipo \mudccp-Request, o mesmo
deve realizar a sua primeira medição do valor de $RTT_{instant}$, iniciando-se o
marcador de tempo para o cálculo do RTT quando enviar o primeiro \mudccp-Request
e parando-o quando receber o pacote do tipo \mudccp-Response. Em seguida,
deve-se acionar o mecanismo de cálculo de $T_{\hat{r}_i}$, caso o respectivo nó
$\hat{r}_i$ seja eleito como \mdrep.

% - A frequencia que é feito (pode ser proporcional ao valor de p), quanto maior
% p, provavelmente maior será rtt

% \subsection{Envio da Taxa de Transmissão}
% \label{subsec:txetime}
% 
% FALAR AQUI DO FORMATO DO PACOTE

% \subsection{Frequência de Envio de Relatórios}
% \label{subsec:freqenvrel}
% 
% Essa taxa não pode ser muito alta para não causar o problema da
% \textit{explosão
% de feedbacks}, porém, se essa taxa for muito baixa, o \mudccp-MCC irá demorar
% para reagir às mudanças do estado da rede. Para o caso que a taxa de envio de
% relatórios for muito baixa, dois
% problemas agravantes podem ser observados. O primeiro problema é se a taxa de
% transmissão estiver muito alta e o nó receptor perceber muitas perdas de
% pacotes. Neste caso, o transmissor pode levar a rede a altos níveis de
% congestionamento e, como consequência, o \mudccp-MCC pode não manter a
% equidade
% para com fluxos do protocolo TCP. E o seguindo problema é se a taxa de
% transmissão praticada pelo nó transmissor estiver muito baixa e o nó receptor
% calcular uma taxa maior do que a atual. Neste caso, o algoritmo \mudccp-MCC
% pode
% sub-utilizar o canal de transmissão por um determinado instante até que a nova
% taxa de transmissão seja enviada para o nó transmissor.

\section{Outros Aspectos do \mudccp}

Além do processo de estabelecimento de conexão e do mecanismo de
controle de congestionamento, existem outros aspectos do protocolo \mudccps que
merecem destaque. Estes aspectos são discutidos a seguir.

\subsection{Finalização da Conexão}
\label{subsec:mudccp-desconexao}

O processo de finalização de uma conexão \mudccps ocorre de forma similar a
outros protocolos orientados à conexão, porém com algumas diferenças. Para
sinalizar o pedido de desconexão, um cliente \mudccps transmite no canal de
controle um pacote do tipo \mudccp-Close, contendo as informações de qual
servidor e porta este deseja se desconectar. Ao receber este tipo de pacote, o
nó relay transmite ao cliente um pacote do tipo \mudccp-Reset para sinalizar que
está ciente do fechamento da conexão. Este procedimento é suficiente para o
pedido de finalização de uma conexão de um cliente \mudccp, porém para
finalizar uma conexão de um nó cliente relay ou reporter, outros procedimentos
devem ser realizados.

A desconexão de um nó relay gera uma situação crítica para todo os nós
clientes que recebem os dados de uma transmissão através dele. Diante disto,
faz-se necessário um mecanismo que promova um dos clientes conectados ao atual
nó relay -- em processo de desconexão -- em um nó relay e assim substituí-lo.
No \mudccp, considera-se candidatos a relay todos os nós reporters conectados
ao atual nó relay. Em linhas gerais, quando um nó relay deseja desconectar, o
mesmo transmite para o canal de controle um pacote do tipo \mudccp-Elect e
aguarda por um \mudccp-ElectReply. Ao receber um ou mais \mudccp-ElectReply, o
nó relay seleciona um dos nós que transmitiram o pacote do tipo
\mudccp-ElectReply e envia um pacote do tipo \mudccp-ElectAck. O pacote do tipo
\mudccp-ElectAck deve conter o endereço IP do cliente \mudccps eleito para ser
tornar um nó relay. Como este tipo de pacote é transmitido através do canal de
controle, todos os outros clientes também o receberão e este passo é cruscial
no processo de substituição de um nó relay que solicita desconexão. Isto
porque, a partir do momento que um cliente \mudccps é promovido a um nó \mudccps
relay, todos os clientes outrora conectados ao nó relay em processo de
desconexão, deve iniciar um novo processo de conexão com o novo nó relay
transmitindo um pacote do tipo \mudccp-Request.

Um aspecto que ainda está sendo estudado é a possibilidade do nó relay em
processo de desconexão transmitir ao novo nó relay a lista de todas as conexões
ativas e desta forma evitar que todos os clientes solicitem uma nova conexão ao
novo nó relay. Apasar dessa estratégia reduzir a quantidade de dados de controle
transmitido na rede, na versão atual do \mudccps esta funcionalidade não foi
incorporada ao protocolo por ser mais complexa e necessitar de mais estudos
quanto a viabilidade desta solução, principalmente se a quantidade de clientes
conectados ao nó relay em processo de desconexão for muito grande. Além disso,
para que este procedimento funcione, deve-se atualizar as informações de
\textit{sockets} de todos os clientes com o novo endereço IP e porta do novo nó
relay.

A desconexão de um nó reporter não gera uma situação muito crítica ao protocolo
\mudccps caso a quantidade de nós reporters seja maior do que $1$. Se existir
apenas um nó reporter e mais outros nós clientes conectados a um relay e um nó
reporter solicitar desconexão, o nó \mudccps deverá transmitir um pacote do tipo
\mudccp-Elect através do canal de controle solicitando que algum cliente se
promova a um nó reporter. Quando um cliente receber um pacote do tipo
\mudccp-Elect, este deverá transmitir um pacote do tipo \mudccp-ElectReply
através do canal de controle, da mesma forma que no processo de desconexão do
relay, porém um indicador especial contido no pacote \mudccp-Elect sinalizará
que trata-se de um processo de eleição de um nó reporter e não de um nó relay.

Na Seção~\ref{subsec:electrelsreps}, discute-se em mais detalhes o processo de
eleição de nós relays e reporters no contexto do protocolo \mudccp.

% 
% \subsubsection{Desconexão de um nó relay}
% 
% \subsubsection{Desconexão de um nó reporter}

\subsection{Detecção do Modo Multicast}
\label{subsec:detectmulticast}


\subsection{Eleição e Tolerância a Desconexão}
\label{subsec:electrelsreps}

Os nós relays são selecionados de duas formas: (i) serão nós relays aqueles que
iniciarem a primeira conexão unicast com algum outro nó relay ou com o nó
servidor, ou seja, o nó transmissor original; (ii) serão relays aqueles que
negociarem com algum outro nó relay sua promoção para nó relay. Note que
para este segundo caso, o nó que conceder a promoção de um nó relay para outro
nó, ele deverá se rebaixar para um nó \mudccps normal ou estar em processo de
desconexão, como discutido anteriormente. Além disso, quando um relay conceder
este status a outro nó cliente, o mesmo poderá se desconectar do nó gerador
(relay ou servidor) dos dados enviando um \mudccp-Close, que conterá o
endereço do novo nó relay. É possível também que um nó relay eleja outros nós
relays secundários, localizados na sua própria rede local. Esta funcionalidade é
importante porque caso o atual relay perca sua conexão ou desconecte do nó
transmissor gerador dos dados, qualquer relay secundário poderá assumir o papel
de relay primário. Neste caso, o nó que passar a assumir este papel deverá
enviar um pacote do tipo \mudccp-Elect informando que assumirá a transmissão de
dados outrora provida pelo nó relay antigo.

No \mudccps foi incorporado um mecanismo de tolerância a desconexão que
funciona de modo a evitar que os nós clientes deixem de receber dados da
transmissão em questão, caso um nó relay desconecte repentinamente sem conseguir
transmitir um pacote do tipo \mudccp-ElectAck, tal como explicado na
Seção~\ref{subsec:mudccp-desconexao}. Considere $T$ uma variável corresponde a
$4$ vezes o valor do tempo do RTT. Um nó relay deve transmitir no canal de
controle um pacote do tipo \mudccp-AdvConn a cada tempo $T$, anunciando aos
demais nós da rede que está ativo e operando corretamente. Caso um nó relay
secundário não receba o pacote do tipo \mudccp-AdvConn durante o período de
tempo $T$, assume-se que o relay atual foi desconectado por algum motivo
desconhecido e o relay secundário que não recebeu o pacote do tipo
\mudccp-AdvConn deverá transmitir um pacote do tipo \mudccp-ElectAck assumindo a
responsabilidade de nó relay para o grupo de clientes e reporters conectados ao
relay que foi desconectado.

Um nó ao iniciar um pedido de conexão \mudccp, se auto promove a
\mdrep\space caso ele seja o único nó em sua rede conectado ao fluxo de dados
representado por um determinado endereço IP e porta. Este procedimento foi
discutido na Seção~\ref{sec:conexaomudccp}, que trata sobre o processo de
conexão do protocolo \mudccp. Porém, outra forma de eleição de um nó cliente
\mudccps para um nó relay é quando acontece o pedido de desconexão de um nó
relay. Neste caso, um outro nó cliente deve assumir o papel de relay utilizando
o processo de eleição através do uso de pacotes do tipo \mudccp-Elect,
\mudccp-ElectReply e \mudccp-ElectAck, como explicado
na Seção~\ref{subsec:mudccp-desconexao}. A diferença é que o novo nó relay
deverá reestabelecer uma conexão unicast com o nó \mudccps ao qual o
antigo nó relay estava recebendo os dados da transmissão multimídia em questão.
Após o estabelecimento dessa conexão, que dar-se seguindo os procedimentos
descritos na Seção~\ref{sec:conexaomudccp}, o novo nó relay deve criar o canal
de repasse e começa a repassar os dados da transmissão multimídia.

Com relação aos nós reporters, o processo de eleição funciona de forma similar e
da seguinte forma: à medida que um relay recebe pacotes do tipo \mudccp-Request,
no pacote \mudccp-Response o nó relay pode ativar um indicador sinalizando que
um determinado nó cliente deverá se comportar como um nó reporter, passando a
enviar relatórios da taxa de transmissão observada por ele como descrito na
Seção~\ref{subsec:mudccp-mcc}. Note que este modo de transmissão deve ser
implementado com garantia de entrega, ou seja, com confirmação de recepção e
retransmissão caso este tipo de pacote seja perdido. Desta forma, um nó relay
poderá limitar a quantidade de nós reporters e assim receber relatórios apenas
de um sub-conjunto de nós da rede.

\subsection{Outra Estratégia para Descoberta de Nós Relays}
\label{sec:arcdescorels}

Um aspecto primordial do \mudccps é a capacidade de obter fluxos de
dados multimídia através de nós relays, os quais repassam esses dados vindo de
uma fonte geradora. No processo de conexão esses nós relays são encontrados e
todo o processo de repasse acontece. Um gargalo no procedimento padrão adotado
no \mudccps é que pode-se demorar até que um cliente \mudccps encontre um nó
relay e comece a receber o fluxo de dados desejado devido ao mecanismo de busca
por profundidade por nós relays utilizando transmissões multicast com valores
incrementais para o campo de TTL presente no cabeçalho IP.

Diante disso, está em estudo no contexto desse trabalho um mecanismo alternativo
para permitir que um nó cliente encontre um nó relay mais rapidamente. Este
mecanismo consiste em permitir que um nó cliente solicite diretamente ao nó
servidor a lista de nós relays conectados a ele. Os nós relays conectados ao
servidor são chamados de nós relays de primeiro nível, que por sua vez podem
possuir nós relays de segundo nível, os quais podem possuir nós relays de
terceiro nível e assim por diante.

O mecanismo de busca por nós relays em estudo é permitir que o cliente consulte,
ao longo dos níveis dos nós relays, aquele nó relay que mais se adequa aos
requisitos da aplicação. Um nó cliente que desejar solicitar esse tipo de
requisição, utiliza o pacote do tipo \mudccp-RelayQuery e transmite o pedido de
consulta ao nó servidor, o qual responde ao cliente com a lista dos nós relays
de primeiro nível utilizando o pacote do tipo \mudccp-RelayReply. Com isto, é
possível encontrar um melhor relay cujo atraso não ultrapasse um determinado
limiar de tempo definido pela aplicação, o que não necessariamente será o nó
relay mais próximo geograficamente do nó cliente.

%\subsection{Seleção de Parceiros e de \textit{Chunks}}

% \subsection{Balanceamento de Carga}
% 
% Um outro aspecto interessante do protocolo \mudccps é sua capacidade em
% permitir divisão de carga entre nós relays. Como os nós relays recebem e
% repassam os fluxos de dados oriundos de um servidor, obtem-se natualmente uma
% solução de distribuição de conteúdo multimídia sem sobrecarregar a fonte
% geradora de dados (geralmente o servidor). Porém, mesmo considerando o
% mecanismo atualmente empregado no \mudccps para divisão de carga entre nós
% relays, atualmente estuda-se um mecanismo complementar de balanceamento de
% carga a fim de evitar que os nós relays entre em colapso de congestionamento
% devido ao grande número de clientes conectados a um determinado nó relay.
% 
% Considerando isso, está em estudo no contexto do protocolo \mudccps um mecanismo
% de balanceamento de carga que quando um nó relay possui muitas conexões de
% clientes permite-se que outro nó cliente seja... PROBLEMA: UM RELAY POR REDE!

\subsection{Adaptação de Fluxo de Dados Multimídia}

Uma funcionalidade peculiar do \mudccps é sua capacidade de permitir a
realização de adaptação de fluxos multimídia de forma distribuída. A maioria
das soluções para transmissão de dados multimídia, além de realizarem controle
de congestionamento no nível de aplicação, realizam adaptação de fluxo
multimídia na fonte geradora dos dados. Diversas soluções existentes consideram
a transmissão de fluxos de dados multimídia adaptados e transmitidos em
diferentes canais, sendo que em cada canal transmite-se os fluxos
multimídia em uma determinada qualidade. Dependendo da qualidade
desejada pelo nó receptor, o sistema cliente solicita a transmissão em um
determinado canal. O problema dessa abordagem é que o nó transmissor,
necessariamente deve transmitir os dados em múltiplos canais, o que aumenta a
complexidade da aplicação e a quantidade de fluxos de dados sendo transmitidos a
partir do servidor.

No \mudccp, é possível realizar a adaptação de fluxo de dados de forma
distribuída, na prática, em cada DCCP \emph{Relay}. Suponhe-se que
existem duas redes adjacentes, rede 1 e rede 2. Considere que existe
um nó DCCP \emph{Relay} na rede 1 e entre esta e o nó transmissor a
largura de banda disponível é de \ut{100}{Mbps}. Caso a largura de
banda disponível na rede 2 seja de no máximo \ut{10}{Mbps}, um nó
receptor na rede 2 teria que solicitar um fluxo multimídia em um
canal diferente, considerando a solução supracitada. No caso do
\mudccps é possível que um nó na rede 2 obtenha o fluxo multimídia
através do DCCP \emph{Relay} presente na rede 1, bastante, neste
caso, que o DCCP \emph{Relay} presente na rede 1 adapte o fluxo para
o nó que esteja na rede 2. Desta forma, pode-se diminuir o tráfego
na rede do nó transmissor e ainda sim permitir que nós em redes com
baixa largura de banda consigam obter o fluxo multimídia adaptado.

\section{Benefícios e Aplicabilidade do \mudccp}

O uso do \mudccps nas aplicações de distribuição de mídia ao vivo fomenta
benefícios em três vertentes, para o desenvolvedor da aplicação; para os
usuários interessados em assistir/ouvir uma mídia ao vivo e para a rede. Esses
benefícios são detalhados a seguir.

\begin{itemize}

 \item Diminuição de fluxos de dados na rede sem qualquer controle de
congestionamento, pois aplicações para distribuição de mídia ao vivo atualmente
fazem uso do protocolo UDP ou variantes;

 \item melhoria no aproveitamento dos recursos de redes e redução de
retrabalhos por parte dos desenvolvedores de aplicações para transmissão de
mídia ao vivo. Isto ocorre porque a taxa de transmissão dos nós
participantes são reguladas de acordo com um algoritmo de controle de
congestionamento apropriado e implementado na camada de transporte, portanto
transparente para o desenvolvedor da aplicação;

 \item flexibilidade no acesso a rede por parte dos nós participantes, pois
eles podem entrar e sair da rede a qualquer momento, realizando parcerias com um
subconjunto de nós participantes a fim de receber o conteúdo multimídia
interessado, caso esteja-se utilizando o \mudccp;

 \item aumento na chance de conseguir acesso ao conteúdo multimídia de
interesse, pois se um nó estiver registrado via a aplicação Sopcast e um outro
nó estiver registrado via PPLive, ambos poderão compartilhar dados multimídia
entre si e de forma transparente;

 \item inibição do problema da tragédia dos comuns discutido no
Capítulo~\ref{cap:introducao}, pois o \mudccps compartilha o conteúdo multimídia
entre os nós participantes sem que seja necessário um pedido de conexão
explícita por parte de todo nó interessado em obter a mídia ao vivo;

 \item padronização na forma como os dados multimídia são transmitidos na rede,
pois o protocolo é implementado na camada de transporte e não na camada de
aplicação, como de costume. Isto inclui a padronização na forma como se
implementa o serviço de controle de congestionamento e a possibilidade de
estender o protocolo com o uso de novos algoritmos;

\end{itemize}

Dentre os diversos sistemas P2P para transmissão de mídia ao vivo que podem se
beneficiar com o uso do \mudccp, destacam-se os baseados em uma arquitetura em
malha e sem organização rígida dos nós participantes do sistema. Isto também se
aplica a todas as variantes dessa arquitetura como, por exemplo, híbrido por
encaminhamento automático e pedido explícito (\textit{Push-Pull}) e híbrido
árvore-malha (vide Capítulo~\ref{cap:fundamentacao}).
Especificamente, os sistemas de distribuição de mídia ao vivo mais conhecidos e
que podem se beneficiar diretamente com o uso do \mudccps são o
Sopcast~\cite{fallica_quality_2008}, o PPLive~\cite{hei_insights_2006} e o
GridMedia~\cite{li_zhao_gridmedia:_2005,zhang_peer--peer_2005}.

% , dentre
% outros referenciados em~\cite{REF, REF, REF, REF, REF}.

% discutir aqui sobre o que o protocolo trás de bom para as aplicações
% 
% - cloud computing
% 
% - transmissão de casa
% 
% - vod
% 
% - youtube/copa america
% 
% - twitcam

% \section{Outros Aspectos Importantes do \mudccp}
% 
% \subsubsection{Uso do Campo \textit{Offset} de Dados}
% 
% \subsubsection{Uso do Campo \textit{CCVal} de Dados}
% 
% \subsubsection{Soma de Verificação e Validação de Pacotes}
% 
% \subsection{Compatibilidade com outras recomendação da IETF}
% 
% - NAT
% - 4340
% - GERAÇÃO DO NÚMERO DE SEQUÊNCIA
% - RFC2365
% - RFC4086
% - RFC2119
% - TFMCC 4654
% - 5166
% - TFRC 3448

%\section{Considerações sobre redes de distribuição de conteúdo}

%\section{Considerações sobre a escolha do DCCP como base para o \mudccp}

% \section{Considerações sobre implementação}

\section{Implementação e Limitações do \mudccp}

O protocolo \mudccps está sendo implementado no simulador NS-2 e a versão atual
do protocolo já permite a execução de transmissão de dados nos moldes do que já
foi discutido anteriormente em termos de suas funcionalidades. Com o
desenvolvimento preliminar do protocolo \mudccps no simulador NS-2, permitiu-se
a execução de diversas simulações a fim de avaliar o comportamento do protocolo
considerando diversas configurações, porém o protocolo ainda apresenta algumas
limitações que precisam ser consideradas e melhoradas nas futuras versão do
mesmo.

Outros estudos estão sendo executados quanto ao funcionamento do protocolo
\mudccps e o mecanismo de NAT e suporte ao protocolo IPv6. Outras limitações no
contexto do \mudccps estão relacionadas com a capacidade do protocolo de tratar
ataques de poluição~\cite{vieira_borges_2010}, evitar eleições para nós
reporters e principalmente para nós relays de nós clientes com baixo poder de
processamento e melhoria no mecanismo de controle de congestionamento em modo
multicast, pois utiliza-se uma equação ainda baseada no ultrapassado TCP
New-Reno.

\section{Sumário do Capítulo}

Neste capítulo, apresentou-se o \textit{Global Media Transmission Protocol}
(\mudccp), um protocolo de transporte baseado em uma arquitetura P2P para
distribuição de fluxos de dados multimídia de aplicações com um nó transmissor e
muitos nós receptores (\mys), desenvolvido para operar principalmente na
Internet. O \mudccp\space permite a transmissão de pacotes de dados com suporte
a controle de congestionamento de fluxos não confiáveis, operando em modo de
transmissão multicast ou múltiplos fluxos unicast compartilhados entre os nós
participantes da transmissão, através de uma rede de favores constituída
dinamicamente a fim de evitar a relação de uma conexão por cliente ao servidor,
como acontece em protocolos unicast de transporte de dados multimídia
disponíveis na literatura.

O \mudccps possui um mecanismo de conexão separado em duas fases, onde a
primeira fase acontece quando o primeiro nó em uma rede local deseja
estabelecer uma conexão com um servidor que está transmitindo um determinado
fluxo multimídia. Ao perceber que nenhum outro nó em sua rede local está
recebendo o fluxo de dados desejado, o cliente estabelece uma conexão unicast
com o servidor e se auto promove a um nó especial chamado de relay. A segunda
fase do processo de conexão do \mudccps acontece quando um segundo nó cliente
deseja obter o mesmo fluxo de dados multimídia que o primeiro nó cliente,
considerado o nó relay daquela rede. No momento em que isto acontece, o nó
cliente é capaz de perceber a presença de um relay e passa a receber o fluxo de
dados através do nó relay em modo multicast, evitando assim um novo pedido de
conexão ao nó servidor de dados.

Um outro aspecto importante do \mudccps é seu mecanismo de controle de
congestionamento de fluxos não confiáveis. O controle de congestionamento
empregado no \mudccps funciona de forma híbrida, a depender do modo de conexão
utilizado por um determinado nó. Quando o protocolo \mudccps está operando em
modo unicast, utiliza-se o \mudccp-UCC, um algoritmo de controle de
congestionamento baseado no Cubic, o qual foi desenvolvido para o protocolo
TCP, mas que devido a sua alta capacidade de convergência e sua capacidade de
compartilhar o canal de transmissão entre os diferentes fluxos de dados,
decidiu-se adotá-lo no contexto do \mudccp. Por outro lado, se o nó \mudccps
estiver operando em uma transmissão em modo multicast, utiliza-se o
\mudccp-MCC, um algoritmo para controle de congestionamento baseado em uma
equação TFRC que faz uso de nós especiais para determinar a próxima taxa de
transmissão que um nó transmissor \mudccps deverá utilizar. Esses nós especiais
são chamados de reporters.

Em seguida, discutiu-se sobre outras funcionalidades do protocolo \mudccp, tais
como seu mecanismo para finalização de conexão, eleição de nós relays e
reporters e um mecanismo para adaptação de fluxos de dados multimídia de acordo
com a capacidade do canal. Por fim, apresentou-se o estado atual e as
limitações do protocolo \mudccp.