\chapter{Detalhamento dos Tipos de Pacotes do GMTP}
\label{app:gmtp-cabecalhos}

% todas as operações no GMTP sob o número de sequência
%    All operations on DCCP sequence numbers use circular arithmetic
%    modulo 2^48, as do comparisons such as "greater" and "greatest".
%    This form of arithmetic preserves the relationships between sequence
%    numbers as they roll over from 2^48 - 1 to 0.  Implementation
%    strategies for DCCP sequence numbers will resemble those for other
%    circular arithmetic spaces, including TCP's sequence numbers [RFC793]
%    and DNS's serial numbers [RFC1982].  It may make sense to store DCCP
%    sequence numbers in the most significant 48 bits of 64-bit integers
%    and set the least significant 16 bits to zero, since this supports a
%    common technique that implements circular comparison A < B by testing
%    whether (A - B) < 0 using conventional two's-complement arithmetic.
% Reserved bitfields in DCCP packet headers MUST be set to zero by
%    senders and MUST be ignored by receivers, unless otherwise specified.
%    This allows for future protocol extensions.  In particular, DCCP
%    processors MUST NOT reset a DCCP connection simply because a Reserved
%    field has non-zero value [RFC3360].

Neste apêndice, apresenta-se detalhes técnicos dos tipos de pacotes do 
protocolo \mudccps, discutindo-se o uso de cada campo dos cabeçalhos. Desta 
forma, este capítulo é dedicado aos leitores interessados em sua implementação.

Todos os \textit{bytes} no \mudccp, tais como números de portas, números de
seqüência e valores para opções são transmitidos em \textit{network byte order}
(primeiro os bytes mais significativos).

Os números aleatórios no \mudccps são utilizados por razões de segurança e podem
ser escolhidos de acordo com a RFC 4086~\cite{RFC4086}.

\section{Cabeçalhos e Tipos de Pacotes do \mudccp}
\label{sec:tipodepacotesmudccp-tecnica}

Na Figura~\ref{fig:cabecalhomudccp48}, ilustra-se o cabeçalho genérico do
\mudccp. O nome genérico é justificado porque o cabeçalho assume um
formato diferente dependendo do tipo de pacote transmitido. De acordo com o
tipo de pacote transmitido, o \mudccps poderá utilizar até $48$ bits para
diferentes finalidades e, nestes casos, o tamanho total do cabeçalho passa a ser
de $20$ bytes. A descrição dos campos do cabeçalho genérico é apresentada a
seguir.

\begin{figure}[ht]
    \begin{center}
        \includegraphics[scale=0.5]{imagens/mudccp-generic-header.pdf}
    \end{center}
    \vspace{-1.2cm}
    \caption{Cabeçalho Genérico do protocolo \mudccp.}
    \label{fig:cabecalhomudccp48}
\end{figure}

\begin{description}

  \item[Porta de origem e destino:] cada porta possui um tamanho de $16$ bits.
Estes campos identificam a conexão, como acontece com os protocolos TCP, UDP e
o DCCP;

  \item[\textit{Offset} de dados:] ou simplesmente \emph{offset},
determina o tamanho do cabeçalho \mudccp, contando do início do cabeçalho até o
início de onde estão os dados da aplicação. Este campo tem o tamanho de $8$
bits;

  \item[CCVal:] é utilizado pelo controle de congestionamento do sistema
transmissor. O tamanho desse campo é de $4$ bits. Em uma transmissão \mudccps
% entre um cliente e um servidor \mudccps ou de um \mdrel, o algoritmo para
controle de congestionamento de cada lado pode enviar $4$ bits de informação
para o lado oposto utilizando este campo para tal;

  \item[Tipo do pacote:] tamanho de $4$ bits. Este campo determina o tipo de
pacote que está sendo transmitido/recebido. Os possíveis valores desse campo
serão apresentados na Seção~\ref{subsec:tipopacote-mudccp};

  \item[\emph{Checksum}:] tamanho de $16$ bits. Este campo é utilizado para
checagem de erro, tradicionalmente como acontece em outros protocolosde
transporte;

  \item[Número de seqüência:] número de seqüência com $32$ bits utilizado para
transmitir requisições, podendo ser estendido para $48$ bits ao utilizar-se dos
próximos $16$ bits de conteúdo variável, o que dependerá do tipo de pacote a ser
transmitido. Como em outros protocolos, este campo identifica unicamente um
pacote transmitido na rede por um sistema final. O valor deste campo aumenta-se
em $1$ a cada pacote transmitido;

  \item[Opção:] tamanho de $4$ bits. Este campo é utilizado para sinalizar a
ativação ou não de alguma opção do \mudccp, por exemplo, para sinalizar se a
conexão entre um cliente e um relay \mudccps deve ser unicast ou multicast;

  \item[Reservado:] tamanho de $12$ bits. Campo reservado para utilizações
futuras;

  \item[Conteúdo variável:] tamanho de $48$ bits. Campo reservado para uso em
mecanismos específicos do \mudccps como, por exemplo, especificar o endereço IP
e número da porta do servidor \mudccps no momento de uma conexão
multicast.

\end{description}

\subsection{Tipos de Pacotes}
\label{subsec:tipopacote-mudccp}

No Capítulo~\ref{cap:mudccp}, apresentou-se a
Tabela~\ref{tab:tipospacotemudccp}, quando descreveu-se brevemente os tipos de
pacotes utilizados no \mudccp. No campo \emph{tipo do pacote} desse cabeçalho
genérico do \mudccp, determina-se que tipo de informação está contida no pacote
transmitido por um nó \mudccp. Isto permite que um nó execute uma determinada
ação ao recebe um pacote de um outro nó \mudccps e possivelmente gerando-se
outros pacotes como resposta. Nesta seção, apresenta-se detalhes do uso de cada
um dos tipos de pacotes, discutindo-se através de exemplos o preenchimento dos
campos do cabeçalho genérico apresentado anteriormente.

\subsubsection{\mudccp-Request}

O pacote do tipo \mudccp-Request, número 0 (0000$_2$), é utilizado pelo cliente
\mudccps para enviar um pedido de estabelecimento de conexão em modo multicast.
% Quando transmitido na rede, um nó \mdrel\space captura esse tipo de pacote e
responde ao cliente \mudccp, notificando-o a respeito do fluxo de interesse e
% que este é um dos \mdrels\space do servidor de mídia \mudccp. Considerando o
cabeçalho genérico do \mudccps ilustrado na
Figura~\ref{fig:cabecalhomudccp48}, os dois campos variáveis desse cabeçalho
são utilizados. Como pode-se observar na
Figura~\ref{fig:cabecalhomudccp-request}, o campo variável de $16$ bits é
utilizado para armezenar o número da porta do servidor de mídia \mudccps e o
segundo campo de $32$ bits é utilizado para armazenar o endereço IP desse
servidor. No processo de conexão, esses dois campos variáveis são lidos por um
% \mdrel\space a fim de identificar o fluxo de mídia desejado pelo usuário e, caso
% exista algum \mdrel\space recebendo o fluxo de mídia de interesse, o mesmo
% responde pelo pedido de conexão como se fosse o servidor de mídia \mdrel\space
original, utilizando-se do pacote \mudccp-Response, descrito a seguir. Na
Seção~\ref{sec:conexaomudccp}, discutem-se detalhes do processo de
estabelecimento de conexão do \mudccp.

\begin{figure}[ht]
    \begin{center}
        \includegraphics[scale=0.5]{imagens/mudccp-header-request.pdf}
    \end{center}
    \vspace{-1.2cm}
    \caption{Cabeçalho do pacote \mudccp-Request.}
    \label{fig:cabecalhomudccp-request}
\end{figure}

\subsubsection{\mudccp-Response}

O pacote do tipo \mudccp-Response, número 1 (0001$_2$), é utilizado pelo
% \mdrel\space para enviar uma resposta a um pedido de estabelecimento de conexão
% enviado por um cliente \mudccps em modo multicast. Quando um nó \mdrel\space
recebe um pacote \mudccp-Request, este cria um pacote do tipo \mudccp-Response
para informar ao cliente \mudccps sobre o estabelecimento de conexão.
Neste caso e considerando o cabeçalho genérico do \mudccps ilustrado na
Figura~\ref{fig:cabecalhomudccp48}, os dois campos variáveis desse cabeçalho
são utilizados. Como pode-se observar na
Figura~\ref{fig:cabecalhomudccp-response}, o campo variável de $16$ bits é
% utilizado para armezenar o número da porta do \mdrel\space e o segundo campo de
$32$ bits é utilizado para armazenar o endereço IP desse Relay. Desta forma, um
cliente \mudccps é capaz de ler pacotes do tipo \mudccp-Data transmitidos por um
% \mdrel\space via multicast na rede e reproduzir a mídia de interesse. O tipo de
pacote \mudccp-Data e \mudccp-DataAck são descritos a seguir.

\begin{figure}[ht]
    \begin{center}
        \includegraphics[scale=0.5]{imagens/mudccp-header-response.pdf}
    \end{center}
    \vspace{-1.2cm}
    \caption{Cabeçalho do pacote \mudccp-Response.}
    \label{fig:cabecalhomudccp-response}
\end{figure}

\subsubsection{\mudccp-Data e \mudccp-DataAck}

Os pacotes do tipo \mudccp-Data e \mudccp-DataAck, números 2 e 4 (0010$_2$ e
% 0100$_2$), respectivamente, são utilizados por um \mdrel\space para enviar dados
em modo multicast a todos os clientes \mudccps interessados pelo fluxo por ele
% transmitido. A partir do momento que um nó \mudccps se torna um nó \mdrel,
% através do processo de eleição de nós \mdrels, descrito na
Seção~\ref{subsec:electrelsreps}, este começa a retransmitir, em modo multicast,
% os dados vindos do servidor de mídia \mudccps ou de outro \mdrel,
utilizando pacotes dos tipos \mudccp-Data ou \mudccp-DataAck para este fim.
Neste caso, o cabeçalho genérico do \mudccps ilustrado na
Figura~\ref{fig:cabecalhomudccp48}, passa a ter a forma dos cabeçalhos
ilustrados nas Figuras~\ref{fig:cabecalhomudccp-data}
e~\ref{fig:cabecalhomudccp-dataack}, respectivamente. Note que ambos pacotes não
possuem os campos endereço IP e porta relacionados ao servidor de mídia \mudccp.
Esta decisão foi intencional para forçar que um cliente \mudccps realize o
pedido de conexão enviando o pacote \mudccp-Request, caso contrário um cliente
% \mudccps poderia capturar um pacote \mudccp-Data sem que um \mdrel\space
soubesse de sua existência.

\begin{figure}[ht]
    \begin{center}
        \includegraphics[scale=0.5]{imagens/mudccp-header-data.pdf}
    \end{center}
    \vspace{-1.2cm}
    \caption{Cabeçalho do pacote \mudccp-Data.}
    \label{fig:cabecalhomudccp-data}
\end{figure}

\begin{figure}[ht]
    \begin{center}
        \includegraphics[scale=0.5]{imagens/mudccp-header-dataack.pdf}
    \end{center}
    \vspace{-1.2cm}
    \caption{Cabeçalho do pacote \mudccp-DataAck.}
    \label{fig:cabecalhomudccp-dataack}
\end{figure}

\subsubsection{\mudccp-Ack}

O pacote do tipo \mudccp-Ack, número 3 (0011$_2$), é utilizado por um nó
\mudccps para enviar confirmações de recepção de pacotes contendo dados
enviados com garantia de entrega. Por exemplo, um pacote \mudccp-Ack pode ser
% enviado por um \mdrel\space para confirmar pacotes de definições de opções de
uma conexão \mudccps ou por um nó \mudccps ao aceitar ser eleito para ser
% um \mdrep.

\begin{figure}[ht]
    \begin{center}
        \includegraphics[scale=0.5]{imagens/mudccp-header-ack.pdf}
    \end{center}
    \vspace{-1.2cm}
    \caption{Cabeçalho do pacote \mudccp-Ack.}
    \label{fig:cabecalhomudccp-ack}
\end{figure}

\subsubsection{\mudccp-Elect, \mudccp-ElectReply e \mudccp-ElectAck}

Os pacotes do tipo \mudccp-Elect, \mudccp-ElectReply e \mudccp-ElectAck, números
5, 6 e 7 (0101$_2$, 0110$_2$ e 0111$_2$), respectivamente, são utilizados por um
% \mdrel\space ou por um cliente \mudccps para tratar do processo de eleição de
% nós \mdreps\space ou de promoções de clientes \mudccps para se tornarem \mdrel.
% Quando um \mdrel\space assume seu papel de repassar o fluxo de dados em modo
multicast para os clientes \mudccps interessados, o mesmo precisa obter
% informações sobre o estado da rede. Para isto, um \mdrel\space cria um pacote do
 tipo \mudccp-Elect e transmite no canal multicast. Quando um cliente \mudccps
% recebe um pacote deste tipo, o mesmo pode se candidatar a um \mdrep, enviando um
% pacote do tipo \mudccp-ElectReply para o nó \mdrel\space que enviou o pacote
\mudccp-Elect. Como muitos nós \mudccps podem receber um pacote \mudccp-Elect, o
% nó \mdrel\space utiliza o pacote do tipo \mudccp-ElectAck para confirmar a
eleição apenas de um subconjunto de clientes \mudccp.

Neste caso, para os pacotes \mudccp-Elect, \mudccp-ElectReply e
\mudccp-ElectAck, o cabeçalho genérico do \mudccps ilustrado na
Figura~\ref{fig:cabecalhomudccp48} passa a ter a forma dos cabeçalhos ilustrados
nas Figuras~\ref{fig:cabecalhomudccp-elect},
\ref{fig:cabecalhomudccp-electreply} e \ref{fig:cabecalhomudccp-electack},
respectivamente. Note que no pacote \mudccp-Elect, os campos variáveis de $16$ e
% $32$ bits são utilizados para o \mdrel\space especificar um número de porta e
um endereço IP para o qual um cliente \mudccps enviará um pacote do tipo
\mudccp-ElectReply.

\begin{figure}[ht]
    \begin{center}
        \includegraphics[scale=0.5]{imagens/mudccp-header-elect.pdf}
    \end{center}
    \vspace{-1.2cm}
    \caption{Cabeçalho do pacote \mudccp-Elect.}
    \label{fig:cabecalhomudccp-elect}
\end{figure}

\begin{figure}[ht]
    \begin{center}
        \includegraphics[scale=0.5]{imagens/mudccp-header-electreply.pdf}
    \end{center}
    \vspace{-1.2cm}
    \caption{Cabeçalho do pacote \mudccp-ElectReply.}
    \label{fig:cabecalhomudccp-electreply}
\end{figure}

\begin{figure}[ht]
    \begin{center}
        \includegraphics[scale=0.5]{imagens/mudccp-header-electack.pdf}
    \end{center}
    \vspace{-1.2cm}
    \caption{Cabeçalho do pacote \mudccp-ElectAck.}
    \label{fig:cabecalhomudccp-electack}
\end{figure}

\subsubsection{Outros pacotes: \mudccp-RelayQuery,
\mudccp-RelayReply, \mudccp-AdvConn, \mudccp-CloseReq, \mudccp-Close
e \mudccp-Reset}

Os pacotes \mudccp-RelayQuery, \mudccp-RelayReply, \mudccp-AdvConn,
\mudccp-CloseReq, \mudccp-Close e \mudccp-Reset tem funções e formatos
similares aos outros pacotes anteriormente discutidos.

\section{Detalhamento do Processo de Conexão do \mudccp}
\label{sec:detalhe-proc-conexao}

Como discutido na Seção~\ref{sec:conexaomudccp}, o processo de conexão do
protocolo \mudccps acontece em duas fases. A fase 1 ocorre quando não existe
nenhum nó recebendo os dados desejados por um outro nó \mudccp. Já a fase 2
ocorre quando existe um nó na rede local recebendo um fluxo de dados de
interesse de um segundo nó interessado em também recebê-lo.

\subsection{Fase 1}

O primeiro pacote a ser utilizado neste processo é o \mudccp-Request,
apresentado na Figura~\ref{fig:cabecalhomudccp-request}, seguindo-se da forma
como discutido na Seção~\ref{subsec:conn-fase1}. Um aspecto importante ainda não
discutido é o tempo que um cliente deve esperar para receber um pacote do tipo
\mudccp-Response. Baseando-se em simulações de rede realizadas no contexto desse
trabalho e considerando os padrões de tecnologia de rede atualmente difundidas,
constatou-se ser suficiente que um cliente espere por um \mudccp-Response até no
máximo \ut{300}{ms}. Considerando-se uma rede local, este tempo é suficiente
para que um relay receba um pacote \mudccp-Request, processe-o e em seguida crie
e envie um \mudccp-Response de volta para o cliente.

Mesmo com este procedimento, é possível que no final do processo existam dois
nós relays presentes na mesma rede local, o que significa duas conexões na mesma
rede local recebendo o mesmo conteúdo de dados. Como discutido na
Seção~\ref{sec:problematica}, este tipo de situação deve ser evitada ao utilizar
protocolos orientados a conexão a fim de evitar o problema da tragédia dos
comuns, principalmente considerando os cenários de aplicações estudados neste
trabalho. Dito isto, deve-se garantir que existirá apenas um relay na rede local
e, para garantir esta premissa, outra decisão foi tomada. Caso um cliente inicie
uma conexão unicast com o servidor, mas receba um pacote \mudccp-Response
durante este tempo ou após o estabelecimento da conexão com o servidor, o mesmo
deve encerrá-la e obter os dados da conexão multicast transmitidos pelo relay
que o enviou o pacote \mudccp-Response. Antes de iniciar o processo de
encerramento de conexão, um cliente nessa situação deverá contactar primeiro
o nó relay e começar a receber o fluxo de dados de interesse e em seguida este
deverá parar de agir como nó relay.

No contexto deste trabalho, atualmente estão sendo avaliadas outras propostas
para definição do tempo que um cliente deve esperar por uma resposta ao pedido
de conexão enviado por ele. Porém, de acordo com uma série de simulações
realizadas até o momento, o uso de um tempo fixo de \ut{300}{ms} é suficiente e
ao mesmo tempo simples de se implementar, pois não requer quaisquer cálculos
extras, como por exemplo, cálculos baseados no valor do RTT ou na quantidade de
saltos entre o cliente e o servidor, práticas bastante adotadas por outros
protocolos de transporte, como o TCP. Independente disto, no protocolo \mudccps
permite-se que uma aplicação cliente altere o tempo de espera padrão por um
\mudccp-Response através da própria API de \textit{sockets} padrão BSD. Para
isto, o desenvolvedor da aplicação deve utilizar a função \textit{setsockopt} e
alterar o valor da opção SO\_SNDTIMEO, aumentando-se ou diminuindo-se o tempo
padrão de espera como desejado.

Como o pacote \mudccp-Request é transmitido na rede local com TTL igual a $1$,
o pacote \mudccp-Request inicial não será roteado para a rede externa e apenas
% os nós da rede local o receberá. Note que se houvesse um \mdrel\space na rede
local, este responderia com um pacote do tipo \mudccp-Response, notificando o
cliente de que o mesmo passará a transmitir dados multimídia em modo multicast
relacionado à conexão desejada. Este procedimento está relacionado com a fase
$2$ do processo de estabelecimento de conexão do protocolo \mudccp, a seguir
discutida mais adiante.

Como exemplo de uma conexão \mudccps na fase $1$, suponha que um servidor de
mídias ao vivo esteja respondendo por conexões \textit{sockets} através do
endereço IP 200.200.211.5 e porta $8900$. Suponha também que um cliente com
endereço IP 200.200.200.1 e número de porta de origem $53900$ esteja interessado
pelo fluxo de dados enviado por este servidor. Neste caso, o cliente deve enviar
um pacote do tipo \mudccp-Request para o canal de controle do \mudccps com os
campos endereço IP e número de porta do servidor de mídia preenchidos com os
dados do \textit{socket} do servidor em questão, ou seja, endereço IP
200.200.211.5 e número de porta $8900$.

Na Figura~\ref{fig:cabecalhomudccp-request-exemplo}, ilustra-se como os campos
mais relevantes do cabeçalho do pacote \mudccp-Request devem ser preenchidos
para o caso do exemplo supracitado. Note que os valores estão preenchidos em
decimal para facilitar o entendimento, mas na prática esses valores devem estar
representados em binário. Note também que o campo IPPROTO do cabeçalho do IP
deve ser preenchido com o valor $253$. O valor para este campo é também regulado
pela IANA, que definiu o valor $253$ para protocolos experimentais, como é o
caso do \mudccp~\cite{protonum2008}.

\begin{figure}[ht]
    \begin{center}
        \includegraphics[scale=0.5]{imagens/mudccp-header-request-exemplo.pdf}
    \end{center}
    \vspace{-1.2cm}
    \caption{Exemplo do Cabeçalho do \mudccp-Request e do IP.}
    \label{fig:cabecalhomudccp-request-exemplo}
\end{figure}

Quando um nó cliente \mudccps se promove a relay, um outro procedimento deve
ser executado por ele. Após estabelecer a conexão, o relay já começa a receber o
fluxo de dados, mas em segundo plano, o relay deve continuar em busca de outro
nó relay mais próximo a ele. O objetivo desse procedimento é sempre evitar a
sobrecarga de acessos simultâneos no servidor partindo de uma mesma rede.

Para encontrar um relay em outras redes, um cliente deve enviar o pedido de
conexão utilizando o pacote do tipo \mudccp-Request, da mesma forma que da
primeira tentativa, porém com o valor de TTL igual a 2 em diante. Neste
caso, se o roteador da rede do cliente estiver participando do grupo multicast
do canal de controle do \mudccp, o mesmo deverá repassar o pacote
\mudccp-Request para suas interfaces de rede de saída. Se houver algum relay
correspondente ao pedido de conexão do cliente, este deverá responder ao cliente
em modo unicast, através do endereço IP e porta do \textit{socket} do cliente.

Note que o procedimento para descoberta de novos relays discutido anteriormente
não funcionará em redes que utilizam NAT~\cite{RFC1631} e, para a atual versão
do \mudccp, este assunto está fora do escopo deste trabalho. Como o procedimento
de encontrar um relay é baseado em busca por profundidade, não se pode conhecer
facilmente o limite de saltos até encontrar um relay correspondente a conexão
desejada pelo cliente. Desta forma, este procedimento de busca deve ser limitado
a no máximo $5$ saltos, ou seja TTL igual a $5$.

% Uma questão fundamental que pode levar a um impasse por parte do cliente é
% como este detecta se seu pacote \mudccp-Request, com TTL igual a 2 em diante,
% está sendo roteado para uma rede adjacente, mas nenhum relay foi encontrado ou
% se simplesmente seu pacote \mudccp-Request não foi roteado para uma rede
% adjante. Em ambos os casos, o comportamento será o mesmo, ou seja, nenhum pacote
% do tipo \mudccp-Response será recebido. Saber diferenciar esses dois casos é
% muito importante para evitar que o cliente continue tentando enviar pacotes
% \mudccp-Request com TTL acima de 2 quando se detecte que o roteador não
% está repassando este tipo de pacote para redes adjacentes. Na
% Seção~\ref{subsec:detectmulticast}, discute-se como o \mudccps lida com esta
% questão, onde serão apresentadas algumas estratégias para evitar este impasse.

% Como o processo de busca em profundidade adotada no protocolo \mudccps pode ser
% bastante oneroso, está em estudo uma estratégia alternativa caso nenhum relay
% seja encontrado utilizando o procedimento descrito anteriormente. Sendo assim,
% quando um cliente A não consegue encontrar nenhum relay, o mesmo pode enviar
% uma requisição da lista de relays de nível $1$ ao servidor que ele está
% conectado em modo unicast, ou seja, o cliente solicita a lista de todos os
% clientes conectados diretamente ao servidor, pois estes podem ser potenciais
% relays e estarem localizados mais próximos a ele. Na
% Seção~\ref{sec:arcdescorels}, discute-se como este processo funciona no
% protocolo \mudccp.

%  Este
% procedimento pode ser oneroso por dois motivos: (1) pode-se demorar para
% encontrar um relay e (2) mais dados de controle serão transmitidos sem a
% garantia de encontrar um relay, consumindo recursos de rede
% desnecessariamente.

\subsection{Fase 2}

A fase 2 inicia quando um relay cria um socket de repasse multicast.
Por exemplo, suponha um socket de repasse multicast no endereço IP
239.255.255.252 e número de porta $23456$. Como ilustrado na
Figura~\ref{fig:cabecalhomudccp-response-exemplo}, o relay deve preencher os
campos endereço IP e o número de porta do pacote do tipo \mudccp-Response com os
valores 239.255.255.252 e $23456$, respectivamente. Note que o pacote do tipo
\mudccp-Response a ser transmitido pelo nó relay ao cliente em resposta ao
pacote \mudccp-Request deve ser transmitido em modo unicast, neste caso para o
endereço IP 200.200.200.1 e na porta $53900$. Note que neste exemplo o endereço
IP do relay é o 200.200.200.2.

\begin{figure}[ht]
    \begin{center}
        \includegraphics[scale=0.5]{imagens/mudccp-header-response-exemplo.pdf}
    \end{center}
    \vspace{-1.2cm}
    \caption{Exemplo do Cabeçalho do \mudccp-Response.}
    \label{fig:cabecalhomudccp-response-exemplo}
\end{figure}

Um aspecto importante nesse processo é que todos os pacotes \mudccp-Response e
\mudccp-Ack utilizados no processo de conexão do \mudccp, transmitidos através
do canal de controle, devem ser transportados de forma confiável, ou seja, com o
uso de confirmação de recebimento utilizando o pacote do tipo \mudccp-Ack e
retransmissão caso pacotes desse tipo sejam perdidos.

% As regras de implementação
% desse mecanismo confiável de transmissão podem ser as mesmas adotadas no
% protocolo DCCP, descritos nas seções 6, 7 e 11 da RFC 4340~\cite{RFC4340}.

Para os casos em que um cliente encontre um relay localizado fora da sua rede
local, o relay deve iniciar um \textit{socket} unicast e repassar os dados
recebidos do servidor para o cliente em questão, criando-se portanto um
\textit{socket} para o canal de repasse. Para que o cliente saiba dessa decisão,
o relay deve enviar um pacote do tipo \mudccp-Response com os campos endereço IP
e número de porta do relay preenchidos com as informações do canal de repasse,
como ilustrado na Figura~\ref{fig:cabecalhomudccp-response-externo-exemplo}.
Nesse pacote, o primeiro bit do campo \textit{opção} deve está ativado para
sinalizar ao cliente que a transmissão é unicast e não multicast.

\begin{figure}[ht]
    \begin{center}

\includegraphics[scale=0.5]{imagens/mudccp-header-response-externo-exemplo.pdf}
    \end{center}
    \vspace{-1.2cm}
    \caption{Exemplo do Cabeçalho do \mudccp-Response quando o relay não está
na mesma rede do cliente.}
    \label{fig:cabecalhomudccp-response-externo-exemplo}
\end{figure}

\subsection{Conexão Rápida}
\label{subsec:fasccommudccp}

O processo de conexão do \mudccps requer que o cliente envie um pacote do tipo
\mudccp-Request para o canal de controle. Este procedimento objetiva fazer com
que o relay tenha conhecimento dos nós \mudccps interessados em receber o fluxo
de dados repassado pelo relay e, com este conhecimento, permitir que o relay
regule a taxa de transmissão a fim de controlar o congestionamento da rede. O
problema é que o processo de conexão do \mudccps pode demorar devido as
tentativas de busca para encontrar um nó relay. Sabendo-se disso, no \mudccps
adicionou-se um mecanismo que permite um cliente estabelecer uma conexão de
forma mais rápida.

A conexão rápida do \mudccps é opcional e funciona da seguinte forma.
Quando um cliente \mudccps se torna um nó relay e começa a enviar dados
utilizando o pacote do tipo \mudccp-Data, o mesmo pode anunciar no canal de
controle suas conexões ativas e qual canal de repasse está sendo utilizado.
Neste caso, o relay utiliza o pacote do tipo \mudccp-AdvConn para anunciar,
através do canal de controle, suas conexões de repasse ativas e clientes
interessados em obter o conteúdo multimídia correspondente pode passar a
receber pacotes de dados no canal especificado no anúncio do relay. O anúncio
do conexão de repasse deve ser enviado a cada \ut{30}{s}.

Na Figura~\ref{fig:anuncio-advconn}, ilustra-se o cabeçalho do pacote
\mudccp-AdvConn para o caso em que um nó relay tem uma conexão de repasse na
porta $32231$ através do endereço IP 200.200.200.2.

\begin{figure}[ht]
    \begin{center}

\includegraphics[scale=0.5]{imagens/mudccp-header-advconn-exemplo.pdf}
    \end{center}
    \vspace{-1.2cm}
    \caption{Exemplo do Cabeçalho do \mudccp-AdvConn para anúncio de conexão
de repasse.}
    \label{fig:anuncio-advconn}
\end{figure}

%
% \subsubsection{Desconexão de um nó relay}
%
% \subsubsection{Desconexão de um nó reporter}

%\subsection{Detecção do Modo Multicast}
%\label{subsec:detectmulticast}

% You could listen on 224.0.0.1 for 125s for an IGMP query but this wont detect
% static multicast routing.
% 
% The only sure method is to have a transport to another host on a different LAN
% segment and test a join & send. Still then dependent upon sparse or dense mode
% routing its not an immediate response.
% 
% ----
% 
% The best way is you have to have atleast 2 nodes on the both sides of a ROUTER.
% Then you can run a very small Utility written in C Lang called "mcfirst" and a
% sender "vlc" or "smtext" etc. So Scene is
% 
% PC1 (Sender)---->>-- Router ---->>-----PC2 (Receiver)
% 
% If you have any issue you can send message to me.
% 
% Above works for both IPv4 and IPv6


% - A frequencia que é feito (pode ser proporcional ao valor de p), quanto maior
% p, provavelmente maior será rtt

% \subsection{Envio da Taxa de Transmissão}
% \label{subsec:txetime}
%
% FALAR AQUI DO FORMATO DO PACOTE

% \subsection{Frequência de Envio de Relatórios}
% \label{subsec:freqenvrel}
%
% Essa taxa não pode ser muito alta para não causar o problema da
% \textit{explosão
% de feedbacks}, porém, se essa taxa for muito baixa, o \mudccp-MCC irá demorar
% para reagir às mudanças do estado da rede. Para o caso que a taxa de envio de
% relatórios for muito baixa, dois
% problemas agravantes podem ser observados. O primeiro problema é se a taxa de
% transmissão estiver muito alta e o nó receptor perceber muitas perdas de
% pacotes. Neste caso, o transmissor pode levar a rede a altos níveis de
% congestionamento e, como consequência, o \mudccp-MCC pode não manter a
% equidade
% para com fluxos do protocolo TCP. E o seguindo problema é se a taxa de
% transmissão praticada pelo nó transmissor estiver muito baixa e o nó receptor
% calcular uma taxa maior do que a atual. Neste caso, o algoritmo \mudccp-MCC
% pode
% sub-utilizar o canal de transmissão por um determinado instante até que a nova
% taxa de transmissão seja enviada para o nó transmissor.

\section{Considerações sobre Implementação}

O núcleo do protocolo \mudccps foi implementado no simulador NS-2 e a versão atual
do protocolo já permite a execução de transmissão de dados. Com o
desenvolvimento preliminar do protocolo \mudccps no simulador NS-2, permitiu-se
a execução de diversas simulações a fim de avaliar o comportamento do protocolo
considerando diversas configurações.

Em linhas gerais, a implementação no referido simulador de rede permite a
comunicação entre os nós através dos modos de transmissão multicast e unicast.
Foram implementados os tipos de pacotes do \mudccps e os processos de
estabelecimento de conexão, incluindo o processo de uso de nós relays, troca
de dados em modos multicast e unicast e os algoritmos para controle de
congestionamento, incluindo o uso de nós reporters.

Contudo, não foi implementado o arcabouço de extensão para permitir o
desenvolvimento de novos algoritmos para o processo de conexão, descoberta e
seleção de nós, adaptação de fluxo de dados e tolerância a falhas. Tal
implementação será feita no núcleo do sistema operacional Linux, juntamente com
todos os mecanismos básicos para o funcionamento do \mudccp.

A proposta é de implementar um arcabouço de extensão para as funções previstas
no \mudccp, permitindo-se o desenvolvimento e adição de novos algoritmos para
as funcionalidades supracitadas, de modo que torne o \mudccps flexível para
permitir que qualquer aplicação os utilizem.

Na prática, um cenário desejado para essa proposta de implementação do \mudccps
é que o desenvolvedor possa configurar quais algoritmos deseja utilizar em sua
aplicação, permitindo-se que estes sejam alterados em modo de execução da
da mesma. Neste caso, suponha um algoritmo de descoberta de nós chamado
\textit{DN-1}, um algoritmo para controle de congestionamento chamado
\textit{CC-2}, um algoritmo de tolerância a desconexão \textit{TD-3}; um
algoritmo de adaptação de fluxo \textit{AF-4} e um algoritmo para reciprocidade
\textit{R-2}. As implementações de tais algoritmos serão feitas na camada de
transporte, acoplando-as em forma de módulos do sistema operacional ao protocolo
\mudccp. Em seguida, as aplicações podem selecionar quais algoritmos melhor se
adequa as suas necessidades, com o \mudccps sendo responsável por:

\begin{enumerate}

  \item carregar o conjunto de algoritmos \textit{A = \{DN-1, CC-2, TD-3, AF-4,
R-2\}};

  \item definir os parâmetros iniciais para cada um dos algoritmos em A,
definidos pela aplicação;

  \item executar funções preliminares para ajustes iniciais, tais como informar
aos nós participantes de uma transmissão quais dos algoritmos estão sendo
utilizados (o conjunto \textit{A}) e quais outros estão disponíveis;

  \item executar os algoritmos em momentos apropriados de acordo com os eventos
de rede, notificando a aplicação caso necessário e desejável pela aplicação;

  \item descarregar os algoritmos quando não forem mais necessários e informar
aos nós parceiros.

\end{enumerate}

Desta forma, um nó servidor poderá solicitar que seus nós clientes carreguem um
determinado módulo, dependendo da sua disponibilidade nos nós clientes. Neste
caso, o \mudccps controlará todo o processo de carregamento dos mesmos.

Com isso, o \mudccps se tornará um protocolo extensível que gerencia quais
algoritmos devem ser executados em cada ponto de extensão. Esses algoritmos
podem ser adicionados ao protocolo através de módulos do sistema operacional,
carregáveis utilizando-se comandos como o \textit{modprobe} (no Linux, por
exemplo) e manipulados (passagem de parâmetros) pela aplicação através de uma
API de programação, por exemplo, utilizando-se as primitivas
\textit{setsockopt()} e \textit{getsockopt()} da especificação \textit{BSD
Socket API}~\cite{1197551}.

Para que as aplicações possam utilizar o \mudccp, o protocolo deve ser
compatível com todas as funções prevista na especificação \textit{BSD Socket
API}, são elas: \textit{socket()}, \textit{bind()}, \textit{listen()},
\textit{connect()}, \textit{accept()}, \textit{send()}, \textit{recv()},
\textit{write()}, \textit{read()}, \textit{sendto()}, \textit{recvfrom()},
\textit{close()}, \textit{select()}, \textit{setsockopt()},
\textit{getsockopt()} e \textit{pull()}.

Outros trabalhos podem ser desenvolvidos para tornar o \mudccps compatível com o
padrão de \textit{sockets} do sistema operacional Windows, conhecido pelo nome
de \textit{winsock}. Todavia, por ser um sistema operacional de código fechado,
a implementação do \mudccps só será possível após sua padronização em forma de
RFC.

% http://en.wikipedia.org/wiki/Berkeley_sockets

\section{Sumário do Capítulo}

Neste capítulo, apresentou-se uma visão técnica do \mudccp. Discutiu-se o uso e
as aplicabilidades dos diferentes tipos de pacotes do \mudccp, onde foram
abordados exemplos para a execução das funcionalidade de tal protocolo.

Em seguida, apresentou-se discussões acerca do processo de estabelecimento de
conexão do \mudccps e uma formalização do algoritmo para controle de
congestionamento em modo de transmissão multicast empregado no
\mudccps através do uso de teoria de conjuntos.

Por fim, apresentou-se algumas considerações importantes quanto a implementação
do \mudccps em sistemas operacionais, tais como o Linux (\textit{BSD Socket
API}) e Windows (\textit{Winsock API}).