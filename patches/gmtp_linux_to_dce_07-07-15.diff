diff --git a/linux-4.0.3/net/gmtp/gmtp.h b/linux-4.0.3/net/gmtp/gmtp.h
index cc81016..4e7650e 100644
--- a/linux-4.0.3/net/gmtp/gmtp.h
+++ b/linux-4.0.3/net/gmtp/gmtp.h
@@ -194,6 +194,7 @@ struct sock *gmtp_check_req(struct sock *sk, struct sk_buff *skb,
 			    struct request_sock **prev);
 void gmtp_reqsk_send_ack(struct sock *sk, struct sk_buff *skb,
 			 struct request_sock *rsk);
+unsigned int gmtp_poll(struct file *file, struct socket *sock, poll_table *wait);
 
 
 /** GMTP structs and etc **/
diff --git a/linux-4.0.3/net/gmtp/ipv4.c b/linux-4.0.3/net/gmtp/ipv4.c
index 0d8076a..0940a77 100644
--- a/linux-4.0.3/net/gmtp/ipv4.c
+++ b/linux-4.0.3/net/gmtp/ipv4.c
@@ -1179,7 +1179,7 @@ static const struct proto_ops inet_gmtp_ops = {
 		.socketpair = sock_no_socketpair,
 		.accept = inet_accept,
 		.getname = inet_getname,
-		/*	.poll		   = dccp_poll, */
+		.poll = gmtp_poll,
 		.ioctl = inet_ioctl,
 		.listen = inet_gmtp_listen,
 		.shutdown = inet_shutdown,
diff --git a/linux-4.0.3/net/gmtp/proto.c b/linux-4.0.3/net/gmtp/proto.c
index d38495f..38303d8 100644
--- a/linux-4.0.3/net/gmtp/proto.c
+++ b/linux-4.0.3/net/gmtp/proto.c
@@ -10,6 +10,7 @@
 
 #include <uapi/linux/gmtp.h>
 #include <linux/gmtp.h>
+#include <linux/poll.h>
 #include "gmtp.h"
 #include "mcc.h"
 
@@ -75,7 +76,7 @@ const char *gmtp_state_name(const int state)
 	[GMTP_OPEN]		= "OPEN",
 	[GMTP_REQUESTING]	= "REQUESTING",
 	[GMTP_LISTEN]		= "LISTEN",
-	[GMTP_REQUEST_RECV]		= "REQUEST/REGISTER_RECEIVED",
+	[GMTP_REQUEST_RECV]     = "REQUEST/REGISTER_RECEIVED",
 	[GMTP_ACTIVE_CLOSEREQ]	= "CLOSEREQ",
 	[GMTP_PASSIVE_CLOSE]	= "PASSIVE_CLOSE",
 	[GMTP_CLOSING]		= "CLOSING",
@@ -600,6 +601,55 @@ out:
 
 EXPORT_SYMBOL_GPL(gmtp_recvmsg);
 
+unsigned int gmtp_poll(struct file *file, struct socket *sock,
+                poll_table *wait) {
+	unsigned int mask;
+	struct sock *sk = sock->sk;
+
+	sock_poll_wait(file, sk_sleep(sk), wait);
+	if (sk->sk_state == GMTP_LISTEN)
+		return inet_csk_listen_poll(sk);
+
+	/* Socket is not locked. We are protected from async events
+	   by poll logic and correct handling of state changes
+	   made by another threads is impossible in any case.
+	 */
+
+	mask = 0;
+	if (sk->sk_err)
+		mask = POLLERR;
+
+	if (sk->sk_shutdown == SHUTDOWN_MASK || sk->sk_state == GMTP_CLOSED)
+		mask |= POLLHUP;
+	if (sk->sk_shutdown & RCV_SHUTDOWN)
+		mask |= POLLIN | POLLRDNORM | POLLRDHUP;
+
+	/* Connected? */
+	if ((1 << sk->sk_state) & ~(GMTPF_REQUESTING)) {
+		if (atomic_read(&sk->sk_rmem_alloc) > 0)
+			mask |= POLLIN | POLLRDNORM;
+
+		if (!(sk->sk_shutdown & SEND_SHUTDOWN)) {
+			if (sk_stream_is_writeable(sk)) {
+				mask |= POLLOUT | POLLWRNORM;
+			} else {  /* send SIGIO later */
+				set_bit(SOCK_ASYNC_NOSPACE,
+					&sk->sk_socket->flags);
+				set_bit(SOCK_NOSPACE, &sk->sk_socket->flags);
+
+				/* Race breaker. If space is freed after
+				 * wspace test but before the flags are set,
+				 * IO signal will be lost.
+				 */
+				if (sk_stream_is_writeable(sk))
+					mask |= POLLOUT | POLLWRNORM;
+			}
+		}
+	}
+	return mask;
+}
+EXPORT_SYMBOL_GPL(gmtp_poll);
+
 int gmtp_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
 		size_t len)
 {
