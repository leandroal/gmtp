diff --git a/net-next-sim/include/linux/gmtp.h b/net-next-sim/include/linux/gmtp.h
index ced752f..2be09fe 100644
--- a/net-next-sim/include/linux/gmtp.h
+++ b/net-next-sim/include/linux/gmtp.h
@@ -226,6 +226,13 @@ struct gmtp_sock {
 	unsigned long			tx_max_rate;
 	int 				tx_byte_budget;
 	int				tx_adj_budget;
+
+	struct timer_list		xmit_timer;
+};
+
+struct gmtp_packet_info {
+	struct sock			*sk;
+	struct sk_buff			*skb;
 };
 
 static inline struct gmtp_sock *gmtp_sk(const struct sock *sk)
@@ -336,6 +343,12 @@ static inline __u32 gmtp_data_len(const struct sk_buff *skb)
 	return (__u32)(skb_tail_pointer(skb) - gmtp_data(skb));
 }
 
+static inline int gmtp_data_hdr_len(void)
+{
+	return sizeof(struct gmtp_hdr)
+			+ gmtp_packet_hdr_variable_len(GMTP_PKT_DATA);
+}
+
 #endif /* LINUX_GMTP_H_ */
 
 
diff --git a/net-next-sim/net/gmtp/gmtp-inter/build.c b/net-next-sim/net/gmtp/gmtp-inter/build.c
index 996b0f7..d8aa283 100644
--- a/net-next-sim/net/gmtp/gmtp-inter/build.c
+++ b/net-next-sim/net/gmtp/gmtp-inter/build.c
@@ -78,8 +78,6 @@ struct gmtp_hdr *gmtp_inter_make_request_notify_hdr(struct sk_buff *skb,
 	int gmtp_hdr_len = sizeof(struct gmtp_hdr)
 			+ sizeof(struct gmtp_hdr_reqnotify);
 
-	gmtp_print_function();
-
 	transport_header = kmalloc(gmtp_hdr_len, gfp_any());
 	memset(transport_header, 0, gmtp_hdr_len);
 
diff --git a/net-next-sim/net/gmtp/gmtp-inter/gmtp-inter.c b/net-next-sim/net/gmtp/gmtp-inter/gmtp-inter.c
index acec81e..b8dafec 100644
--- a/net-next-sim/net/gmtp/gmtp-inter/gmtp-inter.c
+++ b/net-next-sim/net/gmtp/gmtp-inter/gmtp-inter.c
@@ -80,7 +80,7 @@ unsigned char *gmtp_inter_build_relay_id(void)
 	char mac_address[6];
 
 	char buffer[50];
-	__u8 *str[30];
+	u8 *str[30];
 
 	gmtp_print_function();
 
@@ -196,16 +196,13 @@ unsigned int hook_func_in(unsigned int hooknum, struct sk_buff *skb,
 
 		struct gmtp_hdr *gh = gmtp_hdr(skb);
 
-		if(gh->type != GMTP_PKT_DATA && gh->type != GMTP_PKT_FEEDBACK) {
-			gmtp_pr_debug("GMTP packet: %s (%d)",
-					gmtp_packet_name(gh->type), gh->type);
-			print_packet(skb, true);
-			print_gmtp_packet(iph, gh);
-		}
-
 		switch(gh->type) {
 		case GMTP_PKT_REQUEST:
-			ret = gmtp_inter_request_rcv(skb);
+			if(iph->ttl == 1) {
+				print_packet(skb, true);
+				print_gmtp_packet(iph, gh);
+				ret = gmtp_inter_request_rcv(skb);
+			}
 			break;
 		case GMTP_PKT_REGISTER_REPLY:
 			ret = gmtp_inter_register_reply_rcv(skb);
@@ -248,13 +245,6 @@ unsigned int hook_func_out(unsigned int hooknum, struct sk_buff *skb,
 
 		struct gmtp_hdr *gh = gmtp_hdr(skb);
 
-		if(gh->type != GMTP_PKT_DATA) {
-			gmtp_print_debug("GMTP packet: %s (%d)",
-					gmtp_packet_name(gh->type), gh->type);
-			print_packet(skb, false);
-			print_gmtp_packet(iph, gh);
-		}
-
 		switch(gh->type) {
 		case GMTP_PKT_REGISTER:
 			ret = gmtp_inter_register_out(skb);
@@ -275,6 +265,8 @@ unsigned int hook_func_out(unsigned int hooknum, struct sk_buff *skb,
 int init_module()
 {
 	int ret = 0;
+	 __u8 relay_id[21];
+
 	gmtp_pr_func();
 	gmtp_print_debug("Starting GMTP-Inter");
 
@@ -298,23 +290,16 @@ int init_module()
 	gmtp_inter.rx_rate_wnd = 1000;
 	memset(&gmtp_inter.mcst, 0, 4 * sizeof(unsigned char));
 
-/*	gmtp_inter.relay_id = kmalloc(MD5_LEN * sizeof(__u8), GFP_KERNEL);*/
 	unsigned char *rid = gmtp_inter_build_relay_id();
 	if(rid == NULL) {
-		int i;
-		 __u8 id[21];
-		gmtp_pr_error("Relay ID lookup failed...\n");
-		gmtp_pr_info("Creating a random id (based on jiffies).\n");
-		memset(gmtp_inter.relay_id, 0, GMTP_FLOWNAME_LEN);
-		for(i = 0; i < GMTP_FLOWNAME_LEN; i += sizeof(jiffies)) {
-			memcpy(&gmtp_inter.relay_id[i], &jiffies, sizeof(jiffies));
-		}
-		pr_info("Getting relay id...\n");
-		flowname_strn(id, gmtp_inter.relay_id, MD5_LEN);
-		pr_info("Relay ID = %s\n", id);
+		gmtp_pr_error("Relay ID build failed. Creating a random id.\n");
+		get_random_bytes(gmtp_inter.relay_id, 128);
 	} else
 		memcpy(gmtp_inter.relay_id, rid, GMTP_FLOWNAME_LEN);
 
+	flowname_strn(relay_id, gmtp_inter.relay_id, MD5_LEN);
+	pr_info("Relay ID = %s\n", relay_id);
+
 	gmtp_inter.hashtable = gmtp_inter_create_hashtable(64);
 	if(gmtp_inter.hashtable == NULL) {
 		gmtp_print_error("Cannot create hashtable...");
diff --git a/net-next-sim/net/gmtp/gmtp-inter/gmtp-inter.h b/net-next-sim/net/gmtp/gmtp-inter/gmtp-inter.h
index 53650fb..4c6ed4d 100644
--- a/net-next-sim/net/gmtp/gmtp-inter/gmtp-inter.h
+++ b/net-next-sim/net/gmtp/gmtp-inter/gmtp-inter.h
@@ -24,7 +24,7 @@
 
 #define CAPACITY_DEFAULT 1250000 /* bytes/s => 10 Mbit/s */
 
-extern const char *gmtp_packet_name(const int);
+extern const char *gmtp_packet_name(const __u8);
 extern const char *gmtp_state_name(const int);
 extern void flowname_str(__u8* str, const __u8* flowname);
 extern void print_gmtp_packet(const struct iphdr *iph, const struct gmtp_hdr *gh);
@@ -171,13 +171,14 @@ static inline void print_gmtp_data(struct sk_buff *skb, char* label)
 {
 	__u8* data = gmtp_data(skb);
 	__u32 data_len = gmtp_data_len(skb);
-
+	char *lb = (label != NULL) ? label : "Data";
 	if(data_len > 0) {
-		char *lb = (label != NULL) ? label : "Data";
 		unsigned char *data_str = kmalloc(data_len+1, GFP_KERNEL);
 		memcpy(data_str, data, data_len);
 		data_str[data_len] = '\0';
 		pr_info("%s: %s\n", lb, data_str);
+	} else {
+		pr_info("%s: <empty>\n", lb);
 	}
 }
 
diff --git a/net-next-sim/net/gmtp/gmtp-inter/input-inter.c b/net-next-sim/net/gmtp/gmtp-inter/input-inter.c
index e656c1a..12933ee 100644
--- a/net-next-sim/net/gmtp/gmtp-inter/input-inter.c
+++ b/net-next-sim/net/gmtp/gmtp-inter/input-inter.c
@@ -68,6 +68,8 @@ int gmtp_inter_request_rcv(struct sk_buff *skb)
 		case GMTP_INTER_WAITING_REGISTER_REPLY:
 			code = 	GMTP_REQNOTIFY_CODE_WAIT;
 			gh->type = GMTP_PKT_REGISTER;
+			iph->ttl = 64;
+			ip_send_check(iph);
 			break;
 		case GMTP_INTER_REGISTER_REPLY_RECEIVED:
 		case GMTP_INTER_TRANSMITTING:
@@ -94,7 +96,10 @@ int gmtp_inter_request_rcv(struct sk_buff *skb)
 					gh->flowname);
 			max_nclients = new_reporter(entry);
 			code = GMTP_REQNOTIFY_CODE_WAIT;
+
 			gh->type = GMTP_PKT_REGISTER;
+			iph->ttl = 64;
+			ip_send_check(iph);
 		} else {
 			gmtp_pr_error("Failed to insert flow in table (%d)", err);
 			ret = NF_DROP;
@@ -133,9 +138,12 @@ static inline struct gmtp_client *jump_over_gmtp_intra(struct sk_buff *skb,
 	struct gmtp_hdr *gh = gmtp_hdr(skb);
 	struct gmtp_client *client = gmtp_get_first_client(list_head);
 
-	gh->dport = client->port;
-	iph->daddr = client->addr;
-	ip_send_check(iph);
+	if(client != NULL) {
+		gh->dport = client->port;
+		iph->daddr = client->addr;
+		ip_send_check(iph);
+	} else
+		pr_info("There are no clients anymore!\n");
 	return client;
 }
 
@@ -195,6 +203,9 @@ int gmtp_inter_register_reply_rcv(struct sk_buff *skb)
 	entry = gmtp_inter_lookup_media(gmtp_inter.hashtable, gh->flowname);
 	if(entry == NULL)
 		return NF_ACCEPT;
+
+	print_packet(skb, true);
+	print_gmtp_packet(iph, gh);
 	info = entry->info;
 
 	gh_route_n = gmtp_inter_make_route_hdr(skb);
@@ -260,16 +271,18 @@ int gmtp_inter_ack_rcv(struct sk_buff *skb)
 	struct gmtp_flow_info *info;
 	struct gmtp_client *reporter;
 
-	gmtp_print_function();
-
 	entry = gmtp_inter_lookup_media(gmtp_inter.hashtable, gh->flowname);
 	if(entry == NULL)
 		return NF_ACCEPT;
 
+	gmtp_print_function();
+	print_packet(skb, true);
+	print_gmtp_packet(iph, gh);
+
 	info = entry->info;
 	reporter = gmtp_get_client(&info->clients->list, iph->saddr, gh->sport);
 	if(reporter != NULL) {
-		print_gmtp_packet(iph, gh);
+		pr_info("Reporter is not NULL!\n");
 		reporter->ack_rx_tstamp = jiffies_to_msecs(jiffies);
 	}
 
@@ -287,13 +300,13 @@ int gmtp_inter_feedback_rcv(struct sk_buff *skb)
 	struct gmtp_flow_info *info;
 	struct gmtp_client *reporter;
 
-/*	print_gmtp_packet(iph, gh);*/
-
 	entry = gmtp_inter_lookup_media(gmtp_inter.hashtable, gh->flowname);
 	if(entry == NULL)
 		return NF_ACCEPT;
 	info = entry->info;
 
+	/*print_gmtp_packet(iph, gh);*/
+
 	reporter = gmtp_get_client(&info->clients->list, iph->saddr, gh->sport);
 	if(reporter == NULL)
 		return NF_DROP;
@@ -316,12 +329,13 @@ int gmtp_inter_elect_resp_rcv(struct sk_buff *skb)
 	struct gmtp_hdr *gh = gmtp_hdr(skb);
 	struct gmtp_inter_entry *entry;
 
-	gmtp_pr_func();
-
 	entry = gmtp_inter_lookup_media(gmtp_inter.hashtable, gh->flowname);
 	if(entry == NULL)
 		return NF_ACCEPT;
 
+	print_packet(skb, true);
+	print_gmtp_packet(iph, gh);
+
 	gmtp_list_add_client(++entry->info->nclients, iph->saddr,
 					gh->sport, gmtp_inter.kreporter,
 					&entry->info->clients->list);
@@ -358,6 +372,8 @@ static inline void gmtp_update_stats(struct gmtp_flow_info *info,
 	gmtp_inter.ucc_bytes += skblen(skb);
 }
 
+
+
 /**
  * P = p.flowname
  * If P != NULL:
@@ -404,12 +420,14 @@ int gmtp_inter_close_rcv(struct sk_buff *skb)
 	struct iphdr *iph = ip_hdr(skb);
 	struct gmtp_inter_entry *entry;
 
-	gmtp_pr_func();
-
 	entry = gmtp_inter_lookup_media(gmtp_inter.hashtable, gh->flowname);
 	if(entry == NULL)
 		return NF_ACCEPT;
 
+	gmtp_pr_func();
+	print_packet(skb, true);
+	print_gmtp_packet(iph, gh);
+
 	if(iph->saddr != entry->server_addr
 			|| entry->state == GMTP_INTER_CLOSED)
 		return NF_ACCEPT;
diff --git a/net-next-sim/net/gmtp/gmtp-inter/mcc-inter.c b/net-next-sim/net/gmtp/gmtp-inter/mcc-inter.c
index cf50b88..6f4724d 100644
--- a/net-next-sim/net/gmtp/gmtp-inter/mcc-inter.c
+++ b/net-next-sim/net/gmtp/gmtp-inter/mcc-inter.c
@@ -61,11 +61,12 @@ void mcc_timer_callback(unsigned long data)
 	struct gmtp_flow_info *info = (struct gmtp_flow_info*) data;
 	struct gmtp_client *reporter, *temp;
 
-	if(likely(info->nfeedbacks > 0))
+	/* FIXME FIX MCC on reporters to generate correct TX_rate... */
+/*	if(likely(info->nfeedbacks > 0))
 		info->required_tx = DIV_ROUND_CLOSEST(info->sum_feedbacks,
 				info->nfeedbacks);
 	else
-		info->required_tx /= 2;
+		info->required_tx /= 2;*/
 
 	/*pr_info("n_feedbacks: %u\n", info->nfeedbacks);
 	pr_info("Required_tx=%u bytes/s\n", info->required_tx);*/
diff --git a/net-next-sim/net/gmtp/gmtp-inter/output-inter.c b/net-next-sim/net/gmtp/gmtp-inter/output-inter.c
index eca3f30..e85e526 100644
--- a/net-next-sim/net/gmtp/gmtp-inter/output-inter.c
+++ b/net-next-sim/net/gmtp/gmtp-inter/output-inter.c
@@ -20,17 +20,19 @@ int gmtp_inter_register_out(struct sk_buff *skb)
 	struct gmtp_hdr *gh = gmtp_hdr(skb);
 	struct gmtp_inter_entry *entry;
 
-	gmtp_pr_func();
-
 	entry = gmtp_inter_lookup_media(gmtp_inter.hashtable, gh->flowname);
 	if(entry == NULL)
 		return NF_DROP;
 
+	print_packet(skb, false);
+	print_gmtp_packet(iph, gh);
+
 	/* FIXME Get a valid and unused port */
 	entry->info->my_addr = gmtp_inter_device_ip(skb->dev);
 	entry->info->my_port = gh->sport;
 
 	iph->saddr = entry->info->my_addr;
+	iph->ttl = 64;
 	ip_send_check(iph);
 
 	return NF_ACCEPT;
@@ -185,12 +187,14 @@ int gmtp_inter_close_out(struct sk_buff *skb)
 	struct gmtp_hdr *gh = gmtp_hdr(skb);
 	struct gmtp_inter_entry *entry;
 
-	gmtp_pr_func();
-
 	entry = gmtp_inter_lookup_media(gmtp_inter.hashtable, gh->flowname);
 	if(entry == NULL)
 		return NF_ACCEPT;
 
+	gmtp_pr_func();
+	print_packet(skb, false);
+	print_gmtp_packet(iph, gh);
+
 	switch(entry->state) {
 	case GMTP_INTER_TRANSMITTING:
 		return gmtp_inter_close_from_client(skb, entry);
diff --git a/net-next-sim/net/gmtp/gmtp.h b/net-next-sim/net/gmtp/gmtp.h
index 7001497..7210742 100644
--- a/net-next-sim/net/gmtp/gmtp.h
+++ b/net-next-sim/net/gmtp/gmtp.h
@@ -132,7 +132,7 @@ void gmtp_shutdown(struct sock *sk, int how);
 void gmtp_destroy_sock(struct sock *sk);
 void gmtp_set_state(struct sock*, const int);
 int inet_gmtp_listen(struct socket *sock, int backlog);
-const char *gmtp_packet_name(const int);
+const char *gmtp_packet_name(const __u8);
 const char *gmtp_state_name(const int);
 void flowname_str(__u8* str, const __u8 *flowname);
 void print_gmtp_packet(const struct iphdr *iph, const struct gmtp_hdr *gh);
@@ -173,6 +173,7 @@ struct sk_buff *gmtp_make_register_reply(struct sock *sk, struct dst_entry *dst,
 struct sk_buff *gmtp_ctl_make_reset(struct sock *sk,
 		struct sk_buff *rcv_skb);
 /** output.c - Packet Output and Timers  */
+void gmtp_write_xmit_timer(unsigned long data);
 void gmtp_write_space(struct sock *sk);
 int gmtp_retransmit_skb(struct sock *sk);
 struct sk_buff *gmtp_ctl_make_elect_response(struct sock *sk,
@@ -198,6 +199,7 @@ unsigned int gmtp_poll(struct file *file, struct socket *sock, poll_table *wait)
 /** GMTP structs and etc **/
 struct gmtp_info {
 	unsigned char 		relay_enabled:1;
+	int pkt_sent;
 
 	struct sock		*control_sk;
 	struct sockaddr_in	*ctrl_addr;
@@ -236,6 +238,7 @@ struct gmtp_skb_cb {
 	__u8 reset_code,
 		reset_data[3];
 	__u8 elect_code:2;
+	__u8 retransmits;
 	__be32 seq;
 	__be32 server_tstamp;
 };
diff --git a/net-next-sim/net/gmtp/hash/hash.h b/net-next-sim/net/gmtp/hash/hash.h
index a114ee7..04bc624 100644
--- a/net-next-sim/net/gmtp/hash/hash.h
+++ b/net-next-sim/net/gmtp/hash/hash.h
@@ -93,13 +93,9 @@ void gmtp_del_client_entry(struct gmtp_hashtable *table, const __u8 *key);
 /**
  * struct gmtp_server_entry - An entry in server hash table
  *
- * @srelay: 	source of route (route[route->nrelays]).
- * 			the primary key at table is 'srelay->relayid'
- * @route:	the route stored in table
- * @next: 	the next entry with the same key (hash)
  */
 struct gmtp_server_entry {
-	/* gmtp_hash_entry has to be the first member of gmtp_client_entry */
+	/* gmtp_hash_entry has to be the first member of gmtp_server_entry */
 	struct gmtp_hash_entry		entry;
 
 	struct gmtp_hashtable 		*relay_hashtable;
@@ -112,20 +108,11 @@ int gmtp_add_server_entry(struct gmtp_hashtable *table, const __u8 *flowname,
  * struct gmtp_relay_table_entry - An entry in relays hash table (in server)
  * @next: 	the next entry with the same key (hash)
  *
- * @relay: the relay info
- * @nextRelay: 	the next relay in path
- * @relay_id: the relay id (key)
- * @relay_ip: the relay ip
- *
  * @list:  the list head
  */
 struct gmtp_relay_entry {
 	struct gmtp_hash_entry		entry;
-
 	struct gmtp_relay 		relay;
-	struct gmtp_relay_entry		*nextRelay;
-	struct gmtp_relay_entry		*prevRelayList;
-
 	struct list_head 		list;
 };
 
diff --git a/net-next-sim/net/gmtp/hash/hash_server.c b/net-next-sim/net/gmtp/hash/hash_server.c
index 35fe384..91d73d5 100644
--- a/net-next-sim/net/gmtp/hash/hash_server.c
+++ b/net-next-sim/net/gmtp/hash/hash_server.c
@@ -28,55 +28,43 @@ const struct gmtp_hash_ops gmtp_relay_hash_ops = {
 static struct gmtp_relay_entry *gmtp_build_relay_entry(
 		const struct gmtp_relay *relay)
 {
-	struct gmtp_relay_entry *entry;
-	entry = kmalloc(sizeof(struct gmtp_relay_entry), GFP_KERNEL);
-	if(entry == NULL)
-		return NULL;
+	struct gmtp_relay_entry *relay_entry;
 
-	entry->nextRelay = NULL;
-	entry->prevRelayList = NULL;
+	relay_entry = kmalloc(sizeof(struct gmtp_relay_entry), GFP_KERNEL);
+	if(relay_entry == NULL)
+		return NULL;
 
-	memcpy(entry->entry.key, relay->relay_id, GMTP_HASH_KEY_LEN);
-	memcpy(&entry->relay, relay, sizeof(struct gmtp_relay));
+	memcpy(relay_entry->entry.key, relay->relay_id, GMTP_HASH_KEY_LEN);
+	memcpy(&relay_entry->relay, relay, sizeof(struct gmtp_relay));
 
-	return entry;
+	return relay_entry;
 }
 
-int gmtp_add_relay_entries(struct gmtp_hashtable *rtable,
-		struct gmtp_hdr_route *route)
+int gmtp_add_route(struct gmtp_server_entry* server,
+		struct gmtp_hdr_route *route_hdr)
 {
+	struct gmtp_hashtable *relay_table = server->relay_hashtable;
+	struct list_head *head;
 	int i, err = 0;
-	struct gmtp_relay_entry *nextRelay = NULL;
-	struct gmtp_relay_entry *prevRelay = NULL;
 
 	gmtp_pr_func();
 
-	for(i = route->nrelays - 1; (i >= 0) && (!err); --i) {
-		struct gmtp_relay_entry *entry;
-		
-		entry = rtable->hash_ops.lookup(rtable,
-				route->relay_list[i].relay_id);
-
-		if(entry == NULL) {
-			entry = gmtp_build_relay_entry(&route->relay_list[i]);
-			if(entry == NULL)
-				return 1;
-		}
+	for(i = 0; i < route_hdr->nrelays; ++i) {
+		struct gmtp_relay_entry *relay;
+		relay = gmtp_build_relay_entry(&route_hdr->relay_list[i]);
+		if(relay == NULL)
+			return 1;
 
-		entry->nextRelay = nextRelay;
-		if(entry->nextRelay != NULL) {
-			INIT_LIST_HEAD(&entry->nextRelay->prevRelayList->list);
-			list_add_tail(&entry->nextRelay->prevRelayList->list,
-					&entry->list);
+		if(i == 0) {
+			INIT_LIST_HEAD(&relay->list);
+			head = &relay->list;
 		}
-		nextRelay = entry;
+		list_add_tail(&relay->list, head);
 
-		err = rtable->hash_ops.add_entry(rtable,
-				(struct gmtp_hash_entry*)entry);
+		err = relay_table->hash_ops.add_entry(relay_table,
+				(struct gmtp_hash_entry*) relay);
 
-		print_gmtp_relay(&entry->relay);
-		pr_info("entry->nextRelay: %p\n", entry->nextRelay);
-		pr_info("entry->prevRelayList: %p\n", entry->nextRelay);
+		print_gmtp_relay(&relay->relay);
 	}
 
 	return err;
@@ -85,27 +73,26 @@ int gmtp_add_relay_entries(struct gmtp_hashtable *rtable,
 int gmtp_add_server_entry(struct gmtp_hashtable *table, const __u8 *flowname,
 		struct gmtp_hdr_route *route)
 {
-	struct gmtp_server_entry *entry;
+	struct gmtp_server_entry *server;
 
 	gmtp_pr_func();
 
-	entry = table->hash_ops.lookup(table, flowname);
-
-	if(entry == NULL) {
+	server = (struct gmtp_server_entry*) table->hash_ops.lookup(table, flowname);
 
-		entry = kmalloc(sizeof(struct gmtp_server_entry), GFP_KERNEL);
-		if(entry == NULL)
+	if(server == NULL) {
+		server = kmalloc(sizeof(struct gmtp_server_entry), GFP_KERNEL);
+		if(server == NULL)
 			return 1;
 
-		memcpy(entry->entry.key, flowname, GMTP_HASH_KEY_LEN);
-		entry->relay_hashtable = gmtp_build_hashtable(U8_MAX,
+		memcpy(server->entry.key, flowname, GMTP_HASH_KEY_LEN);
+		server->relay_hashtable = gmtp_build_hashtable(U8_MAX,
 				gmtp_relay_hash_ops);
 	}
 
-	if(gmtp_add_relay_entries(entry->relay_hashtable, route))
+	if(gmtp_add_route(server, route))
 		return 1;
 
-	return table->hash_ops.add_entry(table, (struct gmtp_hash_entry*)entry);
+	return table->hash_ops.add_entry(table, (struct gmtp_hash_entry*)server);
 }
 EXPORT_SYMBOL_GPL(gmtp_add_server_entry);
 
diff --git a/net-next-sim/net/gmtp/input.c b/net-next-sim/net/gmtp/input.c
index 5cca0a6..63ea30b 100644
--- a/net-next-sim/net/gmtp/input.c
+++ b/net-next-sim/net/gmtp/input.c
@@ -121,6 +121,7 @@ struct sock* gmtp_multicast_connect(struct sock *sk, enum gmtp_sock_type type,
 {
 	struct sock *newsk;
 	struct ip_mreqn mreq;
+	int ret;
 
 	gmtp_pr_func();
 
@@ -136,15 +137,15 @@ struct sock* gmtp_multicast_connect(struct sock *sk, enum gmtp_sock_type type,
 
 	mreq.imr_multiaddr.s_addr = addr;
 	mreq.imr_address.s_addr = htonl(INADDR_ANY);
-	/* FIXME Interface index must be filled ? */
-	mreq.imr_ifindex = 0;
+	/* NS-3 sim0 interface is 7 */
+	mreq.imr_ifindex = 7;
 
 	gmtp_pr_debug("Joining the multicast group in %pI4@%-5d",
 			&addr, ntohs(port));
-
 	rtnl_lock();
-	ip_mc_join_group(newsk, &mreq);
+	ret = ip_mc_join_group(newsk, &mreq);
 	rtnl_unlock();
+	pr_info("ip_mc_join_group returned %d\n", ret);
 
 	__inet_hash_nolisten(newsk, NULL);
 
diff --git a/net-next-sim/net/gmtp/ipv4.c b/net-next-sim/net/gmtp/ipv4.c
index d36116f..7d62503 100644
--- a/net-next-sim/net/gmtp/ipv4.c
+++ b/net-next-sim/net/gmtp/ipv4.c
@@ -1,10 +1,8 @@
 #include <linux/init.h>
 #include <linux/module.h>
-
 #include <linux/err.h>
 #include <linux/errno.h>
 #include <linux/types.h>
-
 #include <net/inet_hashtables.h>
 #include <net/inet_common.h>
 #include <net/inet_connection_sock.h>
@@ -15,17 +13,20 @@
 #include <net/sock.h>
 #include <net/xfrm.h>
 #include <net/secure_seq.h>
+#include <linux/netfilter.h>
+#include <linux/netfilter_ipv4.h>
 
 #include <uapi/linux/gmtp.h>
 #include <linux/gmtp.h>
 #include "gmtp.h"
 
+static struct nf_hook_ops nfho_gmtp_out;
+
 extern int sysctl_ip_nonlocal_bind __read_mostly;
 extern struct inet_timewait_death_row gmtp_death_row;
 
 static inline __u32 gmtp_v4_init_sequence(const struct sk_buff *skb)
 {
-	gmtp_print_function();
 	return secure_gmtp_sequence_number(ip_hdr(skb)->daddr,
 			ip_hdr(skb)->saddr, gmtp_hdr(skb)->sport,
 			gmtp_hdr(skb)->dport);
@@ -51,7 +52,6 @@ struct sock* gmtp_v4_build_control_sk(struct sock *sk)
 
 int gmtp_v4_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)
 {
-
 	const struct sockaddr_in *usin = (struct sockaddr_in *)uaddr;
 	struct inet_sock *inet = inet_sk(sk);
 	struct gmtp_sock *gp = gmtp_sk(sk);
@@ -103,7 +103,6 @@ int gmtp_v4_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)
 	if(inet->inet_saddr == 0)
 		inet->inet_saddr = fl4->saddr;
 	inet->inet_rcv_saddr = inet->inet_saddr;
-
 	inet->inet_dport = usin->sin_port;
 	inet->inet_daddr = daddr;
 
@@ -177,6 +176,7 @@ void gmtp_v4_err(struct sk_buff *skb, u32 info)
 	const struct gmtp_hdr *gh = (struct gmtp_hdr *)(skb->data + offset);
 	struct gmtp_sock *gp;
 	struct inet_sock *inet;
+	struct inet_connection_sock *icsk;
 	const int type = icmp_hdr(skb)->type;
 	const int code = icmp_hdr(skb)->code;
 	struct sock *sk;
@@ -186,7 +186,7 @@ void gmtp_v4_err(struct sk_buff *skb, u32 info)
 
 	struct request_sock *req, **prev;
 
-	gmtp_print_function();
+	gmtp_pr_debug("ICMP: Type: %d, Code: %d", type, code);
 
 	if(skb->len < offset + sizeof(*gh)) {
 		ICMP_INC_STATS_BH(net, ICMP_MIB_INERRORS);
@@ -252,8 +252,11 @@ void gmtp_v4_err(struct sk_buff *skb, u32 info)
 		goto out;
 	}
 
+	icsk = inet_csk(sk);
 	switch(sk->sk_state) {
 	case GMTP_REQUESTING:
+		if(err == EHOSTUNREACH && icsk->icsk_retransmits <= 3)
+			goto out;
 	case GMTP_REQUEST_RECV:
 		if(!sock_owned_by_user(sk)) {
 			sk->sk_err = err;
@@ -835,7 +838,7 @@ static int gmtp_v4_rcv(struct sk_buff *skb)
 	 *
 	 * Only accept multicast packets from relays
 	 */
-	if(skb->pkt_type == PACKET_MULTICAST && gh->relay == 1) {
+	if(skb->pkt_type == PACKET_MULTICAST) {
 
 		struct gmtp_client *tmp;
 		struct gmtp_client_entry *media_entry = gmtp_lookup_client(
@@ -946,8 +949,10 @@ int gmtp_v4_conn_request(struct sock *sk, struct sk_buff *skb)
 		goto drop_and_free;
 
 	ireq = inet_rsk(req);
-	ireq->ir_loc_addr = ip_hdr(skb)->daddr;
-	ireq->ir_rmt_addr = ip_hdr(skb)->saddr;
+	sk_rcv_saddr_set(req_to_sk(req), ip_hdr(skb)->daddr);
+	sk_daddr_set(req_to_sk(req), ip_hdr(skb)->saddr);
+	ireq->ireq_family = AF_INET;
+	ireq->ir_iif = sk->sk_bound_dev_if;
 
 	/*
 	 * Step 3: Process LISTEN state
@@ -965,7 +970,6 @@ int gmtp_v4_conn_request(struct sock *sk, struct sk_buff *skb)
 	if(gmtp_v4_send_register_reply(sk, req))
 		goto drop_and_free;
 
-	gmtp_print_debug("Calling gmtp_csk_reqsk_queue_hash_add(...)");
 	inet_csk_reqsk_queue_hash_add(sk, req, GMTP_TIMEOUT_INIT);
 
 	return 0;
@@ -1209,6 +1213,32 @@ static struct pernet_operations gmtp_v4_ops = {
 		.exit = gmtp_v4_exit_net,
 };
 
+static unsigned int hook_func_gmtp_out(unsigned int hooknum, struct sk_buff *skb,
+		const struct net_device *in, const struct net_device *out,
+		int (*okfn)(struct sk_buff *))
+{
+	struct iphdr *iph = ip_hdr(skb);
+
+	if(iph->protocol == IPPROTO_GMTP) {
+
+		struct gmtp_hdr *gh = gmtp_hdr(skb);
+		int new_ttl = 1;
+
+		switch(gh->type) {
+		case GMTP_PKT_REQUEST:
+			if(GMTP_SKB_CB(skb)->retransmits <= 3) {
+				gmtp_pr_info("Changing TTL to %d\n", new_ttl);
+				iph->ttl = new_ttl;
+				ip_send_check(iph);
+			} else
+				pr_info("Keeping default TTL (%d)\n", iph->ttl);
+		}
+
+	}
+
+	return NF_ACCEPT;
+}
+
 /*************************************************************/
 static int __init gmtp_v4_init(void)
 {
@@ -1232,6 +1262,12 @@ static int __init gmtp_v4_init(void)
 	if(err)
 		goto out_destroy_ctl_sock;
 
+	nfho_gmtp_out.hook = hook_func_gmtp_out;
+	nfho_gmtp_out.hooknum = NF_INET_LOCAL_OUT;
+	nfho_gmtp_out.pf = PF_INET;
+	nfho_gmtp_out.priority = NF_IP_PRI_FIRST;
+	nf_register_hook(&nfho_gmtp_out);
+
 	return err;
 
 out_destroy_ctl_sock:
@@ -1251,6 +1287,7 @@ static void __exit gmtp_v4_exit(void)
 
 	gmtp_print_function();
 
+	nf_unregister_hook(&nfho_gmtp_out);
 	unregister_pernet_subsys(&gmtp_v4_ops);
 	inet_unregister_protosw(&gmtp_protosw);
 	inet_del_protocol(&gmtp_protocol, IPPROTO_GMTP);
diff --git a/net-next-sim/net/gmtp/output.c b/net-next-sim/net/gmtp/output.c
index 6b1621c..36ccea0 100644
--- a/net-next-sim/net/gmtp/output.c
+++ b/net-next-sim/net/gmtp/output.c
@@ -22,7 +22,6 @@ static inline void gmtp_event_ack_sent(struct sock *sk)
 
 /* enqueue @skb on sk_send_head for retransmission, return clone to send now */
 static struct sk_buff *gmtp_skb_entail(struct sock *sk, struct sk_buff *skb) {
-	gmtp_print_function();
 	skb_set_owner_w(skb, sk);
 	WARN_ON(sk->sk_send_head);
 	sk->sk_send_head = skb;
@@ -56,6 +55,7 @@ static int gmtp_transmit_skb(struct sock *sk, struct sk_buff *skb) {
 			break;
 		case GMTP_PKT_REQUEST:
 			set_ack = 0;
+			GMTP_SKB_CB(skb)->retransmits = icsk->icsk_retransmits;
 			/* Use ISS on the first (non-retransmitted) Request. */
 			if (icsk->icsk_retransmits == 0)
 				gcb->seq = gp->iss;
@@ -85,24 +85,9 @@ static int gmtp_transmit_skb(struct sock *sk, struct sk_buff *skb) {
 		memcpy(gh->flowname, gp->flowname, GMTP_FLOWNAME_LEN);
 
 		gh->transm_r = (__be32) gp->tx_max_rate;
-		if (gcb->type == GMTP_PKT_FEEDBACK) {
-			struct gmtp_hdr_feedback *fh = gmtp_hdr_feedback(skb);
-			gh->transm_r = gp->rx_max_rate;
-			fh->pkt_tstamp = gcb->server_tstamp;
-			fh->nclients = gp->myself->nclients;
-
-			pr_info("[Feedback] pkt_tstamp=%u, nclients=%u\n",
-					fh->pkt_tstamp, fh->nclients);
-		}
-
 		if (gcb->type == GMTP_PKT_RESET)
 			gmtp_hdr_reset(skb)->reset_code = gcb->reset_code;
 
-		if(gcb->type == GMTP_PKT_DATA) {
-			struct gmtp_hdr_data *gh_data = gmtp_hdr_data(skb);
-			gh_data->tstamp = jiffies_to_msecs(jiffies);
-		}
-
 		gcb->seq = ++gp->gss;
 		if (set_ack) {
 			gcb->seq = --gp->gss;
@@ -110,6 +95,20 @@ static int gmtp_transmit_skb(struct sock *sk, struct sk_buff *skb) {
 		}
 		gh->seq = gcb->seq;
 
+		if(gcb->type == GMTP_PKT_DATA) {
+			struct gmtp_hdr_data *gh_data = gmtp_hdr_data(skb);
+			gh_data->tstamp = jiffies_to_msecs(jiffies);
+		}
+		if(gcb->type == GMTP_PKT_FEEDBACK) {
+			struct gmtp_hdr_feedback *fh = gmtp_hdr_feedback(skb);
+			gh->transm_r = gp->rx_max_rate;
+			fh->pkt_tstamp = gcb->server_tstamp;
+			fh->nclients = gp->myself->nclients;
+
+			pr_info("[Feedback] pkt_tstamp=%u, nclients=%u, seq: %u\n",
+					fh->pkt_tstamp, fh->nclients, gh->seq);
+		}
+
 		err = icsk->icsk_af_ops->queue_xmit(sk, skb, &inet->cork.fl);
 		return net_xmit_eval(err);
 	}
@@ -122,8 +121,6 @@ unsigned int gmtp_sync_mss(struct sock *sk, u32 pmtu)
 	struct gmtp_sock *gp = gmtp_sk(sk);
 	u32 cur_mps = pmtu;
 
-	gmtp_print_function();
-
 	/* Account for header lengths and IPv4/v6 option overhead */
 	/* FIXME Account variable part of GMTP Header */
 	cur_mps -= (icsk->icsk_af_ops->net_header_len + icsk->icsk_ext_hdr_len +
@@ -133,8 +130,6 @@ unsigned int gmtp_sync_mss(struct sock *sk, u32 pmtu)
 	icsk->icsk_pmtu_cookie = pmtu;
 	gp->mss = cur_mps;
 
-	gmtp_print_debug("mss: %u", gp->mss);
-
 	return cur_mps;
 }
 EXPORT_SYMBOL_GPL(gmtp_sync_mss);
@@ -568,11 +563,11 @@ static long gmtp_wait_for_delay(struct sock *sk, unsigned long delay)
 {
 	DEFINE_WAIT(wait);
 	long remaining;
+	gmtp_pr_func();
+	prepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE);
 
-	prepare_to_wait(sk_sleep(sk), &wait, TASK_UNINTERRUPTIBLE);
 	sk->sk_write_pending++;
 	release_sock(sk);
-
 	remaining = schedule_timeout(delay);
 
 	lock_sock(sk);
@@ -581,19 +576,20 @@ static long gmtp_wait_for_delay(struct sock *sk, unsigned long delay)
 
 	if (signal_pending(current) || sk->sk_err)
 		return -1;
+
 	return remaining;
 }
 
 static inline unsigned int packet_len(struct sk_buff *skb)
 {
 	/* Total = Data + (GMTP + IP + MAC) */
-	return skb->len + (gmtp_hdr_len(skb) + 20 + ETH_HLEN);
+	return skb->len + (gmtp_data_hdr_len() + 20 + ETH_HLEN);
 }
 
 static inline unsigned int payload_len(struct sk_buff *skb)
 {
 	/* Data = Total - (GMTP + IP + MAC) */
-	return skb->len - (gmtp_hdr_len(skb) + 20 + ETH_HLEN);
+	return skb->len - (gmtp_data_hdr_len() + 20 + ETH_HLEN);
 }
 
 /*static inline void packet_sent(struct gmtp_sock *gp, int data_len)*/
@@ -603,7 +599,7 @@ static inline void packet_sent(struct sock *sk, struct sk_buff *skb)
 	unsigned long elapsed = 0;
 	int data_len = payload_len(skb);
 
-	if(gp->tx_dpkts_sent == 0)
+	if(unlikely(gp->tx_dpkts_sent == 0))
 		gmtp_pr_info("Start sending data packets...\n\n");
 
 	++gp->tx_dpkts_sent;
@@ -611,7 +607,7 @@ static inline void packet_sent(struct sock *sk, struct sk_buff *skb)
 	gp->tx_bytes_sent += skb->len;
 
 	gp->tx_last_stamp = jiffies;
-	if(gp->tx_first_stamp == 0) { /* This is the first sent */
+	if(unlikely(gp->tx_first_stamp == 0)) { /* This is the first sent */
 		gp->tx_first_stamp = gp->tx_last_stamp;
 		gp->tx_time_sample = jiffies;
 		gp->tx_byte_sample = gp->tx_bytes_sent;
@@ -642,14 +638,29 @@ static void gmtp_xmit_packet(struct sock *sk, struct sk_buff *skb) {
 
 	GMTP_SKB_CB(skb)->type = GMTP_PKT_DATA;
 
+/*	if(gmtp_sk(sk)->gss == 550980189) {
+		pr_info("Jumping packet with seq = %d\n", 550980189 + 1);
+		gmtp_sk(sk)->gss++;
+		return;
+	}*/
 	err = gmtp_transmit_skb(sk, skb);
-	if (err)
-		gmtp_pr_error("transmit_skb() returned err=%d\n", err);
 
 	/*
 	 * Register this one as sent (even if an error occurred).
+	 * To the remote end a local packet drop is indistinguishable from
+	 * network loss.
 	 */
 	packet_sent(sk, skb);
+
+	if (unlikely(err)) {
+		gmtp_pr_error("transmit_skb() returned err=%d\n", err);
+
+		print_gmtp_packet(ip_hdr(skb), gmtp_hdr(skb));
+
+		pr_info("ISS: %u, GSS: %u, N: %u\n", gmtp_sk(sk)->iss,
+				gmtp_sk(sk)->gss,
+				(gmtp_sk(sk)->gss - gmtp_sk(sk)->iss));
+	}
 }
 
 /**
@@ -688,24 +699,26 @@ void gmtp_write_xmit(struct sock *sk, struct sk_buff *skb)
 	long delay = 0, delay2 = 0, delay_budget = 0;
 	int len;
 
+	struct gmtp_packet_info *pkt_info = kmalloc(
+			sizeof(struct gmtp_packet_info), GFP_KERNEL);
+	pkt_info->sk = sk;
+	pkt_info->skb = skb;
+
 	/** TODO Continue tests with different scales... */
 	static const int scale = 1;
 	/*static const int scale = HZ/100;*/
 
-	if(unlikely(sk == NULL || skb == NULL))
+	if(unlikely(skb == NULL))
 		return;
-
-	len = packet_len(skb);
-
-	if(gp->tx_max_rate == 0UL)
+	else if(gp->tx_max_rate == 0UL)
 		goto send;
-	/*
-	pr_info("[%d] Tx rate: %lu bytes/s\n", gp->pkt_sent, gp->total_rate);
-	pr_info("[-] Tx rate (sample): %lu bytes/s\n", gp->sample_rate);
-	*/
+
+	/*pr_info("[%d] Tx rate: %lu bytes/s\n", gp->tx_dpkts_sent, gp->tx_total_rate);
+	pr_info("[-] Tx rate (sample): %lu bytes/s\n", gp->tx_sample_rate);*/
 
 	elapsed = jiffies - gp->tx_last_stamp; /* time elapsed since last sent */
 
+	len = packet_len(skb);
 	if(gp->tx_byte_budget >= mult_frac(len, 3, 4)) {
 		goto send;
 	} else if(gp->tx_byte_budget != INT_MIN) {
@@ -721,8 +734,7 @@ void gmtp_write_xmit(struct sock *sk, struct sk_buff *skb)
 
 wait:
 	delay2 += delay_budget;
-	if(delay2 > 0)
-		gmtp_wait_for_delay(sk, delay2);
+	/*pr_info("delay2 += delay_budget ==> %ld ms\n", delay2);*/
 
 	/*
 	 * TODO More tests with byte_budgets...
@@ -733,8 +745,18 @@ wait:
 	else
 		gp->tx_byte_budget = INT_MIN;
 
+	if(delay2 > 0) {
+		setup_timer(&gp->xmit_timer, gmtp_write_xmit_timer,
+				(unsigned long ) pkt_info);
+		mod_timer(&gp->xmit_timer, jiffies + delay2);
+		/* Never use gmtp_wait_for_delay(sk, delay2); in NS-3/dce*/
+		schedule_timeout(delay2);
+		return;
+	}
+
 send:
 	gmtp_xmit_packet(sk, skb);
+
 }
 EXPORT_SYMBOL_GPL(gmtp_write_xmit);
 
diff --git a/net-next-sim/net/gmtp/proto.c b/net-next-sim/net/gmtp/proto.c
index db39a2e..cba0518 100644
--- a/net-next-sim/net/gmtp/proto.c
+++ b/net-next-sim/net/gmtp/proto.c
@@ -23,7 +23,7 @@ EXPORT_SYMBOL_GPL(gmtp_inet_hashinfo);
 struct gmtp_info* gmtp_info;
 EXPORT_SYMBOL_GPL(gmtp_info);
 
-const char *gmtp_packet_name(const int type)
+const char *gmtp_packet_name(const __u8 type)
 {
 	static const char *const gmtp_packet_names[] = {
 		[GMTP_PKT_REQUEST]  = "REQUEST",
@@ -109,7 +109,7 @@ void print_gmtp_packet(const struct iphdr *iph, const struct gmtp_hdr *gh)
 {
 	__u8 flowname[GMTP_FLOWNAME_STR_LEN];
 	flowname_str(flowname, gh->flowname);
-	pr_info("%s (%d) src=%pI4@%-5d, dst=%pI4@%-5d, seq=%u, rtt=%u ms, "
+	pr_info("%s (%u) src=%pI4@%-5d, dst=%pI4@%-5d, seq=%u, rtt=%u ms, "
 			"transm_r=%u bytes/s, flow=%s\n",
 				gmtp_packet_name(gh->type), gh->type,
 				&iph->saddr, ntohs(gh->sport),
@@ -315,7 +315,7 @@ void gmtp_close(struct sock *sk, long timeout)
 
 	gmtp_pr_func();
 
-	pr_info("state: %s, timeout: %ld", gmtp_state_name(sk->sk_state), timeout);
+	pr_info("state: %s, timeout: %ld\n", gmtp_state_name(sk->sk_state), timeout);
 
 	lock_sock(sk);
 
@@ -650,9 +650,25 @@ out:
 
 EXPORT_SYMBOL_GPL(gmtp_recvmsg);
 
+struct sendmsg_data {
+	struct sock *sk;
+	struct sk_buff *skb;
+	struct timer_list *sendmsg_timer;
+};
+
+static void gmtp_sendmsg_callback(unsigned long data)
+{
+	struct sendmsg_data *sd = (struct sendmsg_data*) data;
+	if(!timer_pending(&gmtp_sk(sd->sk)->xmit_timer)) {
+		gmtp_write_xmit(sd->sk, sd->skb);
+		del_timer(sd->sendmsg_timer);
+	} else
+		mod_timer(sd->sendmsg_timer, jiffies + 1);
+}
+
 int gmtp_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)
 {
-	const struct gmtp_sock *gp = gmtp_sk(sk);
+	struct gmtp_sock *gp = gmtp_sk(sk);
 	const int flags = msg->msg_flags;
 	const int noblock = flags & MSG_DONTWAIT;
 	struct sk_buff *skb;
@@ -664,6 +680,7 @@ int gmtp_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)
 
 	lock_sock(sk);
 
+	/* FIXME Check if sk queue is full */
 	timeo = sock_sndtimeo(sk, noblock);
 
 	/*
@@ -677,9 +694,7 @@ int gmtp_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)
 
 	size = sk->sk_prot->max_header + len;
 	release_sock(sk);
-
 	skb = sock_alloc_send_skb(sk, size, noblock, &rc);
-
 	lock_sock(sk);
 	if (skb == NULL)
 		goto out_release;
@@ -689,13 +704,30 @@ int gmtp_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)
 	if (rc != 0)
 		goto out_discard;
 
+	/** FIXME Enqueue packets when time is pending... */
+
 	/**
-	 * FIXME Use a timer to rate-based congestion control protocols.
+	 * Use a timer to rate-based congestion control protocols.
 	 * The timer will expire when congestion control permits to release
-	 * further packets into the network
+	 * further packets into the network.
+	 *
+	 * Here, a while(timer_pending(...)) does not work for ns-3/dce
+	 * So, we use a timer...
 	 */
-	/*if (!timer_pending(&gp->xmit_timer))*/
-	gmtp_write_xmit(sk, skb);
+	if(!timer_pending(&gp->xmit_timer)) {
+		gmtp_write_xmit(sk, skb);
+	} else {
+		struct timer_list *sendmsg_timer = kmalloc(
+				sizeof(struct timer_list), GFP_KERNEL);
+		struct sendmsg_data *sd = kmalloc(sizeof(struct sendmsg_data),
+				GFP_KERNEL);
+		sd->sk = sk;
+		sd->skb = skb;
+		sd->sendmsg_timer = sendmsg_timer;
+		setup_timer(sd->sendmsg_timer, gmtp_sendmsg_callback,
+				(unsigned long ) sd);
+		mod_timer(sd->sendmsg_timer, jiffies + 1);
+	}
 
 out_release:
 	release_sock(sk);
@@ -901,6 +933,7 @@ static int __init gmtp_init(void)
 		goto out;
 	}
 	gmtp_info->relay_enabled = 0;
+	gmtp_info->pkt_sent = 0;
 	gmtp_info->control_sk = NULL;
 	gmtp_info->ctrl_addr = NULL;
 
diff --git a/net-next-sim/net/gmtp/sockopt.c b/net-next-sim/net/gmtp/sockopt.c
index e1ba1bb..9e78df7 100644
--- a/net-next-sim/net/gmtp/sockopt.c
+++ b/net-next-sim/net/gmtp/sockopt.c
@@ -32,21 +32,25 @@ static int do_gmtp_setsockopt(struct sock *sk, int level, int optname,
 	lock_sock(sk);
 	switch(optname) {
 	case GMTP_SOCKOPT_FLOWNAME:
+		gmtp_pr_debug("GMTP_SOCKOPT_FLOWNAME");
 		err = gmtp_setsockopt_flowname(gp, optval, optlen);
 		break;
 	case GMTP_SOCKOPT_MAX_TX_RATE:
+		gmtp_pr_debug("GMTP_SOCKOPT_MAX_TX_RATE");
 		if(val > 0)
 			gp->tx_max_rate = (unsigned long)val;
 		else
 			err = -EINVAL;
 		break;
 	case GMTP_SOCKOPT_SERVER_TIMEWAIT:
+		gmtp_pr_debug("GMTP_SOCKOPT_SERVER_TIMEWAIT");
 		if(gp->role != GMTP_ROLE_SERVER)
 			err = -EOPNOTSUPP;
 		else
 			gp->server_timewait = (val != 0)? 1 : 0;
 		break;
 	case GMTP_SOCKOPT_ROLE_RELAY:
+		gmtp_pr_debug("GMTP_SOCKOPT_ROLE_RELAY");
 		if(val != 0 && gp->role == GMTP_ROLE_UNDEFINED)
 			gp->role = GMTP_ROLE_RELAY;
 		else if(val == 0 && gp->role == GMTP_ROLE_RELAY)
@@ -55,6 +59,7 @@ static int do_gmtp_setsockopt(struct sock *sk, int level, int optname,
 			err = -EOPNOTSUPP;
 		break;
 	case GMTP_SOCKOPT_RELAY_ENABLED:
+		gmtp_pr_debug("GMTP_SOCKOPT_RELAY_ENABLED");
 		if(gp->role != GMTP_ROLE_RELAY)
 			err = -EOPNOTSUPP;
 		else
diff --git a/net-next-sim/net/gmtp/timer.c b/net-next-sim/net/gmtp/timer.c
index 42a7286..0f09997 100644
--- a/net-next-sim/net/gmtp/timer.c
+++ b/net-next-sim/net/gmtp/timer.c
@@ -36,35 +36,14 @@ static int gmtp_write_timeout(struct sock *sk)
 			dst_negative_advice(sk);
 		retry_until = icsk->icsk_syn_retries ?
 			    : TCP_SYN_RETRIES;
+
 	} else {
 		if (icsk->icsk_retransmits >= TCP_RETR1) {
-		/* NOTE. draft-ietf-tcpimpl-pmtud-01.txt requires pmtu
-		   black hole detection. :-(
-
-		   It is place to make it. It is not made. I do not want
-		   to make it. It is disguisting. It does not work in any
-		   case. Let me to cite the same draft, which requires for
-		   us to implement this:
-
-   "The one security concern raised by this memo is that ICMP black holes
-   are often caused by over-zealous security administrators who block
-   all ICMP messages.  It is vitally important that those who design and
-   deploy security systems understand the impact of strict filtering on
-   upper-layer protocols.  The safest web site in the world is worthless
-   if most TCP implementations cannot transfer data from it.  It would
-   be far nicer to have all of the black holes fixed rather than fixing
-   all of the TCP implementations."
-
-			   Golden words :-).
-		   */
 
 			dst_negative_advice(sk);
 		}
 
 		retry_until = TCP_RETR2;
-		/*
-		 * FIXME: see tcp_write_timout and tcp_out_of_resources
-		 */
 	}
 
 	if (icsk->icsk_retransmits >= retry_until) {
@@ -90,13 +69,6 @@ static void gmtp_retransmit_timer(struct sock *sk)
 	if (gmtp_write_timeout(sk))
 		return;
 
-	/*
-	 * We want to know the number of packets retransmitted, not the
-	 * total number of retransmissions of clones of original packets.
-	 */
-	if (icsk->icsk_retransmits == 0)
-		/* TODO Register some statistics */;
-
 	if (gmtp_retransmit_skb(sk) != 0) {
 		/*
 		 * Retransmission failed because of local congestion,
@@ -232,7 +204,6 @@ static void gmtp_keepalive_timer(unsigned long data)
 
 	gmtp_pr_func();
 
-	pr_info("Locking socket (%p) \n", sk);
 	print_gmtp_sock(sk);
 
 	bh_lock_sock(sk);
@@ -327,11 +298,22 @@ out:
 	sock_put(sk);
 }
 
+void gmtp_write_xmit_timer(unsigned long data)
+{
+	struct gmtp_packet_info *pkt_info = (struct gmtp_packet_info*) data;
+	gmtp_write_xmit(pkt_info->sk, pkt_info->skb);
+	del_timer_sync(&gmtp_sk(pkt_info->sk)->xmit_timer);
+	kfree(pkt_info);
+}
+EXPORT_SYMBOL_GPL(gmtp_write_xmit_timer);
+
 void gmtp_init_xmit_timers(struct sock *sk)
 {
+	struct gmtp_sock *gp = gmtp_sk(sk);
 	gmtp_pr_func();
+
 	inet_csk_init_xmit_timers(sk, &gmtp_write_timer, &gmtp_delack_timer,
-			&gmtp_keepalive_timer);
+				&gmtp_keepalive_timer);
 }
 
 
