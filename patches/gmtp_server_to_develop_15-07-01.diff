diff --git a/linux-4.0.3/net/gmtp/Makefile b/linux-4.0.3/net/gmtp/Makefile
index 7f2229d..a4d1132 100755
--- a/linux-4.0.3/net/gmtp/Makefile
+++ b/linux-4.0.3/net/gmtp/Makefile
@@ -6,7 +6,8 @@ KBUILD_EXTRA_SYMBOLS := $(PWD)/Module.symvers
 #obj-$(CONFIG_GMTP) += gmtp.o gmtp_ipv4.o
 obj-m += gmtp.o gmtp_ipv4.o
 
-gmtp-y += hash.o input.o minisocks.o output.o sockopt.o proto.o timer.o
+gmtp-y += hash/hash.o hash/hash_client.o hash/hash_server.o
+gmtp-y += input.o minisocks.o output.o sockopt.o proto.o timer.o
 gmtp-y +=  mcc/mcc_proto.o mcc/mcc_input.o mcc/mcc_equation.o mcc/packet_history.o mcc/loss_interval.o 
 gmtp_ipv4-y := ipv4.o
 
diff --git a/linux-4.0.3/net/gmtp/gmtp-inter/build.c b/linux-4.0.3/net/gmtp/gmtp-inter/build.c
index 9cceeef..f958ea9 100644
--- a/linux-4.0.3/net/gmtp/gmtp-inter/build.c
+++ b/linux-4.0.3/net/gmtp/gmtp-inter/build.c
@@ -65,7 +65,7 @@ struct gmtp_hdr *gmtp_inter_make_route_hdr(struct sk_buff *skb)
 }
 
 struct gmtp_hdr *gmtp_inter_make_request_notify_hdr(struct sk_buff *skb,
-		struct gmtp_relay_entry *entry, __be16 new_sport,
+		struct gmtp_inter_entry *entry, __be16 new_sport,
 		__be16 new_dport, struct gmtp_client *my_reporter,
 		__u8 max_nclients, __u8 code)
 {
@@ -129,7 +129,7 @@ int gmtp_inter_make_request_notify(struct sk_buff *skb, __be32 new_saddr,
 
 	struct gmtp_hdr *gh = gmtp_hdr(skb);
 	struct iphdr *iph = ip_hdr(skb);
-	struct gmtp_relay_entry *entry;
+	struct gmtp_inter_entry *entry;
 	unsigned int skb_len = skb->len;
 	struct gmtp_hdr *new_gh;
 	int gmtp_hdr_len = sizeof(struct gmtp_hdr)
diff --git a/linux-4.0.3/net/gmtp/gmtp-inter/gmtp-inter.h b/linux-4.0.3/net/gmtp/gmtp-inter/gmtp-inter.h
index a11bd9b..53650fb 100644
--- a/linux-4.0.3/net/gmtp/gmtp-inter/gmtp-inter.h
+++ b/linux-4.0.3/net/gmtp/gmtp-inter/gmtp-inter.h
@@ -102,7 +102,7 @@ void gmtp_inter_add_relayid(struct sk_buff *skb);
 struct gmtp_hdr *gmtp_inter_make_route_hdr(struct sk_buff *skb);
 
 struct gmtp_hdr *gmtp_inter_make_request_notify_hdr(struct sk_buff *skb,
-		struct gmtp_relay_entry *media_info, __be16 new_sport,
+		struct gmtp_inter_entry *media_info, __be16 new_sport,
 		__be16 new_dport, struct gmtp_client *reporter,
 		__u8 max_nclients, __u8 error_code);
 
diff --git a/linux-4.0.3/net/gmtp/gmtp-inter/hash-inter.c b/linux-4.0.3/net/gmtp/gmtp-inter/hash-inter.c
index 49ea46a..3c0a05c 100644
--- a/linux-4.0.3/net/gmtp/gmtp-inter/hash-inter.c
+++ b/linux-4.0.3/net/gmtp/gmtp-inter/hash-inter.c
@@ -30,7 +30,7 @@ struct gmtp_inter_hashtable *gmtp_inter_create_hashtable(unsigned int size)
 	if(ht == NULL)
 		return NULL;
 
-	ht->table = kmalloc(sizeof(struct gmtp_relay_entry*) *size, GFP_KERNEL);
+	ht->table = kmalloc(sizeof(struct gmtp_inter_entry*) *size, GFP_KERNEL);
 	if(ht->table == NULL)
 		return NULL;
 
@@ -62,10 +62,10 @@ unsigned int gmtp_inter_hash(struct gmtp_inter_hashtable *hashtable,
 	return hashval % hashtable->size;
 }
 
-struct gmtp_relay_entry *gmtp_inter_lookup_media(
+struct gmtp_inter_entry *gmtp_inter_lookup_media(
 		struct gmtp_inter_hashtable *hashtable, const __u8 *media)
 {
-	struct gmtp_relay_entry *entry;
+	struct gmtp_inter_entry *entry;
 	unsigned int hashval;
 
 	hashval = gmtp_inter_hash(hashtable, media);
@@ -131,8 +131,8 @@ int gmtp_inter_add_entry(struct gmtp_inter_hashtable *hashtable, __u8 *flowname,
 		__be32 server_addr, __be32 *relay, __be16 media_port,
 		__be32 channel_addr, __be16 channel_port)
 {
-	struct gmtp_relay_entry *new_entry;
-	struct gmtp_relay_entry *current_entry;
+	struct gmtp_inter_entry *new_entry;
+	struct gmtp_inter_entry *current_entry;
 	unsigned int hashval;
 
 	gmtp_print_function();
@@ -143,7 +143,7 @@ int gmtp_inter_add_entry(struct gmtp_inter_hashtable *hashtable, __u8 *flowname,
 	if(hashval < 0)
 		return hashval;
 
-	new_entry = kmalloc(sizeof(struct gmtp_relay_entry), GFP_KERNEL);
+	new_entry = kmalloc(sizeof(struct gmtp_inter_entry), GFP_KERNEL);
 	if(new_entry == NULL)
 		return 1;
 
@@ -171,7 +171,7 @@ int gmtp_inter_add_entry(struct gmtp_inter_hashtable *hashtable, __u8 *flowname,
 }
 EXPORT_SYMBOL_GPL(gmtp_inter_add_entry);
 
-void gmtp_inter_del_clients(struct gmtp_relay_entry *entry)
+void gmtp_inter_del_clients(struct gmtp_inter_entry *entry)
 {
 	struct gmtp_flow_info *info = entry->info;
 	struct gmtp_client *client, *temp;
@@ -185,11 +185,11 @@ void gmtp_inter_del_clients(struct gmtp_relay_entry *entry)
 	}
 }
 
-struct gmtp_relay_entry *gmtp_inter_del_entry(
+struct gmtp_inter_entry *gmtp_inter_del_entry(
 		struct gmtp_inter_hashtable *hashtable, __u8 *media)
 {
-	struct gmtp_relay_entry *previous_entry;
-	struct gmtp_relay_entry *current_entry;
+	struct gmtp_inter_entry *previous_entry;
+	struct gmtp_inter_entry *current_entry;
 	int hashval;
 
 	gmtp_print_function();
@@ -232,7 +232,7 @@ struct gmtp_relay_entry *gmtp_inter_del_entry(
 void kfree_gmtp_inter_hashtable(struct gmtp_inter_hashtable *hashtable)
 {
 	int i;
-	struct gmtp_relay_entry *list, *temp;
+	struct gmtp_inter_entry *list, *temp;
 
 	gmtp_print_function();
 
@@ -244,7 +244,7 @@ void kfree_gmtp_inter_hashtable(struct gmtp_inter_hashtable *hashtable)
 		while(list != NULL) {
 			temp = list;
 			list = list->next;
-			kfree(temp);
+			gmtp_inter_del_entry(hashtable, temp->flowname);
 		}
 	}
 
diff --git a/linux-4.0.3/net/gmtp/gmtp-inter/hash-inter.h b/linux-4.0.3/net/gmtp/gmtp-inter/hash-inter.h
index c5c4f4d..0a8bf15 100644
--- a/linux-4.0.3/net/gmtp/gmtp-inter/hash-inter.h
+++ b/linux-4.0.3/net/gmtp/gmtp-inter/hash-inter.h
@@ -8,10 +8,10 @@
 #ifndef HASH_INTER_H_
 #define HASH_INTER_H_
 
-#define GMTP_HASH_SIZE  16
+#define GMTP_HASH_KEY_LEN  16
 
 /**
- * struct gmtp_relay_entry: entry in GMTP-inter Relay Table
+ * struct gmtp_inter_entry: entry in GMTP-inter Relay Table
  *
  * @flowname: Name of dataflow
  * @server_addr: IP address of media server
@@ -22,9 +22,9 @@
  * @state: state of media transmission
  * @info: control information for media transmission
  *
- * @next: pointer to next gmtp_relay_entry
+ * @next: pointer to next gmtp_inter_entry
  */
-struct gmtp_relay_entry {
+struct gmtp_inter_entry {
 	__u8 flowname[GMTP_FLOWNAME_LEN];
 	__be32 server_addr;
 	__be32 *relay;
@@ -34,7 +34,7 @@ struct gmtp_relay_entry {
 	__u8 state :3;
 
 	struct gmtp_flow_info *info;
-	struct gmtp_relay_entry *next;
+	struct gmtp_inter_entry *next;
 };
 
 /**
@@ -116,17 +116,17 @@ enum {
  */
 struct gmtp_inter_hashtable {
 	int size;
-	struct gmtp_relay_entry **table;
+	struct gmtp_inter_entry **table;
 };
 
 /** hash.c */
 struct gmtp_inter_hashtable *gmtp_inter_create_hashtable(unsigned int size);
-struct gmtp_relay_entry *gmtp_inter_lookup_media(
+struct gmtp_inter_entry *gmtp_inter_lookup_media(
 		struct gmtp_inter_hashtable *hashtable, const __u8 *media);
 int gmtp_inter_add_entry(struct gmtp_inter_hashtable *hashtable, __u8 *flowname,
 		__be32 server_addr, __be32 *relay, __be16 media_port,
 		__be32 channel_addr, __be16 channel_port);
-struct gmtp_relay_entry *gmtp_inter_del_entry(
+struct gmtp_inter_entry *gmtp_inter_del_entry(
 		struct gmtp_inter_hashtable *hashtable, __u8 *media);
 
 void kfree_gmtp_inter_hashtable(struct gmtp_inter_hashtable *hashtable);
diff --git a/linux-4.0.3/net/gmtp/gmtp-inter/input-inter.c b/linux-4.0.3/net/gmtp/gmtp-inter/input-inter.c
index e142a94..0238318 100644
--- a/linux-4.0.3/net/gmtp/gmtp-inter/input-inter.c
+++ b/linux-4.0.3/net/gmtp/gmtp-inter/input-inter.c
@@ -53,7 +53,7 @@ int gmtp_inter_request_rcv(struct sk_buff *skb)
 	struct iphdr *iph = ip_hdr(skb);
 	struct gmtp_hdr *gh = gmtp_hdr(skb);
 	struct gmtp_hdr *gh_reqnotify;
-	struct gmtp_relay_entry *entry;
+	struct gmtp_inter_entry *entry;
 
 	__u8 code = GMTP_REQNOTIFY_CODE_ERROR;
 	__u8 max_nclients = 0;
@@ -175,7 +175,7 @@ int gmtp_inter_register_reply_rcv(struct sk_buff *skb)
 	struct gmtp_hdr *gh = gmtp_hdr(skb);
 	struct iphdr *iph = ip_hdr(skb);
 	struct gmtp_hdr *gh_route_n;
-	struct gmtp_relay_entry *entry;
+	struct gmtp_inter_entry *entry;
 	struct gmtp_flow_info *info;
 	struct gmtp_hdr *gh_req_n;
 	struct gmtp_client *client, *temp, *first_client, *cur_reporter = NULL;
@@ -255,7 +255,7 @@ int gmtp_inter_ack_rcv(struct sk_buff *skb)
 {
 	struct gmtp_hdr *gh = gmtp_hdr(skb);
 	struct iphdr *iph = ip_hdr(skb);
-	struct gmtp_relay_entry *entry;
+	struct gmtp_inter_entry *entry;
 	struct gmtp_flow_info *info;
 	struct gmtp_client *reporter;
 
@@ -282,7 +282,7 @@ int gmtp_inter_feedback_rcv(struct sk_buff *skb)
 {
 	struct gmtp_hdr *gh = gmtp_hdr(skb);
 	struct iphdr *iph = ip_hdr(skb);
-	struct gmtp_relay_entry *entry;
+	struct gmtp_inter_entry *entry;
 	struct gmtp_flow_info *info;
 	struct gmtp_client *reporter;
 
@@ -313,7 +313,7 @@ int gmtp_inter_elect_resp_rcv(struct sk_buff *skb)
 {
 	struct iphdr *iph = ip_hdr(skb);
 	struct gmtp_hdr *gh = gmtp_hdr(skb);
-	struct gmtp_relay_entry *entry;
+	struct gmtp_inter_entry *entry;
 
 	gmtp_pr_func();
 
@@ -370,7 +370,7 @@ static inline void gmtp_update_stats(struct gmtp_flow_info *info,
 int gmtp_inter_data_rcv(struct sk_buff *skb)
 {
 	struct gmtp_hdr *gh = gmtp_hdr(skb);
-	struct gmtp_relay_entry *entry;
+	struct gmtp_inter_entry *entry;
 	struct gmtp_flow_info *info;
 
 	entry = gmtp_inter_lookup_media(gmtp_inter.hashtable, gh->flowname);
@@ -401,7 +401,7 @@ int gmtp_inter_close_rcv(struct sk_buff *skb)
 {
 	struct gmtp_hdr *gh = gmtp_hdr(skb);
 	struct iphdr *iph = ip_hdr(skb);
-	struct gmtp_relay_entry *entry;
+	struct gmtp_inter_entry *entry;
 
 	gmtp_pr_func();
 
diff --git a/linux-4.0.3/net/gmtp/gmtp-inter/mcc-inter.h b/linux-4.0.3/net/gmtp/gmtp-inter/mcc-inter.h
index cd149bb..16e874c 100644
--- a/linux-4.0.3/net/gmtp/gmtp-inter/mcc-inter.h
+++ b/linux-4.0.3/net/gmtp/gmtp-inter/mcc-inter.h
@@ -25,7 +25,7 @@ static inline unsigned long gmtp_mcc_interval(unsigned int rtt)
 	return (jiffies + GMTP_ACK_INTERVAL);
 }
 
-static inline int new_reporter(struct gmtp_relay_entry *entry)
+static inline int new_reporter(struct gmtp_inter_entry *entry)
 {
 	return (entry->info->nclients % GMTP_REPORTER_DEFAULT_PROPORTION) == 0 ?
 			gmtp_inter.kreporter : 0;
diff --git a/linux-4.0.3/net/gmtp/gmtp-inter/output-inter.c b/linux-4.0.3/net/gmtp/gmtp-inter/output-inter.c
index 841656c..eca3f30 100644
--- a/linux-4.0.3/net/gmtp/gmtp-inter/output-inter.c
+++ b/linux-4.0.3/net/gmtp/gmtp-inter/output-inter.c
@@ -18,7 +18,7 @@ int gmtp_inter_register_out(struct sk_buff *skb)
 {
 	struct iphdr *iph = ip_hdr(skb);
 	struct gmtp_hdr *gh = gmtp_hdr(skb);
-	struct gmtp_relay_entry *entry;
+	struct gmtp_inter_entry *entry;
 
 	gmtp_pr_func();
 
@@ -66,7 +66,7 @@ int gmtp_inter_data_out(struct sk_buff *skb)
 {
 	struct gmtp_hdr *gh = gmtp_hdr(skb);
 	struct iphdr *iph = ip_hdr(skb);
-	struct gmtp_relay_entry *entry;
+	struct gmtp_inter_entry *entry;
 	struct gmtp_flow_info *info;
 
 	unsigned int server_tx;
@@ -103,7 +103,7 @@ out:
 }
 
 static int gmtp_inter_close_from_client(struct sk_buff *skb,
-		struct gmtp_relay_entry *entry)
+		struct gmtp_inter_entry *entry)
 {
 	struct iphdr *iph = ip_hdr(skb);
 	struct gmtp_hdr *gh = gmtp_hdr(skb);
@@ -183,7 +183,7 @@ int gmtp_inter_close_out(struct sk_buff *skb)
 {
 	struct iphdr *iph = ip_hdr(skb);
 	struct gmtp_hdr *gh = gmtp_hdr(skb);
-	struct gmtp_relay_entry *entry;
+	struct gmtp_inter_entry *entry;
 
 	gmtp_pr_func();
 
diff --git a/linux-4.0.3/net/gmtp/gmtp.h b/linux-4.0.3/net/gmtp/gmtp.h
index 687fa06..cc81016 100644
--- a/linux-4.0.3/net/gmtp/gmtp.h
+++ b/linux-4.0.3/net/gmtp/gmtp.h
@@ -99,7 +99,8 @@
 extern struct gmtp_info *gmtp_info;
 extern struct inet_hashinfo gmtp_inet_hashinfo;
 extern struct percpu_counter gmtp_orphan_count;
-extern struct gmtp_hashtable *gmtp_hashtable;
+extern struct gmtp_hashtable *client_hashtable;
+extern struct gmtp_hashtable *server_hashtable;
 
 void gmtp_init_xmit_timers(struct sock *sk);
 static inline void gmtp_clear_xmit_timers(struct sock *sk)
@@ -136,6 +137,7 @@ const char *gmtp_packet_name(const int);
 const char *gmtp_state_name(const int);
 void flowname_str(__u8* str, const __u8 *flowname);
 void print_gmtp_packet(const struct iphdr *iph, const struct gmtp_hdr *gh);
+void print_gmtp_relay(const struct gmtp_relay *relay);
 void print_route(struct gmtp_hdr_route *route);
 void print_gmtp_sock(struct sock *sk);
 
@@ -200,11 +202,16 @@ struct gmtp_info {
 
 	struct sock		*control_sk;
 	struct sockaddr_in	*ctrl_addr;
-
-
 };
 
-void kfree_gmtp_info(struct gmtp_info *gmtp);
+static inline void kfree_gmtp_info(struct gmtp_info *gmtp_info)
+{
+	if(gmtp_info->control_sk != NULL)
+		kfree(gmtp_info->control_sk);
+	if(gmtp_info->ctrl_addr != NULL)
+		kfree(gmtp_info->ctrl_addr);
+	kfree(gmtp_info);
+}
 
 /**
  * This is the control buffer. It is free to use by any layer.
@@ -281,6 +288,11 @@ static inline struct gmtp_client *gmtp_create_client(__be32 addr, __be16 port,
 		new->max_nclients = max_nclients;
 		new->nclients = 0;
 		new->ack_rx_tstamp = 0;
+
+		new->clients = 0;
+		new->reporter = 0;
+		new->rsock = 0;
+		new->mysock = 0;
 	}
 	return new;
 }
diff --git a/linux-4.0.3/net/gmtp/hash.c b/linux-4.0.3/net/gmtp/hash.c
deleted file mode 100644
index a166807..0000000
--- a/linux-4.0.3/net/gmtp/hash.c
+++ /dev/null
@@ -1,249 +0,0 @@
-/*
- * hash.c
- *
- *  Created on: 27/02/2015
- *      Author: mario
- */
-
-#include <linux/kernel.h>
-#include <linux/slab.h>
-#include <linux/string.h>
-
-#include "hash.h"
-
-struct gmtp_hashtable *gmtp_create_hashtable(unsigned int size)
-{
-	int i;
-	struct gmtp_hashtable *nt;
-
-	gmtp_print_function();
-	gmtp_print_debug("Size of gmtp_hashtable: %d", size);
-
-	if(size < 1)
-		return NULL;
-
-	nt = kmalloc(sizeof(struct gmtp_hashtable), GFP_KERNEL);
-	if(nt == NULL)
-		return NULL;
-
-	nt->client_table = kmalloc(sizeof(struct gmtp_client_entry*) * size,
-			GFP_KERNEL);
-
-	nt->server_table = kmalloc(sizeof(struct gmtp_server_entry*) * size,
-			GFP_KERNEL);
-
-	if((nt->client_table == NULL) || (nt->server_table == NULL))
-		return NULL;
-
-	for(i = 0; i < size; ++i) {
-		nt->client_table[i] = NULL;
-		nt->server_table[i] = NULL;
-	}
-
-	nt->size = size;
-	return nt;
-}
-
-unsigned int gmtp_hash(struct gmtp_hashtable *hashtable, const __u8 *key)
-{
-	unsigned int hashval;
-	int i;
-
-	if(hashtable == NULL)
-		return -EINVAL;
-
-	if(key == NULL)
-		return -ENOKEY;
-
-	hashval = 0;
-	for(i=0; i<GMTP_FLOWNAME_LEN; ++i)
-		hashval = key[i] + (hashval << 5) - hashval;
-
-	return hashval % hashtable->size;
-}
-
-struct gmtp_client_entry *gmtp_lookup_client(
-		struct gmtp_hashtable *hashtable, const __u8 *flowname)
-{
-	struct gmtp_client_entry *entry;
-	unsigned int hashval;
-
-	hashval = gmtp_hash(hashtable, flowname);
-
-	/* Error */
-	if(hashval < 0)
-		return NULL;
-
-	entry = hashtable->client_table[hashval];
-	for(; entry != NULL; entry = entry->next)
-		if(memcmp(flowname, entry->flowname, GMTP_FLOWNAME_LEN) == 0)
-			return entry;
-	return NULL;
-}
-EXPORT_SYMBOL_GPL(gmtp_lookup_client);
-
-int gmtp_add_client_entry(struct gmtp_hashtable *hashtable, __u8 *flowname,
-		__be32 local_addr, __be16 local_port,
-		__be32 channel_addr, __be16 channel_port)
-{
-	struct gmtp_client_entry *new_entry;
-	struct gmtp_client_entry *cur_entry;
-	unsigned int hashval;
-
-	gmtp_print_function();
-
-	/** Primary key at client hashtable is flowname */
-	hashval = gmtp_hash(hashtable, flowname);
-
-	/* Error */
-	if(hashval < 0)
-		return hashval;
-
-	new_entry = kmalloc(sizeof(struct gmtp_client_entry), GFP_ATOMIC);
-	if(new_entry == NULL)
-		return 1;
-
-	cur_entry = gmtp_lookup_client(hashtable, flowname);
-	if(cur_entry != NULL)
-		return 2; /* TODO Media already being transmitted by other
-								server? */
-
-	memcpy(new_entry->flowname, flowname, GMTP_FLOWNAME_LEN);
-
-	new_entry->clients = kmalloc(sizeof(struct gmtp_client), GFP_ATOMIC);
-	if(new_entry->clients == NULL)
-		return 3;
-	INIT_LIST_HEAD(&new_entry->clients->list);
-
-	new_entry->channel_addr = channel_addr;
-	new_entry->channel_port = channel_port;
-
-	new_entry->next = hashtable->client_table[hashval];
-	hashtable->client_table[hashval] = new_entry;
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(gmtp_add_client_entry);
-
-void gmtp_del_client_list(struct gmtp_client_entry *entry)
-{
-	struct gmtp_client *client, *temp;
-	gmtp_pr_func();
-	list_for_each_entry_safe(client, temp, &(entry->clients->list), list)
-	{
-		list_del(&client->list);
-		kfree(client);
-	}
-}
-
-void gmtp_del_client_entry(struct gmtp_hashtable *hashtable, __u8 *media)
-{
-	struct gmtp_client_entry *entry;
-	int hashval;
-
-	gmtp_print_function();
-
-	hashval = gmtp_hash(hashtable, media);
-
-	if(hashval < 0)
-		return;
-
-	entry = hashtable->client_table[hashval];
-	if(entry != NULL) {
-		gmtp_del_client_list(entry);
-		kfree(entry);
-	}
-}
-
-/* Server Table functions */
-
-struct gmtp_server_entry *gmtp_lookup_route(
-		struct gmtp_hashtable *hashtable, const __u8 *relayid)
-{
-	struct gmtp_server_entry *entry;
-	unsigned int hashval;
-
-	hashval = gmtp_hash(hashtable, relayid);
-
-	/* Error */
-	if(hashval < 0)
-		return NULL;
-
-	entry = hashtable->server_table[hashval];
-	for(; entry != NULL; entry = entry->next)
-		if(!memcmp(relayid, entry->srelay->relay_id, GMTP_RELAY_ID_LEN))
-			return entry;
-	return NULL;
-}
-EXPORT_SYMBOL_GPL(gmtp_lookup_route);
-
-int gmtp_add_server_entry(struct gmtp_hashtable *hashtable, __u8 *relayid,
-		__u8 *flowname, struct gmtp_hdr_route *route)
-{
-	struct gmtp_server_entry *new_entry;
-	struct gmtp_server_entry *cur_entry;
-	unsigned int hashval;
-	__u8 nrelays = route->nrelays;
-
-	gmtp_print_function();
-
-	hashval = gmtp_hash(hashtable, relayid);
-
-	/* Error */
-	if(hashval < 0)
-		return hashval;
-
-	new_entry = kmalloc(sizeof(struct gmtp_server_entry), GFP_KERNEL);
-	if(new_entry == NULL)
-		return 1;
-
-	/* TODO Relay already registered */
-	cur_entry = gmtp_lookup_route(hashtable, relayid);
-	if(cur_entry != NULL)
-		return 2;
-
-	memcpy(new_entry->flowname, flowname, GMTP_FLOWNAME_LEN);
-	memcpy(&new_entry->route, route, sizeof(*route));
-	new_entry->srelay = &new_entry->route.relay_list[nrelays];
-
-	new_entry->next = hashtable->server_table[hashval];
-	hashtable->server_table[hashval] = new_entry;
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(gmtp_add_server_entry);
-
-void kfree_gmtp_hashtable(struct gmtp_hashtable *hashtable)
-{
-	int i;
-	struct gmtp_client_entry *c_entry, *ctmp;
-	struct gmtp_server_entry *s_entry, *stmp;
-
-	gmtp_print_function();
-
-	if(hashtable == NULL)
-		return;
-
-	for(i = 0; i < hashtable->size; ++i) {
-		c_entry = hashtable->client_table[i];
-		while(c_entry != NULL) {
-			ctmp = c_entry;
-			gmtp_del_client_list(ctmp);
-			c_entry = c_entry->next;
-			kfree(ctmp);
-		}
-	}
-
-	for(i = 0; i < hashtable->size; ++i) {
-		s_entry = hashtable->server_table[i];
-		while(s_entry != NULL) {
-			stmp = s_entry;
-			s_entry = s_entry->next;
-			kfree(stmp);
-		}
-	}
-
-	kfree(hashtable->client_table);
-	kfree(hashtable->server_table);
-	kfree(hashtable);
-}
diff --git a/linux-4.0.3/net/gmtp/hash.h b/linux-4.0.3/net/gmtp/hash.h
index 9202f1c..85cf332 100644
--- a/linux-4.0.3/net/gmtp/hash.h
+++ b/linux-4.0.3/net/gmtp/hash.h
@@ -1,83 +1,14 @@
 /*
  * hash.h
  *
- *  Created on: 07/05/2015
+ *  Created on: 23/06/2015
  *      Author: wendell
  */
 
 #ifndef HASH_H_
 #define HASH_H_
 
-#include "gmtp.h"
+#include "hash/hash.h"
 
-#define GMTP_HASH_SIZE  16
-
-/**
- * struct gmtp_client_entry - An entry in client hash table
- *
- * flowname[GMTP_FLOWNAME_LEN];
- * local_addr:	local client IP address
- * local_port:	local client port
- * channel_addr: multicast channel to receive media
- * channel_port: multicast port to receive media
- */
-struct gmtp_client_entry {
-	struct gmtp_client_entry *next; /** It must be the first */
-
-	__u8 			flowname[GMTP_FLOWNAME_LEN];
-
-	struct gmtp_client 	*clients;
-	__be32 			channel_addr;
-	__be16 			channel_port;
-};
-
-
-/**
- * struct gmtp_server_entry - An entry in server hash table
- *
- * @next: 	the next entry with the same key (hash)
- * @srelay: 	source of route (route[route->nrelays]).
- * 			the primary key at table is 'srelay->relayid'
- * @route:	the route stored in table
- */
-struct gmtp_server_entry {
-	struct gmtp_server_entry *next; /** It must be the first */
-
-	struct gmtp_relay *srelay;
-	__u8 flowname[GMTP_FLOWNAME_LEN];
-	struct gmtp_hdr_route route;
-};
-
-/**
- * struct gmtp_hashtable - The GMTP hash table
- *
- * @size: 	the max number of entries in hash table (fixed)
- * @table:	the array of table entries
- * 			(it can be a client or a server entry)
- */
-/* TODO Make routes_entry and relays_entry
- * Make a list of relays instead a array... */
-struct gmtp_hashtable {
-	int size;
-	struct gmtp_client_entry **client_table;
-	struct gmtp_server_entry **server_table;
-};
-
-/** Client */
-struct gmtp_hashtable *gmtp_create_hashtable(unsigned int size);
-struct gmtp_client_entry *gmtp_lookup_client(
-		struct gmtp_hashtable *hashtable, const __u8 *media);
-int gmtp_add_client_entry(struct gmtp_hashtable *hashtable, __u8 *flowname,
-		__be32 local_addr, __be16 local_port,
-		__be32 channel_addr, __be16 channel_port);
-void gmtp_del_client_entry(struct gmtp_hashtable *hashtable, __u8 *media);
-
-/** Server */
-struct gmtp_server_entry *gmtp_lookup_route(
-		struct gmtp_hashtable *hashtable, const __u8 *relayid);
-int gmtp_add_server_entry(struct gmtp_hashtable *hashtable, __u8 *relayid,
-		__u8 *flowname, struct gmtp_hdr_route *route);
-
-void kfree_gmtp_hashtable(struct gmtp_hashtable *hashtable);
 
 #endif /* HASH_H_ */
diff --git a/linux-4.0.3/net/gmtp/hash/hash.c b/linux-4.0.3/net/gmtp/hash/hash.c
new file mode 100644
index 0000000..d6f99bb
--- /dev/null
+++ b/linux-4.0.3/net/gmtp/hash/hash.c
@@ -0,0 +1,132 @@
+/*
+ * hash.c
+ *
+ *  Created on: 27/02/2015
+ *      Author: mario
+ */
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+
+#include "../gmtp.h"
+#include "hash.h"
+
+struct gmtp_hashtable *gmtp_build_hashtable(unsigned int size,
+		struct gmtp_hash_ops hash_ops)
+{
+	int i;
+	struct gmtp_hashtable *new_table;
+
+	gmtp_print_function();
+	gmtp_print_debug("Size of gmtp_hashtable: %d", size);
+
+	if(size < 1)
+		return NULL;
+
+	new_table = kmalloc(sizeof(struct gmtp_hashtable), GFP_KERNEL);
+	if(new_table == NULL)
+		return NULL;
+
+	new_table->entry = kmalloc(sizeof(void*) * size, GFP_KERNEL);
+
+	if(new_table->entry == NULL)
+		return NULL;
+
+	for(i = 0; i < size; ++i)
+		new_table->entry[i] = NULL;
+
+	new_table->size = size;
+	new_table->hash_ops = hash_ops;
+
+	return new_table;
+}
+EXPORT_SYMBOL_GPL(gmtp_build_hashtable);
+
+void kfree_gmtp_hashtable(struct gmtp_hashtable *table)
+{
+	table->hash_ops.destroy(table);
+}
+EXPORT_SYMBOL_GPL(kfree_gmtp_hashtable);
+
+unsigned int gmtp_hash(struct gmtp_hashtable *table, const __u8 *key)
+{
+	unsigned int hashval;
+	int i;
+
+	if(unlikely(table == NULL))
+		return -EINVAL;
+
+	if(unlikely(key == NULL))
+		return -ENOKEY;
+
+	hashval = 0;
+	for(i = 0; i < GMTP_HASH_KEY_LEN; ++i)
+		hashval = key[i] + (hashval << 5) - hashval;
+
+	return hashval % table->size;
+}
+
+struct gmtp_hash_entry *gmtp_lookup_entry(struct gmtp_hashtable *table,
+		const __u8 *key)
+{
+	struct gmtp_hash_entry *entry;
+	unsigned int hashval = table->hash_ops.hash(table, key);
+
+	/* Error */
+	if(hashval < 0)
+		return NULL;
+
+	entry = table->entry[hashval];
+	for(; entry != NULL; entry = entry->next)
+		if(memcmp(key, entry->key, GMTP_HASH_KEY_LEN) == 0)
+			return entry;
+	return NULL;
+}
+
+int gmtp_add_entry(struct gmtp_hashtable *table, struct gmtp_hash_entry *entry)
+{
+	struct gmtp_hash_entry *cur_entry;
+	unsigned int hashval;
+
+	gmtp_print_function();
+
+	hashval = table->hash_ops.hash(table, entry->key);
+	if(hashval < 0)
+		return hashval;
+
+	/** Primary key at client hashtable is flowname */
+	cur_entry = table->hash_ops.lookup(table, entry->key);
+	if(cur_entry != NULL)
+		return 1; /* Entry already exists */
+
+	entry->next = table->entry[hashval];
+	table->entry[hashval] = entry;
+
+	return 0;
+}
+
+void destroy_gmtp_hashtable(struct gmtp_hashtable *table)
+{
+	int i;
+	struct gmtp_hash_entry *entry, *tmp;
+
+	gmtp_print_function();
+
+	if(table == NULL)
+		return;
+
+	for(i = 0; i < table->size; ++i) {
+		entry = table->entry[i];
+		while(entry != NULL) {
+			tmp = entry;
+			entry = entry->next;
+			table->hash_ops.del_entry(table, tmp->key);
+		}
+	}
+
+	kfree(table->entry);
+	kfree(table);
+}
+
+
diff --git a/linux-4.0.3/net/gmtp/hash/hash.h b/linux-4.0.3/net/gmtp/hash/hash.h
new file mode 100644
index 0000000..a114ee7
--- /dev/null
+++ b/linux-4.0.3/net/gmtp/hash/hash.h
@@ -0,0 +1,135 @@
+/*
+ * hash.h
+ *
+ *  Created on: 07/05/2015
+ *      Author: wendell
+ */
+
+#ifndef HASH_INTRA_H_
+#define HASH_INTRA_H_
+
+#define GMTP_HASH_KEY_LEN  16
+
+struct gmtp_hashtable;
+
+/**
+ * struct gmtp_hash_ops - The GMTP hash table operations
+ */
+struct gmtp_hash_ops {
+	unsigned int (*hash)(struct gmtp_hashtable *table, const __u8 *key);
+	struct gmtp_hash_entry *(*lookup)(struct gmtp_hashtable *table,
+			const __u8 *key);
+	int (*add_entry)(struct gmtp_hashtable *table,
+			struct gmtp_hash_entry *entry);
+	void (*del_entry)(struct gmtp_hashtable *table, const __u8 *key);
+	void (*destroy)(struct gmtp_hashtable *table);
+};
+
+extern const struct gmtp_hash_ops gmtp_client_hash_ops;
+extern const struct gmtp_hash_ops gmtp_server_hash_ops;
+
+/**
+ * struct gmtp_hash_entry - The GMTP hash table entry
+ *
+ * @flowname:	the key of hash table entry
+ * @next: 	the next entry with the same key (hash)
+ */
+struct gmtp_hash_entry {
+	__u8 				key[GMTP_HASH_KEY_LEN];
+	struct gmtp_hash_entry		*next;
+};
+
+/**
+ * struct gmtp_hashtable - The GMTP hash table
+ *
+ * @size: 		the max number of entries in hash table (fixed)
+ * @gmtp_hash_ops: 	the operations of hashtable
+ * @table:		the array of table entries
+ * 			(it can be a client or a server entry)
+ */
+struct gmtp_hashtable {
+	int 				size;
+
+	struct gmtp_hash_entry		**entry;
+	struct gmtp_hash_ops		hash_ops;
+};
+
+/** hash.c */
+struct gmtp_hashtable *gmtp_build_hashtable(unsigned int size,
+		struct gmtp_hash_ops hash_ops);
+unsigned int gmtp_hash(struct gmtp_hashtable *table, const __u8 *key);
+struct gmtp_hash_entry *gmtp_lookup_entry(struct gmtp_hashtable *table,
+		const __u8 *key);
+int gmtp_add_entry(struct gmtp_hashtable *table, struct gmtp_hash_entry *entry);
+void destroy_gmtp_hashtable(struct gmtp_hashtable *table);
+void kfree_gmtp_hashtable(struct gmtp_hashtable *table);
+
+/**
+ * struct gmtp_client_entry - An entry in client hash table
+ *
+ * clients: clients connected to flowname
+ * channel_addr: multicast channel to receive media
+ * channel_port: multicast port to receive media
+ */
+struct gmtp_client_entry {
+	/* gmtp_hash_entry has to be the first member of gmtp_client_entry */
+	struct gmtp_hash_entry		entry;
+
+	struct gmtp_client 		*clients;
+	__be32 				channel_addr;
+	__be16 				channel_port;
+};
+
+
+int gmtp_add_client_entry(struct gmtp_hashtable *table,
+		const __u8 *flowname, __be32 local_addr, __be16 local_port,
+		__be32 channel_addr, __be16 channel_port);
+struct gmtp_client_entry *gmtp_lookup_client(struct gmtp_hashtable *table,
+		const __u8 *key);
+void gmtp_del_client_entry(struct gmtp_hashtable *table, const __u8 *key);
+
+/** Servers **/
+
+/**
+ * struct gmtp_server_entry - An entry in server hash table
+ *
+ * @srelay: 	source of route (route[route->nrelays]).
+ * 			the primary key at table is 'srelay->relayid'
+ * @route:	the route stored in table
+ * @next: 	the next entry with the same key (hash)
+ */
+struct gmtp_server_entry {
+	/* gmtp_hash_entry has to be the first member of gmtp_client_entry */
+	struct gmtp_hash_entry		entry;
+
+	struct gmtp_hashtable 		*relay_hashtable;
+};
+
+int gmtp_add_server_entry(struct gmtp_hashtable *table, const __u8 *flowname,
+		struct gmtp_hdr_route *route);
+
+/**
+ * struct gmtp_relay_table_entry - An entry in relays hash table (in server)
+ * @next: 	the next entry with the same key (hash)
+ *
+ * @relay: the relay info
+ * @nextRelay: 	the next relay in path
+ * @relay_id: the relay id (key)
+ * @relay_ip: the relay ip
+ *
+ * @list:  the list head
+ */
+struct gmtp_relay_entry {
+	struct gmtp_hash_entry		entry;
+
+	struct gmtp_relay 		relay;
+	struct gmtp_relay_entry		*nextRelay;
+	struct gmtp_relay_entry		*prevRelayList;
+
+	struct list_head 		list;
+};
+
+
+
+
+#endif /* HASH_INTRA_H_ */
diff --git a/linux-4.0.3/net/gmtp/hash/hash_client.c b/linux-4.0.3/net/gmtp/hash/hash_client.c
new file mode 100644
index 0000000..514099c
--- /dev/null
+++ b/linux-4.0.3/net/gmtp/hash/hash_client.c
@@ -0,0 +1,92 @@
+/*
+ * hash.c
+ *
+ *  Created on: 27/02/2015
+ *      Author: mario
+ */
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+
+#include "../gmtp.h"
+#include "hash.h"
+
+struct gmtp_hashtable* client_hashtable;
+EXPORT_SYMBOL_GPL(client_hashtable);
+
+int gmtp_add_client_entry(struct gmtp_hashtable *table,
+		const __u8 *flowname, __be32 local_addr, __be16 local_port,
+		__be32 channel_addr, __be16 channel_port)
+{
+	struct gmtp_client_entry *new_entry;
+
+	new_entry = kmalloc(sizeof(struct gmtp_client_entry), GFP_ATOMIC);
+	if(new_entry == NULL)
+		return 1;
+
+	memcpy(new_entry->entry.key, flowname, GMTP_HASH_KEY_LEN);
+	new_entry->clients = kmalloc(sizeof(struct gmtp_client), GFP_ATOMIC);
+	if(new_entry->clients == NULL)
+		return 2;
+	INIT_LIST_HEAD(&new_entry->clients->list);
+
+	new_entry->channel_addr = channel_addr;
+	new_entry->channel_port = channel_port;
+
+	return table->hash_ops.add_entry(table,
+			(struct gmtp_hash_entry*) new_entry);
+}
+EXPORT_SYMBOL_GPL(gmtp_add_client_entry);
+
+struct gmtp_client_entry *gmtp_lookup_client(struct gmtp_hashtable *table,
+		const __u8 *key)
+{
+	return (struct gmtp_client_entry *) table->hash_ops.lookup(table, key);
+}
+EXPORT_SYMBOL_GPL(gmtp_lookup_client);
+
+void gmtp_del_client_entry(struct gmtp_hashtable *table, const __u8 *key)
+{
+	table->hash_ops.del_entry(table, key);
+}
+EXPORT_SYMBOL_GPL(gmtp_del_client_entry);
+
+void gmtp_del_client_list(struct gmtp_client_entry *entry)
+{
+	struct gmtp_client *client, *temp;
+	gmtp_pr_func();
+	list_for_each_entry_safe(client, temp, &(entry->clients->list), list)
+	{
+		list_del(&client->list);
+		kfree(client);
+	}
+}
+
+void gmtp_del_client_hash_entry(struct gmtp_hashtable *table, const __u8 *key)
+{
+	struct gmtp_client_entry *entry;
+	int hashval;
+
+	gmtp_print_function();
+
+	hashval = table->hash_ops.hash(table, key);
+	if(hashval < 0)
+		return;
+
+	entry = (struct gmtp_client_entry*) table->entry[hashval];
+	if(entry != NULL) {
+		gmtp_del_client_list(entry);
+		kfree(entry);
+	}
+}
+
+const struct gmtp_hash_ops gmtp_client_hash_ops = {
+		.hash = gmtp_hash,
+		.lookup = gmtp_lookup_entry,
+		.add_entry = gmtp_add_entry,
+		.del_entry = gmtp_del_client_hash_entry,
+		.destroy = destroy_gmtp_hashtable,
+};
+
+
diff --git a/linux-4.0.3/net/gmtp/hash/hash_server.c b/linux-4.0.3/net/gmtp/hash/hash_server.c
new file mode 100644
index 0000000..29d791d
--- /dev/null
+++ b/linux-4.0.3/net/gmtp/hash/hash_server.c
@@ -0,0 +1,164 @@
+/*
+ * hash.c
+ *
+ *  Created on: 27/02/2015
+ *      Author: mario
+ */
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+
+#include "../gmtp.h"
+#include "hash.h"
+
+struct gmtp_hashtable* server_hashtable;
+EXPORT_SYMBOL_GPL(server_hashtable);
+
+void gmtp_del_relay_hash_entry(struct gmtp_hashtable *table, const __u8 *key);
+
+const struct gmtp_hash_ops gmtp_relay_hash_ops = {
+		.hash = gmtp_hash,
+		.lookup = gmtp_lookup_entry,
+		.add_entry = gmtp_add_entry,
+		.del_entry = gmtp_del_relay_hash_entry,
+		.destroy = destroy_gmtp_hashtable,
+};
+
+static struct gmtp_relay_entry *gmtp_build_relay_entry(
+		const struct gmtp_relay *relay)
+{
+	struct gmtp_relay_entry *entry;
+	entry = kmalloc(sizeof(struct gmtp_relay_entry), GFP_KERNEL);
+	if(entry == NULL)
+		return NULL;
+
+	entry->nextRelay = NULL;
+	entry->prevRelayList = NULL;
+
+	memcpy(entry->entry.key, relay->relay_id, GMTP_HASH_KEY_LEN);
+	memcpy(&entry->relay, relay, sizeof(struct gmtp_relay));
+
+	return entry;
+}
+
+int gmtp_add_relay_entries(struct gmtp_hashtable *rtable,
+		struct gmtp_hdr_route *route)
+{
+	int i, err = 0;
+	struct gmtp_relay_entry *nextRelay = NULL;
+	struct gmtp_relay_entry *prevRelay = NULL;
+
+	gmtp_pr_func();
+
+	for(i = route->nrelays - 1; (i >= 0) && (!err); --i) {
+		struct gmtp_relay_entry *entry;
+		
+		entry = rtable->hash_ops.lookup(rtable,
+				route->relay_list[i].relay_id);
+
+		if(entry == NULL) {
+			entry = gmtp_build_relay_entry(&route->relay_list[i]);
+			if(entry == NULL)
+				return 1;
+		}
+
+		entry->nextRelay = nextRelay;
+		if(entry->nextRelay != NULL) {
+			INIT_LIST_HEAD(&entry->nextRelay->prevRelayList->list);
+			list_add_tail(&entry->nextRelay->prevRelayList->list,
+					entry);
+		}
+		nextRelay = entry;
+
+		err = rtable->hash_ops.add_entry(rtable,
+				(struct gmtp_hash_entry*)entry);
+
+		print_gmtp_relay(&entry->relay);
+		pr_info("entry->nextRelay: %p\n", entry->nextRelay);
+		pr_info("entry->prevRelayList: %p\n", entry->nextRelay);
+	}
+
+	return err;
+}
+
+int gmtp_add_server_entry(struct gmtp_hashtable *table, const __u8 *flowname,
+		struct gmtp_hdr_route *route)
+{
+	struct gmtp_server_entry *entry;
+
+	gmtp_pr_func();
+
+	entry = table->hash_ops.lookup(table, flowname);
+
+	if(entry == NULL) {
+
+		entry = kmalloc(sizeof(struct gmtp_server_entry), GFP_KERNEL);
+		if(entry == NULL)
+			return 1;
+
+		memcpy(entry->entry.key, flowname, GMTP_HASH_KEY_LEN);
+		entry->relay_hashtable = gmtp_build_hashtable(U8_MAX,
+				gmtp_relay_hash_ops);
+	}
+
+	if(gmtp_add_relay_entries(entry->relay_hashtable, route))
+		return 1;
+
+	return table->hash_ops.add_entry(table, (struct gmtp_hash_entry*)entry);
+}
+EXPORT_SYMBOL_GPL(gmtp_add_server_entry);
+
+void gmtp_del_relay_list(struct gmtp_relay_entry *entry)
+{
+	struct gmtp_relay_entry *relay, *temp;
+	gmtp_pr_func();
+	list_for_each_entry_safe(relay, temp, &entry->list, list)
+	{
+		list_del(&relay->list);
+	}
+}
+
+void gmtp_del_relay_hash_entry(struct gmtp_hashtable *table, const __u8 *key)
+{
+	struct gmtp_relay_entry *entry;
+	int hashval;
+
+	gmtp_print_function();
+
+	hashval = table->hash_ops.hash(table, key);
+	if(hashval < 0)
+		return;
+
+	entry = (struct gmtp_relay_entry*) table->entry[hashval];
+	if(entry != NULL) {
+		gmtp_del_relay_list(entry);
+		kfree(entry);
+	}
+}
+
+void gmtp_del_server_hash_entry(struct gmtp_hashtable *table, const __u8 *key)
+{
+	struct gmtp_server_entry *entry;
+	int hashval;
+
+	gmtp_print_function();
+
+	hashval = table->hash_ops.hash(table, key);
+	if(hashval < 0)
+		return;
+
+	entry = (struct gmtp_server_entry*) table->entry[hashval];
+	if(entry != NULL) {
+		/*entry->relay_hashtable->hash_ops.destroy(entry->relay_hashtable);*/
+		kfree(entry);
+	}
+}
+
+const struct gmtp_hash_ops gmtp_server_hash_ops = {
+		.hash = gmtp_hash,
+		.lookup = gmtp_lookup_entry,
+		.add_entry = gmtp_add_entry,
+		.del_entry = gmtp_del_server_hash_entry,
+		.destroy = destroy_gmtp_hashtable,
+};
diff --git a/linux-4.0.3/net/gmtp/input.c b/linux-4.0.3/net/gmtp/input.c
index 6fb9b47..2f19a11 100644
--- a/linux-4.0.3/net/gmtp/input.c
+++ b/linux-4.0.3/net/gmtp/input.c
@@ -13,6 +13,7 @@
 
 #include <uapi/linux/gmtp.h>
 #include "gmtp.h"
+#include "hash.h"
 #include "mcc.h"
 
 static void gmtp_enqueue_skb(struct sock *sk, struct sk_buff *skb)
@@ -173,7 +174,7 @@ static int gmtp_rcv_request_sent_state_process(struct sock *sk,
 {
 	struct gmtp_sock *gp = gmtp_sk(sk);
 	const struct inet_connection_sock *icsk = inet_csk(sk);
-	struct gmtp_client_entry *media_entry;
+	struct gmtp_client_entry *client_entry;
 
 	gmtp_pr_func();
 
@@ -183,8 +184,8 @@ static int gmtp_rcv_request_sent_state_process(struct sock *sk,
 	}
 	gmtp_pr_debug("Packet received: %s", gmtp_packet_name(gh->type));
 
-	media_entry = gmtp_lookup_client(gmtp_hashtable, gh->flowname);
-	if(media_entry == NULL)
+	client_entry = gmtp_lookup_client(client_hashtable, gh->flowname);
+	if(client_entry == NULL)
 		goto out_invalid_packet;
 
 	/*** FIXME Check sequence numbers  ***/
@@ -260,8 +261,8 @@ static int gmtp_rcv_request_sent_state_process(struct sock *sk,
 		}
 
 		/* Inserting information in client table */
-		media_entry->channel_addr = gh_rnotify->mcst_addr;
-		media_entry->channel_port = gh_rnotify->mcst_port;
+		client_entry->channel_addr = gh_rnotify->mcst_addr;
+		client_entry->channel_port = gh_rnotify->mcst_port;
 
 		gp->channel_sk = gmtp_multicast_connect(sk,
 				GMTP_SOCK_TYPE_DATA_CHANNEL,
@@ -311,7 +312,7 @@ err:
  	 * We mark this socket as no longer usable, so that the loop in
  	 * gmtp_sendmsg() terminates and the application gets notified.
  	 */
-	gmtp_del_client_entry(gmtp_hashtable, gp->flowname);
+	gmtp_del_client_entry(client_hashtable, gp->flowname);
  	gmtp_set_state(sk, GMTP_CLOSED);
  	sk->sk_err = ECOMM;
  	return 1;
@@ -439,19 +440,15 @@ int gmtp_rcv_route_notify(struct sock *sk, struct sk_buff *skb,
 			 const struct gmtp_hdr *gh)
 {
 	struct gmtp_hdr_route *route = gmtp_hdr_route(skb);
-	struct gmtp_relay *relay;
-	__u8 nrelays = route->nrelays;
 
 	gmtp_print_function();
+
 	print_route(route);
 
-	if(nrelays <= 0)
+	if(route->nrelays <= 0)
 		return 0;
 
-	relay = &route->relay_list[nrelays-1];
-
-	gmtp_add_server_entry(gmtp_hashtable, relay->relay_id,
-			(__u8*)gh->flowname, route);
+	gmtp_add_server_entry(server_hashtable, gh->flowname, route);
 
 	return 0;
 }
diff --git a/linux-4.0.3/net/gmtp/ipv4.c b/linux-4.0.3/net/gmtp/ipv4.c
index 7b181d1..a05f48c 100644
--- a/linux-4.0.3/net/gmtp/ipv4.c
+++ b/linux-4.0.3/net/gmtp/ipv4.c
@@ -563,7 +563,7 @@ static int gmtp_v4_reporter_rcv_elect_request(struct sk_buff *skb)
 
 	gmtp_pr_func();
 
-	media_entry = gmtp_lookup_client(gmtp_hashtable, gh->flowname);
+	media_entry = gmtp_lookup_client(client_hashtable, gh->flowname);
 	if(media_entry == NULL) {
 		pr_info("Media entry == NULL\n");
 		return 1;
@@ -602,7 +602,7 @@ static int gmtp_v4_client_rcv_elect_response(struct sk_buff *skb)
 
 	gmtp_pr_func();
 
-	media_entry = gmtp_lookup_client(gmtp_hashtable, gh->flowname);
+	media_entry = gmtp_lookup_client(client_hashtable, gh->flowname);
 	if(media_entry == NULL) {
 		pr_info("Media entry == NULL\n");
 		return 1;
@@ -672,7 +672,7 @@ static int gmtp_v4_reporter_rcv_ack(struct sk_buff *skb)
 
 	gmtp_pr_func();
 
-	media_entry = gmtp_lookup_client(gmtp_hashtable, gh->flowname);
+	media_entry = gmtp_lookup_client(client_hashtable, gh->flowname);
 	if(media_entry == NULL) {
 		pr_info("Media entry == NULL\n");
 		return 1;
@@ -866,7 +866,7 @@ static int gmtp_v4_rcv(struct sk_buff *skb)
 
 		struct gmtp_client *tmp;
 		struct gmtp_client_entry *media_entry = gmtp_lookup_client(
-				gmtp_hashtable, gh->flowname);
+				client_hashtable, gh->flowname);
 
 		if(media_entry == NULL)
 			goto discard_it;
diff --git a/linux-4.0.3/net/gmtp/output.c b/linux-4.0.3/net/gmtp/output.c
index 5b73653..549628e 100644
--- a/linux-4.0.3/net/gmtp/output.c
+++ b/linux-4.0.3/net/gmtp/output.c
@@ -316,12 +316,12 @@ int gmtp_connect(struct sock *sk)
 	skb_reserve(skb, sk->sk_prot->max_header);
 	GMTP_SKB_CB(skb)->type = GMTP_PKT_REQUEST;
 
-	client_entry = gmtp_lookup_client(gmtp_hashtable, gp->flowname);
+	client_entry = gmtp_lookup_client(client_hashtable, gp->flowname);
 	if(client_entry == NULL)
-		err = gmtp_add_client_entry(gmtp_hashtable, gp->flowname,
+		err = gmtp_add_client_entry(client_hashtable, gp->flowname,
 				inet->inet_saddr, inet->inet_sport, 0, 0);
 
-	client_entry = gmtp_lookup_client(gmtp_hashtable, gp->flowname);
+	client_entry = gmtp_lookup_client(client_hashtable, gp->flowname);
 	if(err != 0 || client_entry == NULL) {
 		return -ENOBUFS;
 	}
diff --git a/linux-4.0.3/net/gmtp/proto.c b/linux-4.0.3/net/gmtp/proto.c
index 9b27449..062ee99 100644
--- a/linux-4.0.3/net/gmtp/proto.c
+++ b/linux-4.0.3/net/gmtp/proto.c
@@ -19,9 +19,6 @@ EXPORT_SYMBOL_GPL(gmtp_orphan_count);
 struct inet_hashinfo gmtp_inet_hashinfo;
 EXPORT_SYMBOL_GPL(gmtp_inet_hashinfo);
 
-struct gmtp_hashtable* gmtp_hashtable;
-EXPORT_SYMBOL_GPL(gmtp_hashtable);
-
 struct gmtp_info* gmtp_info;
 EXPORT_SYMBOL_GPL(gmtp_info);
 
@@ -121,28 +118,25 @@ void print_gmtp_packet(const struct iphdr *iph, const struct gmtp_hdr *gh)
 }
 EXPORT_SYMBOL_GPL(print_gmtp_packet);
 
-/**
- * @str size MUST HAVE len >= GMTP_FLOWNAME_STR_LEN
- */
-void relayid_str(__u8* str, const __u8 *relayid)
+void print_gmtp_relay(const struct gmtp_relay *relay)
 {
-	flowname_str(str, relayid);
+	unsigned char relayid[GMTP_FLOWNAME_STR_LEN];
+	flowname_str(relayid, relay->relay_id);
+	pr_info("%s :: %pI4\n", relayid, &relay->relay_ip);
 }
+EXPORT_SYMBOL_GPL(print_gmtp_relay);
 
 void print_route(struct gmtp_hdr_route *route)
 {
 	int i;
-	unsigned char relayid[GMTP_RELAY_ID_LEN];
-	const struct gmtp_relay *gr;
+	unsigned char relayid[GMTP_FLOWNAME_STR_LEN];
 
 	if(route->nrelays <= 0)
 		return;
 
-	gr = &route->relay_list[route->nrelays-1];
-	relayid_str(relayid, gr->relay_id);
-
-	for(i=0; i < route->nrelays; ++i)
-		pr_info("Route[%d]: %s :: %pI4\n", i, relayid, &gr->relay_ip);
+	pr_info("Route: \n");
+	for(i = route->nrelays - 1; i >= 0; --i)
+		print_gmtp_relay(&route->relay_list[i]);
 }
 EXPORT_SYMBOL_GPL(print_route);
 
@@ -711,14 +705,6 @@ void gmtp_shutdown(struct sock *sk, int how)
 }
 EXPORT_SYMBOL_GPL(gmtp_shutdown);
 
-void kfree_gmtp_info(struct gmtp_info *gmtp)
-{
-	kfree(gmtp_info->control_sk);
-	kfree(gmtp_info->ctrl_addr);
-	kfree(gmtp_info);
-}
-
-
 /* TODO Study thash_entries... This is from DCCP thash_entries */
 static int thash_entries;
 module_param(thash_entries, int, 0444);
@@ -832,7 +818,7 @@ out_fail:
 	return rc;
 }
 
-static int ghash_entries = 256;
+static int ghash_entries = 1024;
 module_param(ghash_entries, int, 0444);
 MODULE_PARM_DESC(ghash_entries, "Number of GMTP hash entries");
 
@@ -852,8 +838,11 @@ static int __init gmtp_init(void)
 		goto out;
 	}
 
-	gmtp_hashtable = gmtp_create_hashtable(ghash_entries);
-	if(gmtp_hashtable == NULL) {
+	client_hashtable = gmtp_build_hashtable(ghash_entries,
+			gmtp_client_hash_ops);
+	server_hashtable = gmtp_build_hashtable(ghash_entries,
+			gmtp_server_hash_ops);
+	if(client_hashtable == NULL || server_hashtable == NULL) {
 		rc = -ENOBUFS;
 		goto out;
 	}
@@ -864,6 +853,8 @@ static int __init gmtp_init(void)
 		goto out;
 	}
 	gmtp_info->relay_enabled = 0;
+	gmtp_info->control_sk = NULL;
+	gmtp_info->ctrl_addr = NULL;
 
 	rc = gmtp_create_inet_hashinfo();
 	if(rc)
@@ -887,7 +878,9 @@ static void __exit gmtp_exit(void)
 	kmem_cache_destroy(gmtp_inet_hashinfo.bind_bucket_cachep);
 
 	kfree_gmtp_info(gmtp_info);
-	kfree_gmtp_hashtable(gmtp_hashtable);
+	kfree_gmtp_hashtable(client_hashtable);
+	kfree_gmtp_hashtable(server_hashtable);
+
 	percpu_counter_destroy(&gmtp_orphan_count);
 	mcc_lib_exit();
 }
